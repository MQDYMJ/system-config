#!/bin/bash
set -e

function die() {
    echo Error: "$@"
    exit -1
}


## start code-generator "^\\s *#\\s *"
# generate-getopt p:prepend P:postpend aask-replacer=true f:change-files='()' @:perl-re=-P ?'by default, use grep -P (perl re), --perl-re="" to overide this'
## end code-generator
## start generated code
TEMP=$(getopt -o P:f:ap:h \
              --long perl-re:,postpend:,change-files:,ask-replacer,prepend:,help,no-ask-replacer \
              -n $(basename -- $0) -- "$@")
perl_re=-P
postpend=
change_files=()
ask_replacer=true
prepend=
eval set -- "$TEMP"
while true; do
    case "$1" in

        --perl-re)
            perl_re=$2
            shift 2
            ;;
        -P|--postpend)
            postpend=$2
            shift 2
            ;;
        -f|--change-files)
            change_files=("${change_files[@]}" "$2")
            shift 2
            ;;
        -a|--ask-replacer|--no-ask-replacer)
            if test "$1" = --no-ask-replacer; then
                ask_replacer=false
            else
                ask_replacer=true
            fi
            shift
            ;;
        -p|--prepend)
            prepend=$2
            shift 2
            ;;
        -h|--help)
            set +x
            echo
            echo
            echo Options and arguments:
            printf %06s '-a, '
            printf %-24s '--[no-]ask-replacer'
            echo
            printf %06s '-f, '
            printf %-24s '--change-files=CHANGE_FILES'
            echo
            printf "%06s" " "
            printf %-24s '--perl-re=PERL_RE'
            echo 'by default, use grep -P (perl re), --perl-re="" to overide this'
            printf %06s '-P, '
            printf %-24s '--postpend=POSTPEND'
            echo
            printf %06s '-p, '
            printf %-24s '--prepend=PREPEND'
            echo
            exit
            shift
            ;;
        --)
            shift
            break
            ;;
        *)
            die "internal error"
            ;;
    esac
done


## end generated code

export ask_replacer
export prepend
export postpend

if test -z "$prepend" -a -z "$postpend" && [[ "$1" =~ ^\\b.*\\b$ ]]; then
    prepend="\b"
    postpend="\b"
fi

if test $# != 2; then
    die "Error: Usage $(basename $0) from to"
fi

# set -- "$(printf %q "$1")" "$(printf %q "$2")"
export ARG1=$1
export ARG2=$2


function die() {
    echo "$@"
    exit 1
}

function debug() {
    echo "$@" 1>&2
}

IFS=$'\n'

function get-files-r() {
    if test "${#change_files[@]}" != 0; then
        for x in "${change_files[@]}"; do
            echo "$x"
        done
    else
        find . -name '.git' -prune -o -type f -print | perl -npe 's#^\./##';
    fi
}

function get-files-this-dir() {
    if test "${#change_files[@]}" != 0; then
        for x in "${change_files[@]}"; do
            echo "$x"
        done
    else
        find . -maxdepth 1 -name '.git' -prune -o -print | perl -npe 's#^\./##' | grep -v $perl_re -e '^\.$';
    fi
}

if ! git-is-clean .; then
    git-interactive-add
    git-is-clean .
fi

test $# = 0 && die "must provide at least 2 args"
tmpf=/tmp/$(basename $0).$$
perlhash=$tmpf.hash
get-files-r > $tmpf
echo shit > $tmpf.tmp
cat $tmpf |
xargs -d \\n grep $perl_re -l -i -I -e "$1" |
xargs -d \\n bash -c 'for x in "$@"; do test -f "$x" -a ! -L "$x" && echo "$x is a match" 1>&2 && echo "$x"; done; echo '$tmpf.tmp true |
xargs -d \\n perl -npe '
BEGIN{
    $from = $ENV{ARG1};
    $to = $ENV{ARG2};
    $prepend = $ENV{prepend};
    $postpend = $ENV{postpend};

    warn "from is $from, to is $to\n";
}

$rep_save{$from} = $to;
$rep_save{lc $from} = lc $to unless (lc $from eq $from);
$rep_save{uc $from} = uc $to unless (uc $from eq $from);
$rep_save{ucfirst lc $from} = ucfirst lc $to unless (ucfirst $from eq $from);

while (m#($prepend$from$postpend)#ig) {
    if (defined $rep_save{$1}) {
        next;
    } else {
        if ($ENV{ask_replacer} eq "true") {
            system("echo please input your replacement for \"$1\" > /tmp/get-stdin.$$");
            chomp($rep_save{$1} = qx(get-stdin /tmp/get-stdin.$$));
            $rep_save{$1} =~ s/^please input your replacement for //;
        } else {
            $rep_save{$1} = $to;
        }
    }
}

for $key (keys %rep_save) {
    my ($from, $to) = ($key, $rep_save{$key});
    s/$prepend\Q$from\E$postpend/$to/g;
}

END {
    use Storable;
    store \%rep_save, "'$perlhash'";
}
' -i

function compute-new-string() {
echo "$@"|perl -npe '
BEGIN{
    use Storable;
    %rep_save = %{retrieve("'$perlhash'")};
    $prepend = $ENV{prepend};
    $postpend = $ENV{postpend};
}

for $key (keys %rep_save) {
    my ($from, $to) = ($key, $rep_save{$key});
    s/$prepend$from$postpend/$to/g;
}
'
}

function rename-files() {
    dir=$1
    shift
    (
        cd "$dir";
        for x in $(get-files-this-dir); do
            if test -d "$x"; then
                test -L "$x" || rename-files "$x" "$@"
            fi
            if echo "$x"|grep $perl_re -q -i -e "$prepend$1$postpend" || readlink "$x" | grep $perl_re -q -i -e "$prepend$1$postpend"; then
                debug doing "$x", the name matched
                y="$(compute-new-string "$x")"

                if test -L "$x"; then
                    new_link=$(compute-new-string "$(readlink "$x")")
                    if test "${#change_files[@]}" = 0; then
                        git rm "$x" --cached
                        rm "$x"
                    fi
                    ln -s "$new_link" "$y"
                    git add "$y"
                elif test "$x" != "$y"; then
                    if test "${#change_files[@]}" = 0; then
                        git mv "$x" "$y"
                    else
                        cp "$x" "$y"
                    fi
                fi

            fi
        done
    )
}

rename-files . "$@"
if test "${#change_files[@]}" != 0; then
    git checkout "${change_files[@]}"
fi
git-interactive-add

rm $tmpf.tmp $tmpf.hash $tmpf
