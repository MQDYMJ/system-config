<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>许愿和编程</title>
<!-- 2016-12-09 Fri 23:33 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Bao Haojun" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">许愿和编程</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 许愿初体验</a></li>
<li><a href="#sec-2">2. 自然而然的许愿</a>
<ul>
<li><a href="#sec-2-1">2.1. 比 Code Complete 里的 PPP 更自然的编程方法</a></li>
</ul>
</li>
<li><a href="#sec-3">3. 许愿和 GTD</a></li>
</ul>
</div>
</div>
<p>
会许愿的人，是有梦想的人。人如果没有梦想，和咸鱼有什么分别？😆
</p>

<p>
圣经里记载的上帝，应该是最会许愿的“人”了——神说：“要有光”，就有了光。
</p>

<p>
1991 年，Linus 说，我想要一个可以运行在 386 机器上的 Unix 系统，于是就有了 Linux。
</p>

<p>
2005 年，Linus 说，我想要一个可以支持 Linux Kernel 开发的版本管理系统，于是就有了 Git。
</p>

<p>
2012 年，罗永浩说，我要做手机，于是就有了锤子科技和 Smartisan 系列手机。
</p>

<p>
由此可见，许愿是一种非常强大的心灵力量，熟练掌握这一技能的话，基本上可以达到心想事成的效果。
</p>

<p>
当然，以上举的例子，许的愿望都是非常大的。事实上，在编程的过程中，许愿是一个非常重要的方法。它让你可以高屋建瓴、大刀阔斧的进行抽象。它不仅是让你“先设定一个小目标，比如先赚它一个亿”，更重要的是，它让你“假设我现在已经有了一个亿”。
</p>

<p>
没错，愿望都是非常抽象的，具体实现起来全都是细节，而魔鬼总是藏在细节中。所以如果一开始许错了愿望（先赚它一个亿），那实现起来的困难就可想而知了。接下来给大家从几个角度给大家分享一下我对编程和许愿的看法：
</p>

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 许愿初体验</a></li>
<li><a href="#sec-2">2. 自然而然的许愿</a>
<ul>
<li><a href="#sec-2-1">2.1. 比 Code Complete 里的 PPP 更自然的编程方法</a></li>
</ul>
</li>
<li><a href="#sec-3">3. 许愿和 GTD</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 许愿初体验</h2>
<div class="outline-text-2" id="text-1">
<p>
我是在阅读那本非常经典的“Structure and Interpretation of Computer Programs”的时候，第一次了解到“Programming by wishful thinking”这个概念。在讲到“有理数的运算”的时候（以下为该书相关部分的翻译）：
</p>

<blockquote>
<p>
我们想要可以对有理数进行运算。我们想要能够对它们进行加、减、乘、除四则运算，并可以判断两个有理数是否相等。
</p>

<p>
让我们从一些假设开始。假设我们已经有办法从一个分子和一个分母创造出一个有理数。还假设拿到一个有理数之后，我们有办法抽出（或称为“选出”）它的分子和分母。让我们进一步假设这个构造函数和这个选择函数都已经是现成的了：
</p>

<ul class="org-ul">
<li><code>(make-rat &lt;n&gt; &lt;d&gt;)</code> 返回一个有理数，它的分子是整数 <code>&lt;n&gt;</code>，它的分母是整数 <code>&lt;d&gt;</code>。
</li>
<li><code>(numer &lt;x&gt;)</code> 返回有理数 <code>&lt;x&gt;</code> 的分子。
</li>
<li><code>(denom &lt;x&gt;)</code> 返回有理数 <code>&lt;x&gt;</code> 的分母。
</li>
</ul>

<p>
我们在这里使用了一种非常强大的综合策略：即“许愿式思考”。我们还没有提到一个有理数是怎么 <b>表示</b> 的，也还没有提到 <code>numer</code>、<code>denom</code>、<code>make-rat</code> 这三个子程序应该如何实现。但即便如此，如果我们的确已经拥有这三个子程序，那么，我们就可以用以下关系式来进行加、减、乘、除和判断是否相等的操作了（We are using here a powerful strategy of synthesis: wishful thinking. We haven't yet said how a rational number is represented, or how the procedures numer, denom, and make-rat should be implemented. Even so, if we did have these three procedures, we could then add, subtract, multiply, divide, and test equality by using the following relations）：
</p>


<div class="figure">
<p><img src="ltxpng/0-Programming-by-Wishful-Thinking_f9dc5843375ccc074d78db3c538d20c303b764cc.png" alt="\begin{eqnarray*}
\frac{n_{1}}{d_{1}} + \frac{n_{2}}{d_{2}} &amp;amp; = &amp;amp; \frac{n_{1}d_{2} + n_{2}d_{1}}{d_{1}d_{2}}\\
\frac{n_{1}}{d_{1}} - \frac{n_{2}}{d_{2}} &amp;amp; = &amp;amp; \frac{n_{1}d_{2} - n_{2}d_{1}}{d_{1}d_{2}}\\
\frac{n_{1}}{d_{1}} * \frac{n_{2}}{d_{2}} &amp;amp; = &amp;amp; \frac{n_{1}n_{2}}{d_{1}d_{2}}\\
\frac{n_{1}/d_{1}}{n_{1}/d_{1}} &amp;amp; = &amp;amp; \frac{n_{1}d_{2}}{d_{1}n_{2}} \\
\frac{n_{1}}{d_{1}} = \frac{n_{2}}{d_{2}} &amp;amp;\text{ if and only if }&amp;amp; n_{1}d_{2} = n_{2}d_{1}\\
\end{eqnarray*}" /></p>
</div>

<p>
我们可以用如下子程序来表达上面这些等式：
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #0000FF;">define</span> (<span style="color: #006699;">add-rat</span> x y)
  (make-rat (+ (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(<span style="color: #0000FF;">define</span> (<span style="color: #006699;">sub-rat</span> x y)
  (make-rat (- (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(<span style="color: #0000FF;">define</span> (<span style="color: #006699;">mul-rat</span> x y)
  (make-rat (* (numer x) (numer y))
            (* (denom x) (denom y))))
(<span style="color: #0000FF;">define</span> (<span style="color: #006699;">div-rat</span> x y)
  (make-rat (* (numer x) (denom y))
            (* (denom x) (numer y))))
(<span style="color: #0000FF;">define</span> (<span style="color: #006699;">equal-rat?</span> x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))
</pre>
</div>
</blockquote>

<p>
现在想想，我当初看到这段文字的时候，内心是非常激动的，简直好像给我揭开了一个全新的广阔天地。
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 自然而然的许愿</h2>
<div class="outline-text-2" id="text-2">
<p>
注意上面引用自 sicp 的文字，是非常自然的，逻辑是非常清晰的。它从我们现有的简单知识出发（1. 有理数可表示为两个整数的比值；2. 我们知道整数的加减乘除规则），直接跳过了有理数的构造函数（<code>make-rat</code>）和取分子（<code>numer</code>）、取分母（<code>denom</code>）函数的定义，直接许了个愿假设我们已经有了这样的函数定义（其实并没有定义，只是有了这么些个函数的名字而已），那么通过这些函数的名字，再加上整数的运算规则，它开始定义有理数的加减乘除运算了！
</p>

<p>
通过这些运算函数的定义，再回过头去看构造函数、取分子、取分母函数应该怎么定义，或者说，应该定义成什么样儿才能/就能满足我们的需要，就非常直观了。甚至，如果你是一个 TDD（Test Driven Development：测试驱动开发）的信徒的话，通过运算函数的定义，你已经写好了 <code>make-rat</code>、<code>numer</code>、<code>denom</code> 等函数的测试用例！
</p>

<p>
相反，如果一上来就非要把 <code>make-rat</code>、<code>numer</code>、<code>denom</code> 这几个函数全都完整的定义出来，那这个开发的过程就有点儿拧巴了。
</p>

<p>
类似的让开发过程变得更顺的方法，我还在 Code Complete 这本书里见到过。在那本书里，有一个关于写程序的方法论的建议，那就是先写伪代码（PPP，Pseudocode Programming Process：伪代码编程流）。通过用英语等人类语言把一个问题、类、函数等描述清楚，然后再用程序语言将其实现，是一种非常好的抽象的方法。先用伪代码（接近英语等人类语言）在一个比较高的 level 上进行抽象的思考，把解决问题的思路整理清楚；然后用程序语言在更具体的 level 上把所有细节全部实现。具体的操作起来的时候可能需要循环迭代几次。你也可以理解为先用伪代码许愿，然后再用代码实现。
</p>

<p>
有比这个更自然的方法吗？
</p>

<p>
再说一遍，许愿，是一种非常高级的抽象方法。
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 比 Code Complete 里的 PPP 更自然的编程方法</h3>
<div class="outline-text-3" id="text-2-1">
<p>
我认为只有一种方法比 PPP 更自然了，那就是 Donald Knuth 提出来的 Literate Programming（文学编程）。更确切的说，我指的是在 Emacs 的 Org mode 下进行的“文学编程”。
</p>

<p>
注意很多人可能会觉得 Donald Knuth 提出来的文学编程太学究了，因此完全不实用。的确是这样，现实中你可能很少会碰到使用“文学编程”方法的人。但不能否认的是，Literate Programming 的影响是非常深远的，目前主流的编程语言都自带文档系统，比如 Java 有 Javadoc、C++/C 等有事实标准的 Doxygen、Python 有 pydoc 等等等等，都是受 Literate Programming 把代码和文档放在一起的思路启发和影响的。
</p>

<p>
但是上面这些系统都只是学到了文学编程思想的一些皮毛。文学编程思想真正的精髓在于（我理解），它允许你更自由、更自然的去组织你的想法、你的思路，去解决你的问题。
</p>

<p>
比如 C 语言，如果你写 C 语言程序，无论如何你逃不开的一些事情包括：
</p>

<ul class="org-ul">
<li>在主体程序开始之前你要先写一大堆 <code>#include &lt;stdio.h&gt;</code> 这样的头文件包含指令。
</li>
<li>在头文件包含指令之后，你要写出所有全局变量的定义、所有内部（static）函数的声明。

<p>
如果你不写 static 函数的声明也可以，但你一定的确保这个函数的定义出现在所有调用它的函数定义之前。
</p>
</li>
</ul>

<p>
等等。而如果是 Java 的话，你需要写一大堆的 import 语句（虽然现代的 IDE 都已经可以自动处理 import 了）。
</p>

<p>
这些杂事儿，你可以认为它们是计算机编程语言的不可避免之痛。但它们带来的一个问题就是，你无法很好的抽象了。到目前为止，计算机是无法抽象的思考问题的。只有人才能抽象的思考。而 C 语言等所有计算机编程语言，都是写出来让计算机去编译、执行的，用编程语言去抽象思考，是不方便的。人要抽象思考的时候，最好的方法还是用像英语、汉语这样的自然语言。
</p>

<p>
所以编程在很大程度上是把抽象的自然语言思考翻译成具体的编程语言实现的过程。注意除了一些非常简单的情况之外，这个翻译的过程很少有一气呵成的，而是抽象与具体存在交替进行的一个过程。Org mode 文学编程能把这种交替带来的思路中断的负面影响，帮你降到最低。
</p>

<p>
以 static 函数为例，在传统 C 语言编程里，你抽象的思考中意识到你需要一个 <code>function_a</code>，你在实现它的时候，需要中断自己的思路去记得做两件事儿：
</p>

<ol class="org-ol">
<li>把输入光标移到内部函数声明的位置，写下 <code>function_a</code> 的声明 
</li>

<li>把输入光标移回到原来的位置
</li>
</ol>

<p>
取决于你的编辑器和你的编程习惯，这两个操作难易程度、对你思路中断的负面影响，会有很大的波动幅度。另外还跟你的 C 程序长度有关系。在一个 1 万行的程序文件里跳来跳去找正确的编辑位置，对思路的打断肯定比一个只有 100 行的程序要更厉害一些。
</p>

<p>
如果是用 Org mode 的文学编程的话呢？你可以把你的思路和你的实现写在一起！像流水线一样写下来，在两种思考模式之间任意的切换。在最后的最后，你通过文学编程的 Web（CWeb、NoWeb）工具，把所有的函数整合在一起（就像编一张网一样，我觉得这个可能是 Web 这个名字的由来）。
</p>

<p>
举个例子，通过 Org mode 文学编程，我可以这样写程序：
</p>

<div class="org-src-container">

<pre class="src src-org"><span style="color: #3C3C3C; background-color: #F0F0F0; font-size: 130%; font-weight: bold; text-decoration: overline;">* &#25105;&#20170;&#22825;&#35201;&#20889;&#20010;&#20160;&#20040;&#20160;&#20040;&#31243;&#24207;</span>

<span style="color: #123555; background-color: #E5F4FB; font-weight: bold; text-decoration: overline;">** &#36825;&#38656;&#35201;&#23376;&#31243;&#24207;&#8201;A&#65292;&#23427;&#20250;&#24110;&#25105;&#23454;&#29616;&#20160;&#20040;&#20160;&#20040;&#21151;&#33021;</span>

   &#65288;&#27880;&#24847;&#65292;&#25105;&#20915;&#23450;&#20808;&#20889;&#23376;&#31243;&#24207;&#8201;A&#65292;&#21487;&#33021;&#26159;&#22240;&#20026;&#25105;&#35273;&#24471;&#23376;&#31243;&#24207;&#8201;A&#8201;&#26368;&#37325;&#35201;&#65292;&#20063;&#21487;&#33021;&#26159;&#22240;&#20026;&#25105;&#35273;&#24471;&#20808;&#20889;&#23427;&#26368;&#33258;&#28982;&#65292;&#20063;&#21487;&#33021;&#26159;&#22240;&#20026;&#25105;&#35273;&#24471;&#23427;&#26368;&#26377;&#36259;&#12290;&#25105;&#39640;&#20852;&#65281;&#39640;&#20852;&#26159;&#31532;&#19968;&#29983;&#20135;&#21147;&#65289;&#12290;

&#65288;&#22914;&#26524;&#26159;&#30452;&#25509;&#20889;&#8201;C&#8201;&#35821;&#35328;&#30340;&#35805;&#65292;&#36825;&#37324;&#25105;&#21487;&#33021;&#23601;&#35201;&#20808;&#20889;&#19968;&#22534; <span style="color: #0066CC;">=#include=</span> &#20043;&#31867;&#30340;&#35821;&#21477;&#20102;&#65292;&#25105;&#19981;&#21916;&#27426;&#36825;&#26679;&#65289;&#12290;

<span style="color: #555555; background-color: #E2E1D5; text-decoration: underline;">#+BEGIN_SRC c</span>
<span style="color: #0000FF; background-color: #FFFFE0;">static</span><span style="background-color: #FFFFE0;"> </span><span style="color: #6434A3; background-color: #FFFFE0;">int</span><span style="background-color: #FFFFE0;"> </span><span style="color: #006699; background-color: #FFFFE0;">function_a</span><span style="background-color: #FFFFE0;">()
{
    </span><span style="color: #8D8D84; background-color: #FFFFE0;">//</span><span style="color: #8D8D84; background-color: #FFFFE0; font-style: italic;">...</span><span style="background-color: #FFFFE0;">
    function_b();
}

</span><span style="color: #555555; background-color: #E2E1D5; text-decoration: overline;">#+END_SRC</span>

<span style="color: #123555; background-color: #E5F4FB; font-weight: bold; text-decoration: overline;">** &#35201;&#23454;&#29616;&#8201;function_a&#65292;&#25105;&#22909;&#20687;&#36824;&#38656;&#35201;&#19968;&#20010;&#23376;&#31243;&#24207;&#8201;B&#65292;&#23427;&#20250;&#24110;&#25105;&#23454;&#29616;&#20160;&#20040;&#20160;&#20040;&#21151;&#33021;</span>

<span style="color: #555555; background-color: #E2E1D5; text-decoration: underline;">#+BEGIN_SRC c</span>
<span style="color: #0000FF; background-color: #FFFFE0;">static</span><span style="background-color: #FFFFE0;"> </span><span style="color: #6434A3; background-color: #FFFFE0;">int</span><span style="background-color: #FFFFE0;"> </span><span style="color: #006699; background-color: #FFFFE0;">function_b</span><span style="background-color: #FFFFE0;">()
{
    </span><span style="color: #8D8D84; background-color: #FFFFE0;">//</span><span style="color: #8D8D84; background-color: #FFFFE0; font-style: italic;">...</span><span style="background-color: #FFFFE0;">
}
</span><span style="color: #555555; background-color: #E2E1D5; text-decoration: overline;">#+END_SRC</span>

<span style="color: #3C3C3C; background-color: #F0F0F0; font-size: 130%; font-weight: bold; text-decoration: overline;">* &#26368;&#21518;&#30340;&#26368;&#21518;</span>

<span style="color: #555555; background-color: #E2E1D5; text-decoration: underline;">#+BEGIN_SRC c</span>
<span style="background-color: #FFFFE0;">
&lt;&lt;function_b&gt;&gt;
&lt;&lt;function_a&gt;&gt;
&lt;&lt;main&gt;&gt;

</span><span style="color: #555555; background-color: #E2E1D5; text-decoration: overline;">#+END_SRC</span>

&#22522;&#26412;&#19978;&#23601;&#26159;&#36825;&#26679;&#12290;&#26368;&#21518;&#25105;&#30340; <span style="color: #0066CC;">=main=</span> &#20989;&#25968;&#23601;&#26159;&#31616;&#21333;&#30340;&#35843;&#29992;&#19968;&#19979; <span style="color: #0066CC;">=function_a=</span>&#65306;

<span style="color: #555555; background-color: #E2E1D5; text-decoration: underline;">#+BEGIN_SRC c</span>
<span style="color: #6434A3; background-color: #FFFFE0;">int</span><span style="background-color: #FFFFE0;"> </span><span style="color: #006699; background-color: #FFFFE0;">main</span><span style="background-color: #FFFFE0;">()
{
    function_a();
}

</span><span style="color: #555555; background-color: #E2E1D5; text-decoration: overline;">#+END_SRC</span>

EOF.
</pre>
</div>

<p>
你会发现最后我在用 NoWeb 的 <code>&lt;&lt;&gt;&gt;</code> 表示符号进行引用的时候，我把 <code>function_b</code> 排在了 <code>function_a</code> 前面，最后生成的代码，自然而然的就满足了 C 语言对函数定义必须出现在其被调用的位置之前的要求。
</p>

<p>
毫无疑问，用文学编程你会变得更啰嗦，但是，它会使你的表达变得更自然，让你更容易沉浸在来回使用自然语言+编程语言解决你的问题的心流（Flow）里。难怪 Knuth 老爷子这么热衷于 Literate Programming。因为它允许程序员用从心理学上讲正确的顺序（psychologically correct order）去探索一个编程问题。根本不需要纠结是应该自顶向下，还是自下而上，还是两者结合。
</p>

<p>
（说实话，其实我对 Literate Programming 完全是一知半解。只是有按照自己的理解，用过这种技巧从头实现了锤子科技的 CM 系统。）
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 许愿和 GTD</h2>
<div class="outline-text-2" id="text-3">
<p>
GTD 是 Get Things Done 的意思。一种非常有效的提升自己的执行力的方法，很简单，就是列一个待办事项清单，然后一项一项的干掉，每干掉一件，就划掉一项。
</p>

<p>
我在《Coders at Work》这本书里看到 jwz 接受采访被问到自己的编程方法时，他就是这么回答的“我就列一个单子，然后一项项的划掉”。事实上我刚刚又打开了那本电子书看了看，jwz 多次提到了 list、todo-list，都是 GTD 里最重要的术语。
</p>

<p>
在我看来，GTD 和许愿其实就是一回事儿。许愿，就是许一个愿望然后去实现它。GTD，就是要记一下自己要做哪些事儿，然后把它们都做掉。
</p>

<p>
所以我就接着讲一些 GTD 相关的领悟了。
</p>

<p>
GTD 的第一步，就是把要办的事情记下来。要不然的话，脑子里装不下太多东西，有很多事情就会忘记。并且因为发现自己忘了什么好像还蛮重要的事情，会让自己进入非常不良的状态，压力山大，撕扯自己的头发。许愿也是这样，许过的愿又忘记了的话，相当于没有愿望，没有愿望就是没有梦想——那和咸鱼还有什么分别？
</p>

<p>
记下来的另一个原因，是为了可以整理头绪。如果把所有东西都装在脑子里，千头万绪，根本不知道从哪里干起。一旦全列出来之后呢，头绪一点儿也没变少，但因为它们不再占用你的大脑（也就是你的 CPU），你甚至可以随便挑一个头开始干起来，不至于“天狗吃月亮，不知从哪儿下嘴”。没错，拖延症都一不小心被治好了。
</p>

<p>
GTD 的第二步、第三步，不好意思，我也还没练好，没有太多经验可以分享。主要就是要分优先级、要清理 todo list，有些事情列出来了但发现办不到的要放弃，每周、每月都要 review，等等等等。我现在基本只做到了自己列过的单子，没什么特殊情况的话，一般都会实现掉（向老罗学习：吹过的牛逼要实现）；当然，该放弃的时候，也会毫不犹豫的放弃掉（再次向老罗学习：不要怕打脸）。
</p>

<p>
最后，还是要推荐 Emacs 的 Org Mode，非常完美的支持 GTD！我在用 Literate Programming，同时用 GTD，噢噢噢（有了快感就要叫出来）！在安卓手机上还有 MobileOrg，我可以随时随地把自己的想法记下来，然后回到 Emacs 下去实现它。我收到的邮件，如果我后续想再处理的话，我会点一下“Flag”标签，这样的邮件会自动进入我的 GTD 列表里。有人在公司的 Bug 系统里给我提单子的时候，这个单子也会自动进入到我的 GTD 里。同事在公司的 Gerrit 上给我提 Code Review，最后也会自动进入我的 GTD 列表里！我一天到晚什么也不干，就只要盯牢我的 GTD 列表就好了！跟炒股的大妈们一样，只要盯着大盘的行情就好了&#x2026;
</p>

<p>
最后在这里给大家拜个早年，新年快到了，你会许个什么样的愿望呢？不管是什么样的愿望，祝你能实现它！比如“先赚他一个亿”！然后给我一点好不啦。
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Bao Haojun</p>
<p class="date">Created: 2016-12-09 Fri 23:33</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.1.90.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"></p>
</div>
</body>
</html>
