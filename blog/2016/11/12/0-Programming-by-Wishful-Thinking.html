<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>许愿和编程</title>
<!-- 2016-12-06 Tue 01:33 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Bao Haojun" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">许愿和编程</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 许愿初体验</a></li>
<li><a href="#sec-2">2. 自然而然的许愿</a>
<ul>
<li><a href="#sec-2-1">2.1. 比Code Complete里的PPP更自然的编程方法</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
会许愿的人，是有梦想的人。人如果没有梦想，和咸鱼有什么分别？😆
</p>

<p>
圣经里记载的上帝，应该是最会许愿的“人”了——神说：“要有光”，就有了光。
</p>

<p>
1991年，Linus说，我想要一个可以运行在386机器上的Unix系统，于是就有了Linux。
</p>

<p>
2005年，Linus说，我想要一个可以支持Linux开发的版本管理系统，于是就有了Git。
</p>

<p>
2012年，罗永浩说，我要做手机，于是就有了锤子科技和Smartisan系列手机。
</p>

<p>
由此可见，许愿是一种非常强大的心灵力量，熟练掌握这一技能的话，基本上可以达到心想事成的效果。
</p>

<p>
当然，以上举的例子，许的愿望都是非常大的。事实上，在编程的过程中，许愿是一个非常重要的方法。它让你可以高屋建瓴、大刀阔斧的进行抽象。它不仅是让你“先设定一个小目标，比如先赚他一个亿”，更重要的是，它让你“假设我现在已经有了一个亿”。
</p>

<p>
没错，愿望都是非常抽象的，具体实现起来全都是细节，而魔鬼总是藏在细节中。所以如果一开始许错了愿望，那实现起来的困难就可想而知了。接下来给大家从几个角度给大家分享一下我对编程和许愿的看法：
</p>

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 许愿初体验</a></li>
<li><a href="#sec-2">2. 自然而然的许愿</a>
<ul>
<li><a href="#sec-2-1">2.1. 比Code Complete里的PPP更自然的编程方法</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 许愿初体验</h2>
<div class="outline-text-2" id="text-1">
<p>
我是在阅读那本非常经典的“Structure and Interpretation of Computer Programs”的时候，第一次了解到“Programming by wishful thinking”这个概念。在讲到“有理数的运算”的时候（以下为该书相关部分的翻译）：
</p>

<blockquote>
<p>
我们想要可以对有理数进行运算。我们想要能够对它们进行加、减、乘、除四则运算，并可以判断两个有理数是否相等。
</p>

<p>
让我们从一些假设开始。假设我们已经有办法从一个分子和一个分母创造出一个有理数。还假设拿到一个有理数之后，我们有办法抽出（或称为“选出”）它的分子和分母。让我们进一步假设这个构造函数和这个选择函数都已经是现成的了：
</p>

<ul class="org-ul">
<li><code>(make-rat &lt;n&gt; &lt;d&gt;)</code> 返回一个有理数，它的分子是整数 <code>&lt;n&gt;</code>，它的分母是整数 <code>&lt;d&gt;</code>。
</li>
<li><code>(numer &lt;x&gt;)</code> 返回有理数 <code>&lt;x&gt;</code> 的分子。
</li>
<li><code>(denom &lt;x&gt;)</code> 返回有理数 <code>&lt;x&gt;</code> 的分母。
</li>
</ul>

<p>
我们在这里使用了一种非常强大的综合策略：即“许愿式思考”。我们还没有提到一个有理数是怎么 <b>表示</b> 的，也还没有提到 <code>numer</code>、<code>denom</code>、<code>make-rat</code> 这三个子程序应该如何实现。但即便如此，如果我们的确已经拥有这三个子程序，那么，我们就可以用以下关系式来进行加、减、乘、除和判断是否相等的操作了（We are using here a powerful strategy of synthesis: wishful thinking. We haven't yet said how a rational number is represented, or how the procedures numer, denom, and make-rat should be implemented. Even so, if we did have these three procedures, we could then add, subtract, multiply, divide, and test equality by using the following relations）：
</p>


<div class="figure">
<p><img src="ltxpng/0-Programming-by-Wishful-Thinking_f9dc5843375ccc074d78db3c538d20c303b764cc.png" alt="\begin{eqnarray*}
\frac{n_{1}}{d_{1}} + \frac{n_{2}}{d_{2}} &amp;amp; = &amp;amp; \frac{n_{1}d_{2} + n_{2}d_{1}}{d_{1}d_{2}}\\
\frac{n_{1}}{d_{1}} - \frac{n_{2}}{d_{2}} &amp;amp; = &amp;amp; \frac{n_{1}d_{2} - n_{2}d_{1}}{d_{1}d_{2}}\\
\frac{n_{1}}{d_{1}} * \frac{n_{2}}{d_{2}} &amp;amp; = &amp;amp; \frac{n_{1}n_{2}}{d_{1}d_{2}}\\
\frac{n_{1}/d_{1}}{n_{1}/d_{1}} &amp;amp; = &amp;amp; \frac{n_{1}d_{2}}{d_{1}n_{2}} \\
\frac{n_{1}}{d_{1}} = \frac{n_{2}}{d_{2}} &amp;amp;\text{ if and only if }&amp;amp; n_{1}d_{2} = n_{2}d_{1}\\
\end{eqnarray*}" /></p>
</div>

<p>
我们可以用如下子程序来表达上面这些等式：
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">add-rat</span> x y)
  (make-rat (+ (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">sub-rat</span> x y)
  (make-rat (- (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">mul-rat</span> x y)
  (make-rat (* (numer x) (numer y))
            (* (denom x) (denom y))))
(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">div-rat</span> x y)
  (make-rat (* (numer x) (denom y))
            (* (denom x) (numer y))))
(<span style="color: #a020f0;">define</span> (<span style="color: #0000ff;">equal-rat?</span> x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))
</pre>
</div>
</blockquote>

<p>
现在想想，我当初看到这段文字的时候，内心是非常激动的，简直好像给我揭开了一个全新的广阔天地。
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 自然而然的许愿</h2>
<div class="outline-text-2" id="text-2">
<p>
注意上面引用自sicp的文字，是非常自然的，逻辑是非常清晰的。它从我们现有的简单知识出发（1. 有理数可表示为两个整数的比值；2. 我们知道整数的加减乘除规则），直接跳过了有理数的构造函数（=make-rat=）和取分子（=numer=）、取分母（=denom=）函数的定义，直接许了个愿假设我们已经有了这样的函数定义（其实并没有定义，只是有了这么些个函数的名字而已），那么通过这些函数的名字，再加上整数的运算规则，它开始定义有理数的加减乘除运算了！
</p>

<p>
通过这些运算函数的定义，再回过头去看构造函数、取分子、取分母函数应该怎么定义，或者说，应该定义成什么样儿才能/就能满足我们的需要，就非常直观了。甚至，如果你是一个TDD（Test Driven Development：测试驱动开发）的信徒的话，通过运算函数的定义，你已经写好了 <code>make-rat</code>、<code>numer</code>、<code>denom</code> 等函数的测试用例！
</p>

<p>
相反，如果一上来就非要把 <code>make-rat</code>、<code>numer</code>、<code>denom</code> 这几个函数全都完整的定义出来，那这个开发的过程就有点儿拧巴了。
</p>

<p>
类似的让开发过程变得更顺的方法，我还在Code Complete这本书里见到过。在那本书里，有一个关于写程序的方法论的建议，那就是先写伪代码（PPP，Pseudocode Programming Process：伪代码编程流）。通过用英语等人类语言把一个问题、类、函数等描述清楚，然后再用程序语言将其实现，是一种非常好的抽象的方法。先用伪代码（接近英语等人类语言）在一个比较高的level上进行抽象的思考，把解决问题的思路整理清楚；然后用程序语言在更具体的level上把所有细节全部实现。具体的操作起来的时候可能需要循环迭代几次。你也可以理解为先用伪代码许愿，然后再用代码实现。
</p>

<p>
有比这个更自然的方法吗？
</p>

<p>
再说一遍，许愿，是一种非常高级的抽象方法。
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 比Code Complete里的PPP更自然的编程方法</h3>
<div class="outline-text-3" id="text-2-1">
<p>
我认为只有一种方法比PPP更自然了，那就是Donald Knuth提出来的Literate Programming（文学编程）。更确切的说，我指的是在Emacs的Org mode下进行的“文学编程”。
</p>

<p>
注意很多人可能会觉得 Donald Knuth 提出来的文学编程太学究了，因此完全不实用。的确是这样，现实中你可能很少会碰到使用“文学编程”方法的人。但不能否认的是，Literate Programming的影响是非常深远的，目前主流的编程语言都自带文档系统，比如Java有Javadoc、C++/C等有事实标准的Doxygen、Python有pydoc等等等等，都是受Literate Programming把代码和文档放在一起的思路启发和影响的。
</p>

<p>
但是上面这些系统都只是学到了文学编程思想的一些皮毛。文学编程思想真正的精髓在于（我理解），它允许你更自由、更自然的去组织你的想法、你的思路，去解决你的问题。
</p>

<p>
比如C语言，如果你写C语言程序，无论如何你逃不开的一些事情包括：
</p>

<ul class="org-ul">
<li>在主体程序开始之前你要先写一大堆 <code>#include &lt;stdio.h&gt;</code> 这样的头文件包含指令。
</li>
<li>在头文件包含指令之后，你要写出所有全局变量的定义、所有内部（static）函数的声明。

<p>
如果你不写static函数的声明也可以，但你一定的确保这个函数的定义出现在所有调用它的函数定义之前。
</p>
</li>
</ul>

<p>
等等。而如果是Java的话，你需要写一大堆的import语句（虽然现代的IDE都已经可以自动处理import了）。
</p>

<p>
这些杂事儿，你可以认为它们是计算机编程语言的不可避免之痛。但它们带来的一个问题就是，你无法很好的抽象了。到目前为止，计算机是无法抽象的思考问题的。只有人才能抽象的思考。而C语言等所有计算机编程语言，都是写出来让计算机去编译、执行的，用编程语言去抽象思考，是不方便的。人要抽象思考的时候，最好的方法还是用像英语、汉语这样的自然语言。
</p>

<p>
所以编程在很大程度上是把抽象的自然语言思考翻译成具体的编程语言实现的过程。注意除了一些非常简单的情况之外，这个翻译的过程很少有一气呵成的，而是抽象与具体存在交替进行的一个过程。Org mode文学编程能把这种交替带来的思路中断的负面影响，帮你降到最低。
</p>

<p>
以static函数为例，在传统C语言编程里，你抽象的思考中意识到你需要一个 <code>function_a</code>，你在实现它的时候，需要中断自己的思路去记得做两件事儿：
</p>

<ol class="org-ol">
<li>把输入光标移到内部函数声明的位置，写下 <code>function_a</code> 的声明
</li>
<li>把输入光标移回到原来的位置
</li>
</ol>

<p>
取决于你的编辑器和你的编程习惯，这两个操作难易程度、对你思路中断的负面影响，会有很大的波动幅度。另外还跟你的C程序长度有关系。在一个1万行的程序文件里跳来跳去找正确的编辑位置，对思路的打断肯定比一个只有100行的程序要更厉害一些。
</p>

<p>
如果是用Org mode的文学编程的话呢？你可以把你的思路和你的实现写在一起！像流水线一样写下来，在两种思考模式之间任意的切换。在最后的最后，你通过文学编程的Web（CWeb、NoWeb）工具，把所有的函数整合在一起。
</p>

<p>
举个例子，通过Org mode文学编程，我可以这样写程序：
</p>

<div class="org-src-container">

<pre class="src src-org"><span style="color: #0000ff; font-weight: bold;">* &#25105;&#20170;&#22825;&#35201;&#20889;&#20010;&#20160;&#20040;&#20160;&#20040;&#31243;&#24207;</span>

<span style="color: #a0522d; font-weight: bold;">** &#36825;&#38656;&#35201;&#23376;&#31243;&#24207;A&#65292;&#23427;&#20250;&#24110;&#25105;&#23454;&#29616;&#20160;&#20040;&#20160;&#20040;&#21151;&#33021;</span>

<span style="color: #b22222;">#+BEGIN_SRC c</span>
<span style="color: #a020f0;">static</span> <span style="color: #228b22;">int</span> <span style="color: #0000ff;">function_a</span>()
{
    <span style="color: #b22222;">//</span><span style="color: #b22222;">...</span>
    function_b();
}

<span style="color: #b22222;">#+END_SRC</span>

<span style="color: #a0522d; font-weight: bold;">** &#35201;&#23454;&#29616;function_a&#65292;&#25105;&#22909;&#20687;&#36824;&#38656;&#35201;&#19968;&#20010;&#23376;&#31243;&#24207;B&#65292;&#23427;&#20250;&#24110;&#25105;&#23454;&#29616;&#20160;&#20040;&#20160;&#20040;&#21151;&#33021;</span>

<span style="color: #b22222;">#+BEGIN_SRC c</span>
<span style="color: #a020f0;">static</span> <span style="color: #228b22;">int</span> <span style="color: #0000ff;">function_b</span>()
{
    <span style="color: #b22222;">//</span><span style="color: #b22222;">...</span>
}
<span style="color: #b22222;">#+END_SRC</span>

<span style="color: #0000ff; font-weight: bold;">* &#26368;&#21518;&#30340;&#26368;&#21518;</span>

<span style="color: #b22222;">#+BEGIN_SRC c</span>

&lt;&lt;function_b&gt;&gt;
&lt;&lt;function_a&gt;&gt;
&lt;&lt;main&gt;&gt;

<span style="color: #b22222;">#+END_SRC</span>

&#22522;&#26412;&#19978;&#23601;&#26159;&#36825;&#26679;&#12290;&#26368;&#21518;&#25105;&#30340; <span style="color: #7f7f7f;">=main=</span> &#20989;&#25968;&#23601;&#26159;&#31616;&#21333;&#30340;&#35843;&#29992;&#19968;&#19979; <span style="color: #7f7f7f;">=function_a=</span>&#65306;

<span style="color: #b22222;">#+BEGIN_SRC c</span>
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>()
{
    function_a();
}

<span style="color: #b22222;">#+END_SRC</span>

EOF.
</pre>
</div>

<p>
你会发现最后我在用 <code>&lt;&lt;&gt;&gt;</code> 进行引用的时候，我把 <code>function_b</code> 排在了 <code>function_a</code> 前面，最后生成的代码，自然而然的就满足了 C 语言对函数定义必须出现在其被调用的位置之前的要求。
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Bao Haojun</p>
<p class="date">Created: 2016-12-06 Tue 01:33</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.1.90.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"></p>
</div>
</body>
</html>
