<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>system-config原理与使用的简要说明</title>
<!-- 2016-04-17 Sun 08:46 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Bao Haojun" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">system-config原理与使用的简要说明</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. system-config原理</a>
<ul>
<li><a href="#sec-1-1">1.1. 改变系统原有行为</a>
<ul>
<li><a href="#sec-1-1-1">1.1.1. bash提供的对系统定制增强的机制</a></li>
</ul>
</li>
<li><a href="#sec-1-2">1.2. 加入系统原来没有的程序</a>
<ul>
<li><a href="#sec-1-2-1">1.2.1. system-config是一个采花大盗</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-2">2. system-config使用</a>
<ul>
<li><a href="#sec-2-1">2.1. 阅读源代码</a></li>
<li><a href="#sec-2-2">2.2. 对Terminal界面（命令行提示符）的改进</a></li>
<li><a href="#sec-2-3">2.3. 安卓开发相关</a>
<ul>
<li><a href="#sec-2-3-1">2.3.1. 对adb的增强</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3">3. system-config原理</a></li>
</ul>
</div>
</div>
<p style="color: red;"> <b>Not finished yet.</b> </p>
<p>
首先，system-config只是对Linux系统的一些增强，并且最大程度的保证对系统原有功能的兼容，所以你可以像使用普通Linux系统一样使用system-config，并不需要特别的学习。这里说一下system-config里最有用、不容易发现的一些配置用法、原理等。
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> system-config原理</h2>
<div class="outline-text-2" id="text-1">
<p>
从系统命令行用户界面来说，system-config主要使用的shell是bash，对shell进行增强，不外乎以下几种方法：
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 改变系统原有行为</h3>
<div class="outline-text-3" id="text-1-1">
<p>
比如Bash自带的cd命令，使用起来有点麻烦，所以我先用 cd_bhj 作为名字定义了一个函数，然后再把 cd 别名到 cd_bhj ，这样每次我在命令行上打 cd 的时候，实际调用的是 cd_bhj 函数，这个函数会检查我给的参数，然后
</p>

<ul class="org-ul">
<li>如果所给的参数是原本合法的 cd 调用，则通过Bash的builtin关键字，调用内置的cd命令。这一点保证了与系统的兼容性，确保system-config不会是一个全新的系统，而是Linux用户不用重新学习、拿来就能用的。
</li>
<li>如果所给的参数是原本非法的 cd 调用，计算出我实际想去的路径，再调用内置的cd命令。这样有可能我可以打很少的几个字，就cd到一个很深的目录下去，比如下图所示


<div class="figure">
<p><a href="../../../../images/cd-t2-fr-base.png"><img src="../../../../images/cd-t2-fr-base.png" alt="cd-t2-fr-base.png" /></a>
</p>
</div>
</li>
</ul>

<p>
还有一种改变系统原有行为的方法，即提供一个与系统程序同名的程序，并且把它放到PATH环境变量的前面，确保系统执行的时候会先找到你的版本。在你自己的版本里，你可以选择是否是调用系统原有的版本来完成你想要达到的效果。比如我写了一个对命令行参数更友好的 <code>~/system-config/bin/rdesktop</code> ，在里面它会调来系统的 <code>/usr/bin/rdesktop</code> 。
</p>

<p>
顺便说一句，想知道某个Bash命令有没有被修改过，有几种方法：
</p>

<ul class="org-ul">
<li><code>type CMD</code> 和 <code>type -a CMD</code>
     这里 <code>type</code> 是Bash的一个Builtin（内置命令）。
</li>

<li><code>which CMD</code>
     这个其实没有 <code>type</code> 功能全
</li>

<li><code>alias</code>
     不带参数运行Bash的 <code>alias</code> 内置命令，它会列出你当前Bash会话中的所有alias。
</li>
</ul>
</div>

<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1"><span class="section-number-4">1.1.1</span> bash提供的对系统定制增强的机制</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
这里顺便总结一下，bash都提供了哪些机制可以用来定制你的系统。
</p>

<ol class="org-ol">
<li>改变环境变量，比如PATH环境变量，命令行提示符变量等。
</li>

<li>改变bash变量，比如 <code>set completion-ignore-case on</code> ，可以在补齐文件名的时候不区分大小写。
</li>

<li>使用bash alias（别名）
</li>

<li>定义bash函数

<p>
如果你定义的函数或alias与某bash内置命令或某系统自带程序同名，在这个函数里你又想调用该内置命令或程序，你可以使用bash的 <code>builtin</code> 或 <code>command</code> 关键字。
</p>

<p>
比如我的ls其实是一个别名：
</p>

<pre class="example">
alias ls='ls -hF --color=tty --show-control-chars --block-size=1'
</pre>

<p>
我想在命令行上交互地调用真正的ls程序，我可以用 <code>command ls</code> 命令，或者也可以用 <code>/bin/ls</code> 。又比如我的cd也是一个alias，因为它也是bash内置的关系，想调用bash内置版本cd的话，可以输入 <code>builtin cd DIRECTORY</code> 。
</p>
</li>

<li>自定义补齐机制

<p>
这个可以参考debian/ubuntu下自带的 bash-completion deb包。也可以参考bash info手册。
</p>

<p>
system-config自定义的补齐机制脚本都放在 <code>~/system-config/.bash_completion.d/</code> 下。
</p>
</li>

<li>自定义快捷键

<p>
在bash下有很多自定义的快捷键，比如Ctrl-r/Ctrl-s可以用来向前/向后搜索历史命令，这个非常有用，有很多同学只知道用Up/Down方向键一条一条的找历史命令，或者用Left/Right方向键一个字符一个字符的移动光标。其实找历史命令和移动光标都可以用Ctrl-r/Ctrl-s来做，很多情况下是最高效的！（其中移动光标的话用Ctrl-r/Ctrl-s找到正确位置之后，需要按一下Ctrl-j）
</p>

<p>
我自定义的最有用的bash快捷键是 Alt-k ，快速把当前命令行上的输入放置到系统剪贴板中，方便我先在命令行上试验，然后把试验成功的命令拷贝、粘贴到Emacs里正在编写的脚本程序里。
</p>

<p>
可以用 <code>bind -p|perl -ne 'print unless m/not bound|self-insert/'|less</code> 命令来看一下你的系统上bash定义了哪些快捷键，然后选几个你认为很有用的慢慢学起来。
</p>

<p>
想知道如何自定义bash快捷键的话，可以参考 <code>~/system-config/.inputrc</code> ，还有 readline 的 man 手册： <code>man readline</code> 。
</p>
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> 加入系统原来没有的程序</h3>
<div class="outline-text-3" id="text-1-2">
<p>
这样的程序我可能写过很多，接下来我会挑几个重要的说一下。比如beagrep/grep-beatags，是阅读代码的利器，其中集成了一个搜索引擎，所以速度非常快。见 <a href="../../../2011/12/23/beagrep.html">中文版博客</a> / <a href="../../../2011/12/23/beagrep.html">英文版博客</a> 。事实上，我非常推荐你用system-config本身提供的这些阅读源码的程序，来了解system-config本身，比如我想搜索上面提到的 cd_bhj 是在哪里定义的，我在~/system-config目录下一运行这个命令，马上就出来了： <code>grep-beatags -e cd_bhj</code> 。关于怎么用，非常简单，下文马上就会提到。
</p>

<ol class="org-ol">
<li>组合调用以上

<p>
比如上面的 cd 的增强，如果计算到有多个路径与我给出的参数匹配，则 cd_bhj 会调用我写的 <code>select-output-line</code> 命令，对我显示一个命令行上的简易选择框（事实上根本就没有框）。见下图：
</p>


<div class="figure">
<p><a href="../../../../images/cd-fa-base.png"><img src="../../../../images/cd-fa-base.png" alt="cd-fa-base.png" /></a>
</p>
</div>

<p>
在以后你会在非常多的地方见到这个对话框。
</p>
</li>
</ol>
</div>

<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> system-config是一个采花大盗</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
为什么说这个对话框会很常见呢？因为我就像一只勤劳的小蜜蜂一样，看见一朵花很漂亮，就飞过去猛采一通。同样的，如果我发现某个软件的某个功能很好用，我就会想办法给它移植到system-config里来。比如你看到的那个命令行选择框，其创意就来自于Emacs下的helm.el（和以前的anything.el），见下图：
</p>


<div class="figure">
<p><a href="../../../../images/emacs-help-pack.png"><img src="../../../../images/emacs-help-pack.png" alt="emacs-help-pack.png" /></a>
</p>
</div>

<p>
类似的，你还会看到 system-config 里有时候会问你这样的问题（注意大小写，Yes/no代表直接回车相当于输入了yes；yes/No代表直接回车相当于输入了no，一般我会选一个我认为比较合适的选项作为默认值）：
</p>


<div class="figure">
<p><a href="../../../../images/cli-yes-or-no-p.png"><img src="../../../../images/cli-yes-or-no-p.png" alt="cli-yes-or-no-p.png" /></a>
</p>
</div>

<p>
这个也是从Emacs里学来的（我的命令行命令也叫yes-or-on-p，跟Emacs下的函数一模一样）：
</p>


<div class="figure">
<p><a href="../../../../images/emacs-y-or-n-p.png"><img src="../../../../images/emacs-y-or-n-p.png" alt="emacs-y-or-n-p.png" /></a>
</p>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> system-config使用</h2>
<div class="outline-text-2" id="text-2">
<p>
System-config里提供的最有价值的功能，应该就是它的全套的阅读源代码的解决方案。我要研究任何项目的代码，都离不开这些工具。包括system-config自身的代码，我也会用这些工具来进行快速搜索、阅读。所以在使用部分，我们一开始就介绍一下这些工具。
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 阅读源代码</h3>
<div class="outline-text-3" id="text-2-1">
<p>
要成为一个高级的程序员，快速的阅读、理解代码的能力是不可获缺的。阅读代码除了打开一个源码文件一行一行的从头读到尾这个笨办法之外，经常需要进行以下三种操作：
</p>

<ol class="org-ol">
<li>搜索某一字符串在代码中出现的位置
</li>

<li>搜索某一函数、变量被定义的位置
</li>

<li>搜索某一函数、变量被使用（调用）的位置
</li>
</ol>

<p>
System-config提供了快速搜索、定位代码的业界最简单方法，只需要以下几个步骤：
</p>

<ol class="org-ol">
<li>创建索引。在源代码的顶层目录运行
<div class="org-src-container">

<pre class="src src-sh">for-code-reading
</pre>
</div>
</li>

<li>搜索字符串。比如在源代码的任意子目录下运行
<div class="org-src-container">

<pre class="src src-sh">beagrep -e <span style="color: #848ea9;">"hello world"</span>
</pre>
</div>

<p>
以搜索 <code>hello world</code> 这个字符串在源码中出现的位置。
</p>
</li>

<li>搜索定义。在源代码的任意子目录下运行

<div class="org-src-container">

<pre class="src src-sh">grep-beatags -e <span style="color: #848ea9;">"readlink"</span>
</pre>
</div>
<p>
以搜索 readlink 被定义的地方。
</p>
</li>

<li>搜索引用。在源代码的任意子目录下运行

<div class="org-src-container">

<pre class="src src-sh">grep-func-call -e <span style="color: #848ea9;">"readlink"</span> -a --nc
</pre>
</div>

<p>
以搜索 readlink 被调用的地方
</p>
</li>
</ol>

<p>
这些程序都可以在命令行上运行，但我平时一般都是通过在Emacs下调用它们，效果更好，比如可以直接跳转到搜到的文件：行号上。
</p>

<p>
各个搜索程序都有一些更复杂的用法，这个目前只能通过阅读相应的脚本文件以获得。再次强烈建议使用system-config提供的这些程序本身来阅读system-config自身代码，以及其他所有工作中要用到的代码。我拿到任何代码，第一步是就是用 <code>for-code-reading</code> 创建索引。
</p>
</div>
</div>


<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 对Terminal界面（命令行提示符）的改进</h3>
<div class="outline-text-3" id="text-2-2">
<p>
接下来我大致按照system-config的各种改动的常用、常见程度，介绍一下我认为比较有用的一些改动。首先是对命令行显示界面的改动，这个是最显著的，所以放在前面说一下。
</p>

<p>
默认Linux的命令行提示符是这样的：
</p>


<div class="figure">
<p><a href="../../../../images/default-ps1.png"><img src="../../../../images/default-ps1.png" alt="default-ps1.png" /></a>
</p>
</div>

<p>
增强后的提示符是这样的：
</p>


<div class="figure">
<p><a href="../../../../images/system-config-ps1.png"><img src="../../../../images/system-config-ps1.png" alt="system-config-ps1.png" /></a>
</p>
</div>

<p>
在这里你可以看到，原来只有一行的提示符，现在变成两行了，颜色也更丰富了。有些人非常受不了提示符被改变，一个劲的追问该怎么改回去，甚至因此就放弃了 system-config 或者忍不住差点破口大骂。其实大可不必。我就不告诉你怎么改，你自己 <a href="http://bing.com/search?q=bash+%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8F%90%E7%A4%BA%E7%AC%A6%E6%94%B9%E5%8A%A8">必应</a> 一下吧。这里我只说一下我这么改的理由、好处。
</p>

<ol class="org-ol">
<li>我可以不折行输入的命令长度最大化了。

<p>
默认因为都是在一行上，并且提示符里包含了当前路径，所以输入的命令稍微长一点，就会发生折行。并且随着当前路径的深度而变化。
</p>
</li>

<li>以前无法用鼠标双击选中当前路径名，必须用鼠标按下拖曳；现在因为在其前后各有一个空格，所以你鼠标双击一下，就能选中整个当前路径。

<p>
注意这是我以前觉得非常有需要的一个功能，现在我用更好的方法实现了，那就是 up 系列命令，接下来会讲到。
</p>
</li>

<li>可以更方便的显示更多信息。

<p>
比如上面你看到的是远程登录的提示符， 其中有 <code>Remote:True</code> 字样。并且上一条命令失败的话，会显示返回值是多少，几点几分失败的。
</p>

<p>
如果是本地登录的话，颜色会更花哨，并且我可以方便的自定义更多的显示信息（通过 start-recursive-shell 命令或者另外的一些对它进行了调用的命令）：
</p>


<div class="figure">
<p><a href="../../../../images/start-recursive-shell-ps1.png"><img src="../../../../images/start-recursive-shell-ps1.png" alt="start-recursive-shell-ps1.png" /></a>
</p>
</div>

<p>
比如上图中，我启动了一个代理（你懂的），然后用 <code>adb -s</code> 命令设置了一下当前的adb设备。
</p>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> 安卓开发相关</h3>
<div class="outline-text-3" id="text-2-3">
</div><div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1"><span class="section-number-4">2.3.1</span> 对adb的增强</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
说到这儿，讲一下我对adb的一些增强。
</p>

<p>
system-config里的adb像cd一样，是一个别名，实际调用的是my-adb脚本。以下是与adb相关的最常用的一些增强：
</p>

<ol class="org-ol">
<li><code>adb -s</code> 直接设置 <code>ANDROID_SERIAL</code> 环境变量，如果有多个adb设备，非常方便，并且会在命令行提示符上显示当前bash会话里选的是哪个adb设备。
</li>

<li><code>adb COMMAND</code> 直接运行相关的 <code>COMMAND</code> ，相当于输入了 <code>adb shell COMMAND</code> ，但不需要多打一个 <code>shell</code> （前提是 <code>COMMAND</code> 不是adb自带的子命令，比如 <code>sync</code> ， <code>adb sync</code> 是用于同步本地文件夹到adb设备的system或data分区； <code>adb shell sync</code> 则是调用 adb 设备上的 <code>sync</code> 命令，这是一个Linux系统程序，用于命令Kernel把内存中的缓存数据写回外部存储设备）。
</li>

<li><code>adb COMMAND ARGS</code> 直接相当于在交互的 <code>adb shell</code> 下输入了 COMMAND ARGS ，不需要额外加引号，因为有时候稍微复杂一点的命令，把引号加正确就变成一件很困难的苦差。

<p>
比如
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #0072b2;">command</span> adb shell echo <span style="color: #848ea9;">'hello    world'</span>
</pre>
</div>
<p>
你会看到结果跟先启动adb shell，然后再输入
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #0072b2;">echo</span> <span style="color: #848ea9;">'hello    world'</span>
</pre>
</div>
<p>
是不一样的，因为adb把引号给“吃掉”了。但system-config里，你可以直接输入
</p>
<div class="org-src-container">

<pre class="src src-sh">adb echo <span style="color: #848ea9;">'hello    world'</span>
</pre>
</div>
<p>
最后得到更合理的那个结果。
</p>

<p>
同理， <code>adb A_QUOTED_STRING_WITH_SPACES_IN_IT</code> 会把后面的参数交给 <code>sh -c</code> ，也就是说，在system-config下输入
</p>

<div class="org-src-container">

<pre class="src src-sh">adb <span style="color: #848ea9;">'echo "hello    world"'</span>
</pre>
</div>

<p>
结果与先启动 <code>adb shell</code> ，然后输入
</p>
<div class="org-src-container">

<pre class="src src-sh">sh -c <span style="color: #848ea9;">'echo "hello    world"'</span>
</pre>
</div>
<p>
是一样的。这个特性我想应该是从Perl的system函数得到的启发，参考 <code>perldoc -f system</code> 。
</p>
</li>

<li>其他一系列与adb相关的脚本，比如adb-push和adb-pull，adb自带的push和pull只支持一次处理一个文件或文件夹，于是我简单的封装了一下，adb-push/adb-pull一次可以处理多个文件或文件夹。

<p>
刚刚简单的看了一下，我的system-config的bin目录下，大约有170个adb相关的命令&#x2026;
</p>
</li>
</ol>
</div>
</div>
</div>
</div>



<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> system-config原理</h2>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Bao Haojun</p>
<p class="date">Created: 2016-04-17 Sun 08:46</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"></p>
</div>
</body>
</html>
