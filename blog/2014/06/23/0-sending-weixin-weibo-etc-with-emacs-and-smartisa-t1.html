<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>在Linux下用Emacs+Smartisan T1手机发weixin/weibo/qq/email/sms</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Bao Haojun" />
<link rel="stylesheet" href="/css/default.css" type="text/css" />
 <link rel="shortcut icon" href="/poison.png" type="image/png" />

    <script type="text/javascript" src="/js/jquery-1.7.1.min.js"></script>
    <script type="text/javascript">
        var BYB = {};
    </script>
    <script type="text/javascript">
        BYB.includeScript = function(file,callback){
            var _doc = document.getElementsByTagName('head')[0];
            var js = document.createElement('script');
            js.setAttribute('type', 'text/javascript');
            js.setAttribute('src', file);
            _doc.appendChild(js);

            if (!/*@cc_on!@*/0) { //if not IE
                //Firefox2、Firefox3、Safari3.1+、Opera9.6+ support js.onload
                js.onload = function () {
                    callback();
                }
            } else {
                //IE6、IE7 support js.onreadystatechange
                js.onreadystatechange = function () {
                    if (js.readyState == 'loaded' || js.readyState == 'complete') {
                        callback();
                    }
                }
            }
            return false;
        }
    </script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<div id="header">

  <h1 id="blog-title">

    包昊军的博客

  </h1>
  <p id="description">What you don't know, won't hurt you.</p>

</div>
</div>
<div id='bhj_article'>
  <div id='bhj_leftpane'>
<div id="content">
<h1 class="title">在Linux下用Emacs+Smartisan T1手机发weixin/weibo/qq/email/sms</h1>
<p>
大家好，今天我们来讲一讲怎么在Linux下，用Emacs+Smartisan T1来发微信、
微博、QQ等操作。
</p>

<p>
其实这只是一个高度自动化的过程，我把几个关键点先说一说。
</p>

<ol class="org-ol">
<li>用Emacs编辑要发送的内容
</li>
<li>把内容adb push到手机上，放入手机的剪贴板
</li>
<li>操作手机的输入，一般是长按编辑框，点粘贴，再点发送按钮
</li>
</ol>

<p>
为了完成以上的步骤，我写了很多脚本，下面是更详细的说明。
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 用Emacs编辑内容</h2>
<div class="outline-text-2" id="text-1">
<p>
这里我会用到几个脚本，比如一个叫weixin的脚本，还有一个叫weibo的脚本。
它们分别是用来发微信和微博用的。但实际上，这两个脚本是一模一样的。嗯，
在这里我采取了busybox的做法，根据 <code>argv[0]</code> 来决定程序不同的行为（在
shell编程中相应的是 <code>$(basename $0)</code> 了）。
</p>

<p>
这个脚本的位置在 <a href="https://github.com/baohaojun/system-config/raw/master/bin/adb-send-weixin">adb-send-weixin</a>：
</p>
<div class="org-src-container">

<pre class="src src-sh"><span class="org-comment-delimiter">#</span><span class="org-comment">!/bin/</span><span class="org-keyword">bash</span>

<span class="org-builtin">export</span> <span class="org-variable-name">USE_BUFFER_NAME</span>=send-to-$(<span class="org-sh-quoted-exec">basename</span> $<span class="org-variable-name">0</span>).org
(
    <span class="org-keyword">if</span> <span class="org-negation-char">!</span> flock -n 9; <span class="org-keyword">then</span>
        find-or-exec emacs <span class="org-string">"No such thing"</span>
        emacsclient -e <span class="org-string">'(switch-to-buffer "'</span>$<span class="org-variable-name">USE_BUFFER_NAME</span><span class="org-string">'")'</span>
        <span class="org-keyword">exit</span>
    <span class="org-keyword">fi</span>

    <span class="org-keyword">while</span> true; <span class="org-keyword">do</span>
        <span class="org-variable-name">input</span>=$(<span class="org-sh-quoted-exec">ask-for-input-with-emacs</span> -p <span class="org-string">"What do you want say on $(</span><span class="org-sh-quoted-exec">basename</span><span class="org-string"> $0)?"</span> || true)
        <span class="org-keyword">if ! </span><span class="org-builtin">test</span> <span class="org-string">"$input"</span>; <span class="org-keyword">then</span>
            <span class="org-keyword">exit</span>
        <span class="org-keyword">fi</span>
        (
            flock 10
            putclip-android <span class="org-string">"$input"</span>&amp;
            <span class="org-keyword">if </span><span class="org-builtin">test</span> $(<span class="org-sh-quoted-exec">basename</span> $<span class="org-variable-name">0</span>) = google+; <span class="org-keyword">then</span>
                adb-long-press 144 374 <span class="org-comment-delimiter"># </span><span class="org-comment">long press</span>
                adb-tap 117 273 <span class="org-comment-delimiter"># </span><span class="org-comment">paste</span>
                adb-tap 949 935 <span class="org-comment-delimiter"># </span><span class="org-comment">send</span>
            <span class="org-keyword">elif </span><span class="org-builtin">test</span> $(<span class="org-sh-quoted-exec">basename</span> $<span class="org-variable-name">0</span>) = weibo; <span class="org-keyword">then</span>
                adb input keyevent SPACE
                adb-long-press 440 281; adb-tap 545 191
                adb-tap 991 166
            <span class="org-keyword">elif </span><span class="org-builtin">test</span> $(<span class="org-sh-quoted-exec">basename</span> $<span class="org-variable-name">0</span>) = t1-sms; <span class="org-keyword">then</span>
                adb-tap 560 1840 <span class="org-comment-delimiter"># </span><span class="org-comment">&#28857;&#31354;&#26684;</span>
                adb-long-press 522 912 <span class="org-comment-delimiter"># </span><span class="org-comment">&#38271;&#25353;&#36755;&#20837;&#26694;</span>
                adb-tap 480 802
                adb-tap 864 921
            <span class="org-keyword">elif </span><span class="org-builtin">test</span> $(<span class="org-sh-quoted-exec">basename</span> $<span class="org-variable-name">0</span>) = cell-mail; <span class="org-keyword">then</span>
                adb shell input touchscreen swipe 586 878 586 268 500
                adb-tap 560 1840 <span class="org-comment-delimiter">#</span>
                adb-long-press 322 283
                adb-tap 505 192
                adb-tap 998 174
            <span class="org-keyword">else</span> <span class="org-comment-delimiter"># </span><span class="org-comment">weixin and qq</span>
                adb-tap 560 1840 <span class="org-comment-delimiter"># </span><span class="org-comment">&#28857;&#19968;&#19979;&#24213;&#37096;&#36755;&#20837;&#26694;&#65292;&#24377;&#20986;&#36719;&#38190;&#30424;</span>
                sleep .1
                adb-tap 560 1840 <span class="org-comment-delimiter"># </span><span class="org-comment">&#20877;&#28857;&#19968;&#19979;&#65292;&#21487;&#33021;&#22312;&#20986;&#38190;&#30424;&#65292;&#38656;&#35201;&#36755;&#20837;&#19968;&#20010;&#31354;&#26684;</span>
                adb-long-press 560 976 <span class="org-comment-delimiter"># </span><span class="org-comment">&#38271;&#28857;&#36755;&#20837;&#26694;</span>
                adb-tap 525 855 <span class="org-comment-delimiter"># </span><span class="org-comment">&#28857;&#19968;&#19979;&#31896;&#36148;&#38062;</span>
                adb-tap 976 976 <span class="org-comment-delimiter"># </span><span class="org-comment">&#28857;&#19968;&#19979;&#21457;&#36865;&#38062;</span>
            <span class="org-keyword">fi</span>
        ) 10&gt; ~/.logs/$(<span class="org-sh-quoted-exec">basename</span> $<span class="org-variable-name">0</span>).lock-send &amp;
    <span class="org-keyword">done</span>
) 9&gt; ~/.logs/$(<span class="org-sh-quoted-exec">basename</span> $<span class="org-variable-name">0</span>).lock
</pre>
</div>

<p>
然后有N个脚本都是指向这个 adb-send-weixin 的软链接：
</p>

<pre class="example">
$ls -l |grep weixin
-rwxr-xr-x 1 bhj bhj    1807 Jun 23 16:53 adb-send-weixin*
lrwxrwxrwx 1 bhj bhj      15 Jun 20 11:55 cell-mail -&gt; adb-send-weixin*
lrwxrwxrwx 1 bhj bhj       6 Jun 17 11:16 google+ -&gt; weixin*
lrwxrwxrwx 1 bhj bhj      15 Jun 10 11:27 qq -&gt; adb-send-weixin*
lrwxrwxrwx 1 bhj bhj       6 Jun 23 16:47 t1-sms -&gt; weixin*
lrwxrwxrwx 1 bhj bhj      15 Jun 20 10:36 weibo -&gt; adb-send-weixin*
lrwxrwxrwx 1 bhj bhj      15 Jun  7 12:04 weixin -&gt; adb-send-weixin*
</pre>

<p>
这个脚本大致的工作是启动一个死循环，第二段里的 <code>while true; do
... done</code> ，先用ask-for-input-with-emacs获取我要在weixin/weibo里输入的
内容，然后用putclip-android把这个内容放到手机的剪贴板里去，然后用一堆
adb-long-press/adb-tap等操作把贴到手机应用程序里并发送出去。
</p>

<p>
上面用的坐标全是用我厂的Smartisan T1手机适配出来的，如果用别的厂的手机
的话，大家需要自己适配一下啦。
</p>

<p>
适配的方法有两种，一种是打开手机设置里的开发者选项，勾选上显示触摸操作
和指针位置，这样你在屏幕上指指点点的时候，X/Y的座标会被显示上屏幕上方。
另一种则是我写的另一个小脚本，在屏幕上长按手指在一个位置，会打应出相应
的坐标。二者各有利弊，主要是第一种老是要打开之后又要记得关闭，操作比较
繁琐，第二种呢，则不是实时的显示坐标。哦对了，我自己现在是用第二种比较
多了，因为我可以截一张图下来慢慢点。Smartisan T1截图真的是超方便。小脚
本的位置在<a href="https://github.com/baohaojun/system-config/raw/master/bin/adb-get-xy">adb-get-xy</a>。
</p>

<div class="org-src-container">

<pre class="src src-sh"><span class="org-comment-delimiter">#</span><span class="org-comment">!/bin/</span><span class="org-keyword">bash</span>

adb getevent -l |perl -ne <span class="org-string">'</span>
<span class="org-string">    if (m/ABS_MT_POSITION_/) {</span>
<span class="org-string">        chomp;</span>
<span class="org-string">        @fields = split;</span>
<span class="org-string">        ($name, $val) = @fields[2,3];</span>
<span class="org-string">        $val = hex($val);</span>
<span class="org-string">        print "$name: $val\n";</span>
<span class="org-string">    }</span>
<span class="org-string">'</span>
</pre>
</div>

<p>
其输出结果大概是这样的：
</p>

<pre class="example">
$adb-get-xy
ABS_MT_POSITION_X: 550
ABS_MT_POSITION_Y: 1006
ABS_MT_POSITION_X: 549
ABS_MT_POSITION_X: 548
ABS_MT_POSITION_X: 547
ABS_MT_POSITION_X: 546
ABS_MT_POSITION_X: 545
ABS_MT_POSITION_X: 544
ABS_MT_POSITION_X: 543
</pre>

<p>
下面来讲一下adb-send-to-weixin里用到的一些其他辅助脚本和命令。
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> flock</h3>
<div class="outline-text-3" id="text-1-1">
<p>
flock是常用的一个shell下通过文件锁来进行进程间同步互斥的机制，在这里我
用了两个flock，其中一个是说如果发现weixin死循环已经在跑的话，新的死循
环就不开启了，而是通过find-or-exec把Emacs窗口提到前面来，再通过
emacsclient把正在进行weixin编辑的Emacs buffer调到前面来。
</p>

<p>
另一个flock则是为了进行性能优化，每次我编辑完一条weixin内容之后，我就
在后台(bash的&amp;符号)执行手机上的操作（放剪贴板、各种长按短按），这些后
台操作我是肯定不希望它们有重合的，否则就会乱套。这样呢，我可以马上进行
下一条微信的编辑，然后是再下一条，不需要等手机把上一条微信发出去先，如
果weixin聊天也能有flow的状态的话，这样就能保证我的flow状态不会被打断了:-)
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> find-or-exec</h3>
<div class="outline-text-3" id="text-1-2">
<p>
这是一段sawfish脚本，对我的Linux桌面管理器是sawfish。见 <a href="https://github.com/baohaojun/system-config/raw/master/bin/find-or-exec">find-or-exec</a> 。
</p>

<div class="org-src-container">

<pre class="src src-sh"><span class="org-comment-delimiter">#</span><span class="org-comment">!/bin/</span><span class="org-keyword">bash</span>

<span class="org-builtin">set</span> -e

<span class="org-keyword">function</span> <span class="org-function-name">die</span>() {
    <span class="org-builtin">echo</span> Error: <span class="org-string">"$@"</span>
    <span class="org-keyword">exit</span> -1
}

<span class="org-keyword">if </span><span class="org-builtin">test</span> $<span class="org-variable-name">#</span> = 0; <span class="org-keyword">then</span>
    die <span class="org-string">"Error: Usage $(</span><span class="org-sh-quoted-exec">basename</span><span class="org-string"> $0) window_class [program_to_exec]"</span>
<span class="org-keyword">fi</span>

<span class="org-keyword">if </span><span class="org-builtin">test</span> <span class="org-string">"$1"</span> = konsole; <span class="org-keyword">then</span>
    <span class="org-builtin">shift</span>;
    <span class="org-builtin">set</span> -- <span class="org-string">"konsole|xfce4-terminal"</span> <span class="org-string">"$@"</span>
<span class="org-keyword">fi</span>

<span class="org-variable-name">sawfish_exp</span>=$(<span class="org-sh-quoted-exec">printf</span> <span class="org-string">'(find-window-or-exec "%s" "%s")'</span> <span class="org-string">"$1"</span> <span class="org-string">"${2:-true}"</span>)

sawfish-client -e <span class="org-string">"$sawfish_exp"</span> &gt;/dev/null 2&gt;&amp;1 &amp;
</pre>
</div>

<p>
这是一段bash脚本，如果你用bash -x看它的trace的话，你会发现：
</p>

<pre class="example">
$bash -x find-or-exec emacs
+ set -e
+ test 1 = 0
+ test emacs = konsole
++ printf '(find-window-or-exec "%s" "%s")' emacs true
+ sawfish_exp='(find-window-or-exec "emacs" "true")'
+ sawfish-client -e '(find-window-or-exec "emacs" "true")'
</pre>

<p>
最后会调一个find-window-or-exec的sawfish函数，我是这样定义的 （见我的
<a href="https://github.com/baohaojun/system-config/raw/master/.sawfishrc">.sawfishrc</a>）：
</p>

<div class="org-src-container">

<pre class="src src-sawfish">(defun find-window-or-exec (wclass-or-lambda #!optional wcommand)
  (if (eq (catch 'wFound
            (mapc (lambda (window)
                    (when (if (stringp wclass-or-lambda)
                              (string-match wclass-or-lambda (bhj-window-class window) 0 t)
                            (when functionp wclass-or-lambda
                                  (write (stderr-file) "hello world\n")
                                  (wclass-or-lambda window)))

                      (bhj-activate-window window)
                      (throw 'wFound 'wFound)))
                  (stacking-order)))
          'wFound)
      t
    (if wcommand
        (system (concat wcommand "&amp;")))
    nil))
</pre>
</div>

<p>
这个就不展开了，再展开就要栈溢出了:-)
</p>

<p>
但是find-or-exec的确是一个我很常用的方便我在Emacs/Terminal之间切换的程
序。设想我在Terminal底下执行一段bash脚本，里面用到了emacs，它能直接帮
我把Emacs窗口弹到前面来；等Emacs操作结束后，它又能把Terminal给我弹回来。
</p>

<p>
常有一些Emacs的大仙说用Emacs可以在Emacs内开eshell什么的，永远不需要离
开Emacs窗口。但首先eshell等都比较有问题，还有性能什么的。并且你还是得
切换buffer嘛。然后我的find-or-exec可以做到自动帮我切换，所以这回我就没
听大仙们的。
</p>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> putclip-android</h3>
<div class="outline-text-3" id="text-1-3">
<p>
putclip/getclip是cygwin下的程序。在Linux底下有一个xclip，在Mac OS X底
下有一个pbcopy/pbpaste。
</p>

<p>
但为了我自己编程写脚本、终端上打命令能够统一，我使用了design pattern里
的不知哪种模式，在Linux下和Mac OS X下也实现了一个相应地用xclip和
pbcopy/pbpaste实现了putclip/getclip。
</p>

<p>
在Linux下的putclip功能最复杂，也最强大。见 <a href="https://github.com/baohaojun/system-config/raw/master/bin/Linux/putclip">putclip</a> 。
</p>

<div class="org-src-container">

<pre class="src src-sh"><span class="org-comment-delimiter">#</span><span class="org-comment">!/bin/</span><span class="org-keyword">bash</span>
<span class="org-keyword">if </span><span class="org-builtin">echo</span> $<span class="org-variable-name">SHELLOPTS</span> | grep xtrace; <span class="org-keyword">then</span>
    <span class="org-builtin">export</span> SHELLOPTS
<span class="org-keyword">fi</span>
<span class="org-keyword">if </span><span class="org-builtin">test</span> $<span class="org-variable-name">#</span> != 0; <span class="org-keyword">then</span>
    <span class="org-keyword">exec</span> &lt;&lt;EOF
<span class="org-sh-heredoc">$@</span>
<span class="org-sh-heredoc">EOF</span>
<span class="org-keyword">fi</span>

<span class="org-keyword">if </span><span class="org-builtin">test</span> <span class="org-string">"$EMACS"</span> = t -o <span class="org-string">"$REMOTEIP"</span>; <span class="org-keyword">then</span>
    rm-last-nl &gt; /tmp/$<span class="org-variable-name">$</span>.putclip
    <span class="org-builtin">export</span> <span class="org-variable-name">FILE</span>=/tmp/$<span class="org-variable-name">$</span>.putclip
    (
        <span class="org-keyword">if </span><span class="org-builtin">test</span> <span class="org-string">"$REMOTEIP"</span> = <span class="org-string">""</span>; <span class="org-keyword">then</span>
            <span class="org-variable-name">prefix</span>=<span class="org-string">""</span>
            <span class="org-variable-name">arg_handler</span>=echo
        <span class="org-keyword">else</span>
            <span class="org-keyword">if </span><span class="org-builtin">test</span> -e ~/.config/ssh-agent; <span class="org-keyword">then</span>
                <span class="org-builtin">.</span> ~/.config/ssh-agent
            <span class="org-keyword">fi</span>
            ssh ${<span class="org-variable-name">REMOTEUSER</span>:-$<span class="org-variable-name">USER</span>}@$<span class="org-variable-name">REMOTEIP</span> remote-putclip $(<span class="org-sh-quoted-exec">whoami</span>)@$<span class="org-variable-name">LOCALIP</span>:$<span class="org-variable-name">FILE</span>
            <span class="org-keyword">exit</span> 0
        <span class="org-keyword">fi</span>

        $<span class="org-variable-name">prefix</span> emacsclient --eval <span class="org-string">"</span>
<span class="org-string">(let ((default-directory \"/tmp/\"))</span>
<span class="org-string">(view-file \"$FILE\")</span>
<span class="org-string">(kill-new (filter-buffer-substring (point-min) (point-max)))</span>
<span class="org-string">(View-quit))"</span>
        $<span class="org-variable-name">prefix</span> rm $<span class="org-variable-name">FILE</span>
        xclip -o -selection clipboard|xclip -i
    ) &gt;~/.logs/putclip.log 2&gt;&amp;1&amp;
<span class="org-keyword">else</span>
    rm-last-nl|xclip -i -selection clipboard &gt;/dev/null 2&gt;&amp;1
    xclip -o -selection clipboard|xclip -i &gt;/dev/null 2&gt;&amp;1
<span class="org-keyword">fi</span>
</pre>
</div>

<p>
简单地说，它在ssh远程登录和Emacs底下都能用。为什么这个事情值得说一下呢？
因为首先ssh登录之后如果还能继续用putclip的话（没有用ssh -X，所以不能
xclip），命令行和GUI能结合得更好。然后在Emacs下，直接操作xclip是会引起
死锁的，因为Emacs是个单线程程序，它执行xclip命令之后，就会等待结束，可
是呢xclip又要等持有着X剪贴板内容的程序跟它通讯，把剪贴板内容传过来。设
想一下持有X剪贴板内容的程序大部分情况下会是谁呢？就是Emacs自己！
</p>

<p>
这些是题外话，您看我的博客买一送一，跟putclip-android没什么关系。这个脚本见 <a href="https://github.com/baohaojun/system-config/raw/master/bin/putclip-android">putclip-android</a> 。
</p>


<div class="org-src-container">

<pre class="src src-sh"><span class="org-comment-delimiter">#</span><span class="org-comment">!/bin/</span><span class="org-keyword">bash</span>

<span class="org-keyword">if </span><span class="org-builtin">test</span> <span class="org-string">"$#"</span> = 0; <span class="org-keyword">then</span>
    <span class="org-builtin">set</span> -- <span class="org-string">"$(</span><span class="org-sh-quoted-exec">ask-for-input-with-emacs</span><span class="org-string">)"</span>
<span class="org-keyword">fi</span>
<span class="org-builtin">echo</span> -n <span class="org-string">"$@"</span> &gt; ~/.logs/$(<span class="org-sh-quoted-exec">basename</span> $<span class="org-variable-name">0</span>).txt

adb <span class="org-string">"set -x;</span>
<span class="org-string">echo -n $(</span><span class="org-sh-quoted-exec">printf</span><span class="org-string"> %q "$@") &gt; /sdcard/putclip.txt</span>
<span class="org-string">am startservice -n com.bhj.setclip/.PutClipService</span>
<span class="org-string">for x in \$(</span><span class="org-sh-quoted-exec">seq</span><span class="org-string"> 1 20); do if test -e /sdcard/putclip.txt; then busybox sleep .1; echo \$x; else exit; fi; done"</span>
</pre>
</div>
</div>

<div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> adb</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
第三层标题了。我保证不会出现第四层标题。
</p>

<p>
上面这个脚本里我的adb命令用法很奇特，它直接跟了一大段shell脚本，没有用
adb shell COMMAND这个形式。这是因为我嫌每次都要打shell这个单词太累了。
</p>

<p>
如果你以为我只是把shell去掉而已的话你就错了！
</p>

<p>
我更多的工作是在引号的处理和终端的交互上。
</p>

<p>
先说说终端的交互。像su命令那样，su -c "echo hello world" 有点像adb
shell "echo hello world"，但 su -c "bash"就跟adb shell bash很不一样了，
前者你能得到一个可以交互的shell，后者你输入任何命令都没有响应。这个问
题我是通过expect解决的。
</p>

<p>
我的adb包装过之后执行adb shell bash时，它会执行expect，然后spawn出一个
adb shell，然后把所有的参数（在这里是bash）发过去，所以最后的结果就像
是你自己启动了一个adb shell，然后再在可以交互的提示符下输入了bash。见
<a href="https://github.com/baohaojun/system-config/raw/master/bin/adb-expect">adb-expect</a>。
</p>

<p>
引号的处理则相当的奇葩。adb的.c程序在处理参数的时候如果发现某个参数里
带有空格，就会在它的两头各加上一个双引号。所以：
</p>

<pre class="example">
{ bhj@bhj-laptop /home/bhj/bin Ret: 130 @ 21:51:38 }
$the-true-adb shell echo "hello    world"
hello    world

{ bhj@bhj-laptop /home/bhj/bin }
$echo "hello    world"
hello    world
</pre>

<p>
这个跟直接在bash里打 <code>(echo "hello world")</code> 效果是一致的（为了让这个命
令在org-mode里变成monospace字体，我必须加一个括号，有谁知道更好的办法
么？）。可是在bash里你还可以 <code>(echo 'hello   "   world')</code> ，可是在adb下就会出错：
</p>

<pre class="example">
{ bhj@bhj-laptop /home/bhj/bin Ret: 130 @ 21:54:59 }
$(echo 'hello   "   world')
hello   "   world

{ bhj@bhj-laptop /home/bhj/bin }
$the-true-adb shell echo 'hello   "   world'
/system/bin/sh: no closing quote
</pre>

<p>
如果你用strace去看怎么回事儿的话，你会发现adb送给手机执行的命令是这样的：
</p>

<pre class="example">
{ bhj@bhj-laptop /home/bhj/bin Ret: 130 @ 21:55:55 }
$strace -e write -f the-true-adb shell echo 'hello   "   world'
[ Process PID=7340 runs in 32 bit mode. ]
write(3, "000c", 4)                     = 4
write(3, "host:version", 12)            = 12
write(3, "0012", 4)                     = 4
write(3, "host:transport-any", 18)      = 18
write(3, "001e", 4)                     = 4
write(3, "shell:echo \"hello   \"   world\"", 30) = 30
write(1, "/system/bin/sh: no closing quote"..., 34/system/bin/sh: no closing quote
) = 34
</pre>

<p>
把引号归整一下，手机的sh看到的命令是 <code>(echo "hello " world")</code> （去掉括
号）。
</p>

<p>
查看一下adb对引号的处理：
</p>

<div class="org-src-container">

<pre class="src src-c">quote = (**argv == 0 || strchr(*argv, <span class="org-string">' '</span>));
<span class="org-keyword">if</span> (quote)
    strcat(buf, <span class="org-string">"\""</span>);
strcat(buf, *argv++);
<span class="org-keyword">if</span> (quote)
    strcat(buf, <span class="org-string">"\""</span>);
</pre>
</div>

<p>
能不能把引号弄对是bash脚本编程功底的一种体现:-) 如之前所述，如果我是在
用adb-expect打开一个终端给每个非交互式的 <code>adb shell echo hello</code> 调用的
话，那引号不是一个问题：
</p>

<pre class="example">
{ bhj@bhj-laptop /home/bhj/src/android/system/core/adb }
$adb-expect echo 'hello   "   world'
spawn the-true-adb shell
root@msm8974sfo:/ # exec 'echo' 'hello   "   world'
hello   "   world
</pre>

<p>
可是这样太影响性能了，并且会影响我对adb进行编程，我必须把前面的两行输
出给过滤掉。
</p>

<p>
所以我还是把引号机制硬生生给它掰正了：
</p>

<div class="org-src-container">

<pre class="src src-sh"><span class="org-variable-name">IFS</span>=$<span class="org-string">'\n'</span>
<span class="org-keyword">for</span> x<span class="org-keyword"> in</span> <span class="org-string">"$@"</span>; <span class="org-keyword">do</span>
    <span class="org-variable-name">args</span>=(<span class="org-string">"${args[@]}"</span> $(
                 <span class="org-keyword">if </span><span class="org-builtin">test</span> <span class="org-string">"$(</span><span class="org-sh-quoted-exec">printf</span><span class="org-string"> %q "$x")"</span> != <span class="org-string">"$x"</span>; <span class="org-keyword">then</span>
                     <span class="org-comment-delimiter"># </span><span class="org-comment">echo \"\'"$(</span><span class="org-sh-quoted-exec">echo</span><span class="org-comment"> -n "$x" | perl -npe "s!'!\\'!")"\'\"</span>
                     <span class="org-builtin">printf</span> <span class="org-string">\"</span>%q<span class="org-string">\"</span> <span class="org-string">"$x"</span>
                 <span class="org-keyword">else</span>
                     <span class="org-builtin">printf</span> %q <span class="org-string">"$x"</span>
                 <span class="org-keyword">fi</span>))
<span class="org-keyword">done</span>

<span class="org-keyword">exec</span> the-true-adb ${<span class="org-variable-name">args</span>[@]}
</pre>
</div>

<p>
如果发现某个参数 (the x in "$@") 需要 quote 的话( <code>(test "$(printf %q
"$x")" != "$x")</code> )，那我们就给它quote，并前后各加一个双引号：
（ <code>(printf \"%q\" "$x")</code> ）。否则就只quote但不加双引号。因为在底下
<code>exec the-true-adb ${args[@]}</code> 的时候，我们没有给 <code>${args[@]}</code> 加上双
引号，所以之前的quote被取消（printf %q），传过去的参数跟之前是一样的，
但不同的是有一些参数前后各加了一个双引号，这些参数被adb的.c程序再在前
后各加一双引号，最后结果等于没加，得到了我们想要的bash引号行为！
</p>

<p>
我的adb脚本在 <a href="https://github.com/baohaojun/system-config/raw/master/bin/overide/adb">adb</a> ，我自己已经快看不明白了。
</p>
</div>
</div>

<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2"><span class="section-number-4">1.3.2</span> PutClipService</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
又一个第三级标题，putclip-android用到的一个手机小apk。这个程序见 <a href="https://github.com/baohaojun/system-config/raw/master/gcode/SetClip/src/com/bhj/setclip/PutClipService.java">PutClipService.java</a> 。
</p>

<div class="org-src-container">

<pre class="src src-java"><span class="org-keyword">package</span> com.bhj.<span class="org-constant">setclip</span>;

<span class="org-keyword">import</span> <span class="org-constant">android</span>.<span class="org-constant">app</span>.<span class="org-type">Service</span>;
<span class="org-keyword">import</span> <span class="org-constant">android</span>.<span class="org-constant">content</span>.<span class="org-type">ClipboardManager</span>;
<span class="org-keyword">import</span> <span class="org-constant">android</span>.<span class="org-constant">content</span>.<span class="org-type">ClipData</span>;
<span class="org-keyword">import</span> <span class="org-constant">android</span>.<span class="org-constant">content</span>.<span class="org-type">Intent</span>;
<span class="org-keyword">import</span> <span class="org-constant">android</span>.<span class="org-constant">os</span>.<span class="org-type">IBinder</span>;
<span class="org-keyword">import</span> <span class="org-constant">android</span>.<span class="org-constant">widget</span>.<span class="org-type">Toast</span>;
<span class="org-keyword">import</span> <span class="org-constant">java</span>.<span class="org-constant">io</span>.<span class="org-type">File</span>;
<span class="org-keyword">import</span> <span class="org-constant">java</span>.<span class="org-constant">io</span>.<span class="org-type">FileReader</span>;

<span class="org-keyword">public</span> <span class="org-keyword">class</span> <span class="org-type">PutClipService</span> <span class="org-keyword">extends</span> <span class="org-type">Service</span> {
    <span class="org-c-annotation">@Override</span>
    <span class="org-keyword">public</span> <span class="org-type">IBinder</span> <span class="org-function-name">onBind</span>(<span class="org-type">Intent</span> <span class="org-variable-name">intent</span>) {
        <span class="org-keyword">return</span> <span class="org-constant">null</span>;
    }

    <span class="org-c-annotation">@Override</span>
    <span class="org-keyword">public</span> <span class="org-type">int</span> <span class="org-function-name">onStartCommand</span>(<span class="org-type">Intent</span> <span class="org-variable-name">intent</span>,  <span class="org-type">int</span> <span class="org-variable-name">flags</span>,  <span class="org-type">int</span> <span class="org-variable-name">startId</span>)  {
        <span class="org-keyword">try</span> {
            <span class="org-type">FileReader</span> <span class="org-variable-name">f</span> = <span class="org-keyword">new</span> <span class="org-type">FileReader</span>(<span class="org-keyword">new</span> <span class="org-type">File</span>(<span class="org-string">"/sdcard/putclip.txt"</span>));
            <span class="org-type">char</span>[] <span class="org-variable-name">buffer</span> = <span class="org-keyword">new</span> <span class="org-type">char</span>[1024];
            <span class="org-type">int</span> <span class="org-variable-name">n</span> = f.read(buffer);
            <span class="org-type">String</span> <span class="org-variable-name">str</span> = <span class="org-keyword">new</span> <span class="org-type">String</span>(buffer, 0, n);
            <span class="org-type">ClipboardManager</span> <span class="org-variable-name">mClipboard</span>;
            mClipboard = (<span class="org-type">ClipboardManager</span>)getSystemService(CLIPBOARD_SERVICE);
            mClipboard.setPrimaryClip(ClipData.newPlainText(<span class="org-string">"Styled Text"</span>, str));
            <span class="org-type">File</span> <span class="org-variable-name">putclip</span> = <span class="org-keyword">new</span> <span class="org-type">File</span>(<span class="org-string">"/sdcard/putclip.txt"</span>);
            putclip.delete();
        } <span class="org-keyword">catch</span> (<span class="org-type">Exception</span> <span class="org-variable-name">e</span>) {
            Toast.makeText(<span class="org-keyword">this</span>, <span class="org-string">"Something went wrong in putclip: "</span> + e.getMessage(), <span class="org-constant">Toast</span>.LENGTH_SHORT).show();
        }
        <span class="org-keyword">return</span> START_STICKY;
    }

    <span class="org-c-annotation">@Override</span>
    <span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">onDestroy</span>() {
    }
}
</pre>
</div>

<p>
最后putclip-android里是通过am startservice来启动这个service的。这个
java程序会打开adb push上来的weixin内容文件(/sdcard/putclip.txt），读出
来，放进剪贴板，删掉这个文件。脚本里有一个死循环一直在等待这个文件被删
除才返回。
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> adb-long-press 和 adb-tap</h2>
<div class="outline-text-2" id="text-2">
<p>
这两个基本上就是adb自带的input命令的封装。其中long-press在adb input命
令里是没有的，但是网上查一下也能查到用swipe来可以模拟出来（见
<a href="https://github.com/baohaojun/system-config/raw/master/bin/adb-long-press">adb-long-press</a>）：
</p>

<div class="org-src-container">

<pre class="src src-sh"><span class="org-comment-delimiter">#</span><span class="org-comment">!/bin/</span><span class="org-keyword">bash</span>

<span class="org-variable-name">seconds</span>=550
<span class="org-keyword">if </span><span class="org-builtin">test</span> $<span class="org-variable-name">#</span> = 5 -o $<span class="org-variable-name">#</span> = 3; <span class="org-keyword">then</span>
    <span class="org-variable-name">seconds</span>=$<span class="org-variable-name">1</span>
    <span class="org-builtin">shift</span>
<span class="org-keyword">fi</span>
<span class="org-keyword">if </span><span class="org-builtin">test</span> $<span class="org-variable-name">#</span> = 4; <span class="org-keyword">then</span>
    adb shell input touchscreen swipe $<span class="org-variable-name">1</span> $<span class="org-variable-name">2</span> $<span class="org-variable-name">3</span> $<span class="org-variable-name">4</span> $<span class="org-variable-name">seconds</span>
<span class="org-keyword">elif </span><span class="org-builtin">test</span> $<span class="org-variable-name">#</span> = 2; <span class="org-keyword">then</span>
    adb shell input touchscreen swipe $<span class="org-variable-name">1</span> $<span class="org-variable-name">2</span> $<span class="org-variable-name">1</span> $<span class="org-variable-name">2</span> $<span class="org-variable-name">seconds</span>
<span class="org-keyword">fi</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> sawfish快捷键</h2>
<div class="outline-text-2" id="text-3">
<div class="org-src-container">

<pre class="src src-sawfish">(bind-keys s-h-keymap "w"  '(system "weixin&amp;"))
(bind-keys global-keymap "XF86Mail" '(synthesize-multiple-events "C-x" "C-s" "C-x" "#"))
</pre>
</div>

<p>
这样，我按一下 <code>s-h w</code> 就能调出weixin的Emacs编辑，输入完内容之后，按一
下我的微软人体工学4000键盘上的Mail键，就会像按键小精灵一样给Emacs发4个
键， <code>C-x C-s C-x #</code> ，我的微信就发出去了。
</p>

<p>
当然，这之前你需要做是的确保已经调出来微信聊天窗口。
</p>

<p>
<del>另外，这些脚本都只能在adb root过后使用吧好像？主要是adb input命令必须有root权限？这个不确定，但即使我用的是user版本的手机，不能adb root，我的adb包装也有一个adb root-mode命令，进入之后每个adb shell COMMAND都会被重新解释成 adb shell su -c 'quoted COMMAND'，相当地绕呢，我自己都快被绕晕了。</del>
</p>

<p>
我记错了，这些脚本是不需要root权限的。Anyway, adb root-mode:-)
</p>

<p>
我的微博账号是 baohaojun，欢迎粉我。微信号是beagrep，欢迎加我。我聊天
打字速度很快的。
</p>
<nav>
  <ul id="prev_next_posts">
    <li class="prev_post">
      <a href="../04/0-binder.html"> <!-- prev-url -->
        <i class="icon-chevron-left">《</i>
        binder <!-- prev-title -->
      </a>
    </li>
    <li class="next_post" style="text-align: right;">
      <a href="../../../../meta/Archive.html"> <!-- next-url -->
        Archive <!-- next-title -->
        <i class="icon-chevron-right">》</i>
      </a>
    </li>
  </ul>
</nav>
</div>
</div>
</div>
<!-- {%html-mode%} -->

<div id="disqus_container">
  <script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: THIS CODE IS ONLY AN EXAMPLE * * */
    var disqus_shortname = 'baohaojun'; // Required - Replace example with your forum shortname
    var disqus_url = 'http://baohaojun.github.io/blog/2014/06/23/0-sending-weixin-weibo-etc-with-emacs-and-smartisa-t1.html';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
    <div style="margin-bottom:20px">
    <script type="text/javascript" charset="utf-8">
      (function(){
      var _w = 86 , _h = 16;
      var param = {
      url:location.href,
      type:'6',
      count:'', /**是否显示分享数，1显示(可选)*/
      appkey:'', /**您申请的应用appkey,显示分享来源(可选)*/
      title:'', /**分享的文字内容(可选，默认为所在页面的title)*/
      pic:'', /**分享图片的路径(可选)*/
      ralateUid:'1611427581', /**关联用户的UID，分享微博会@该用户(可选)*/
      language:'zh_cn', /**设置语言，zh_cn|zh_tw(可选)*/
      rnd:new Date().valueOf()
      }
      var temp = [];
      for( var p in param ){
      temp.push(p + '=' + encodeURIComponent( param[p] || '' ) )
      }
      document.write('<iframe allowTransparency="true" frameborder="0" scrolling="no" src="http://hits.sinajs.cn/A1/weiboshare.html?' + temp.join('&') + '" width="'+ _w+'" height="'+_h+'"></iframe>')
      })()
    </script>
  </div>
  <div id="disqus_thread"></div>
</div>

</div> <!-- bhj_leftpane -->
<div id="sidebar"><div id="sidebar2">


  <!-- Begin #profile-container -->

   <div id="profile-container"><h2 class="sidebar-title">About Me</h2>
<dl class="profile-datablock"><dt class="profile-img"><a href="/images/bhj.png""><img src="/images/bhj-thumb.png" alt="My Photo" height="58" width="80"></a></dt>
<dd class="profile-data"><strong>Name:</strong> <a rel="author" href="https://www.github.com/baohaojun"> Bao Haojun </a></dd>
<dd class="profile-data"><strong>Location:</strong>  Beijing, China </dd></dl>

<p class="profile-link"><a rel="author" href="/blog/2011/12/23/index.html">View my complete profile</a></p></div>

  <!-- End #profile -->



  <h2 class="sidebar-title">Feeds</h2>
    <ul>
        <li><a href="/atom.xml">Atom</a></li>
    </ul>

  <h2 class="sidebar-title">Projects</h2>
    <dl>
        <dt><a href="/blog/2011/12/23/beagrep.html"> Beagrep </a></dt>
        <dd> Grep 2G source code in 0.23 second </dd>

        <dt><a href="/blog/2013/04/13/skeleton-complete.html"> Skeletom-complete.el </a></dt>
        <dd> Type a bare skeleton, complete to a symbol/partial line/sexp/paragraph </dd>

        <dt><a href="/blog/2011/12/28/org-jira.html"> Org-jira.el </a></dt>
        <dd> Use JIRA with org-mode </dd>
    </dl>

    <h2>Tags</h2>
    <ul>
                <li><a href="../../../../meta/tags/tool.html" title="Computer tools">tool</a></li>
    </ul>

  <h2 class="sidebar-title">Previous Posts</h2>
    <ul id="recently">
        <li><a href='../04/0-binder.html'> binder </a></li>
<li><a href='../../05/20/0-build-tar-for-android-under-x86-64-debian.html'> 在Debian下为安卓做一个GNU tar程序 </a></li>
<li><a href='../../01/28/0-Firefor-urlbar-dropdown-list-not-showing-anymore.html'> Firefor urlbar dropdown list not showing anymore </a></li>
<li><a href='../../01/16/0-Use-GreaseMonkey-to-disable-google-redirect.html'> 用GreaseMonkey禁止Google搜索重定向绑架 </a></li>
<li><a href='../../01/03/0-7-habits-of-highly-effective-editting.html'> 高效文本编辑的七个习惯 </a></li>
<li><a href='../../../2013/12/11/0-ssh-remote-command-and-bash--c-string.html'> ssh执行远程命令和bash -c string的用法 </a></li>
<li><a href='../../../2013/11/07/0-programming-discovery.html'> 发现式编程 </a></li>
<li><a href='../../../2013/10/16/0-Interactive-Git-Add.html'> Interactive Git Add </a></li>
<li><a href='../../../2013/10/05/0-My-Own-Win32-Input-Method.html'> 自己写了一个输入法, Windows下的五笔 </a></li>
<li><a href='../../../2013/10/04/0-Win32-IME-Programming.html'> 我的Win32输入法编程心得 </a></li>
    </ul>

    <h2 class="sidebar-title">Archive</h2>
      <ul id="archives">
        <li><a href="/meta/Archive.html"> The complete archive </a></li>
      </ul>

  <!--
  <p>This is a paragraph of text that could go in the sidebar.</p>
  -->



</div></div>
<!-- End #sidebar -->
</div> <!-- End #bhj_article -->
<!-- {%/html-mode%} -->
<div id="postamble" class="status">
<!-- {%html-mode%} -->

<!-- {%/html-mode%} -->
</div>
</body>
</html>
