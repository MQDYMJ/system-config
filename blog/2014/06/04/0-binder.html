<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>binder</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Bao Haojun" />
<link rel="stylesheet" href="/css/default.css" type="text/css" />
<link rel="stylesheet" href="/css/adwaita.css" type="text/css" />
 <link rel="shortcut icon" href="/poison.png" type="image/png" />

    <script type="text/javascript" src="/js/jquery-1.7.1.min.js"></script>
    <script type="text/javascript">
        var BYB = {};
    </script>
    <script type="text/javascript">
        BYB.includeScript = function(file,callback){
            var _doc = document.getElementsByTagName('head')[0];
            var js = document.createElement('script');
            js.setAttribute('type', 'text/javascript');
            js.setAttribute('src', file);
            _doc.appendChild(js);

            if (!/*@cc_on!@*/0) { //if not IE
                //Firefox2、Firefox3、Safari3.1+、Opera9.6+ support js.onload
                js.onload = function () {
                    callback();
                }
            } else {
                //IE6、IE7 support js.onreadystatechange
                js.onreadystatechange = function () {
                    if (js.readyState == 'loaded' || js.readyState == 'complete') {
                        callback();
                    }
                }
            }
            return false;
        }
    </script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<div id="header">

  <h1 id="blog-title">

    <a href="http://baohaojun.github.io/blog/2011/12/23/index.html">包昊军的博客</a>

  </h1>
  <p id="description">What you don't know, won't hurt you.</p>

</div>
</div>
<div id='bhj_article'>
  <div id='bhj_leftpane'>
<div id="content">
<h1 class="title">binder</h1>
<p>
关于android下的binder IPC机制，网上已经有不少人分析过了，我总是嫌看起
来有些雾里看花，所以一咬牙自己看一遍吧。
</p>

<p>
首先，众所周知，IPC也即进程间通信，Inter Process Communication，它的形
式非常多种多样，比大家所熟知的那几种要多得多。在我看来，一些普遍不被认
为是IPC的机制，其实也可以认为是一种IPC，只不过可能原始一点，或者不够健
壮。
</p>

<p>
比如文件，两个进程完全可以通过IPC来进行通信嘛。进程A先往文件
/tmp/ab-ipc-file写一句话，“今晚打老虎”，然后sleep 10秒，进程B读此文件，
回复“好的”（把“好的”写到这个文件里去，覆盖了原来的内容），然后退出，然
后A醒来，重新读一下这个文件，获得了B传给它的信息。这样，它们就完成了一
次双向的IPC。
</p>

<p>
如果把进程间通信跟人类之间的沟通做一个类比的话，能更深的理解的确有很多
种机制均可以被打破常规的认为是IPC。沟通指的是信息的交换。而信息之所以
成为信息，是因为它可以被交换。可以被产生，被观察到，被消化掉。一个只被
产生出来，却从来没有被观察、被消化过的信息，是无法想像的。是不存在的。
比如一个女人，生了一个孩子，这件事本身好像不存在信息交换，孩子刚出生，
还不会跟妈妈交换信息嘛。可如果把范围划得广一点，就会发现在生孩子的过程
中，发生了很多信息交换，比如孩子它爸不停地在妈妈身边喊，“加油！加油！”。
等等等等。产房外焦急等待的长辈在不停地poll产房里的情况&#x2026;
</p>

<p>
可惜，把范围定得这么广的话我们就没法继续讨论下去了。所以我还是稍微收一
下。
</p>

<p>
Binder IPC机制跟其它常见的IPC机制一样，里面包含一些基本的元素：
</p>

<ul class="org-ul">
<li>参与者

<p>
您肯定听说过，signal也是一种IPC机制，一个基本上是单向的IPC机制。进程
A通过Kill命令/系统调用向进程B发一个信号，发送成功的话进程B可能会做出
一些动作来响应这个信号。这里的A和B就是参与者。但有时候进程A是不存在
的，比如当一个子进程退出的时候，父进程会收到一个sigchld的信号，但这
个信号是sigchld是谁发给父进程的呢？刚刚退出的子进程发的吗？可它没有
调过kill系统调用啊？答案是操作系统发的。所以进程间通讯真的不是那么绝
对的。
</p>

<p>
有时候进程间通讯可以是多方的，比如管道，大家可能会认为肯定只能是两方
参与，但其实弄4个进程出来通过一个管道通信也不是什么难事：
</p>

<pre class="example">
(echo hello; echo world) | ( dd bs=1 count=6 &amp;&amp; perl -npe '' )
</pre>

<p>
这些参与者参与到某种通信机制的方式随机制的不同而不同。比如signal机制，
我可以写这样的一段淘气的脚本，不停地随机地给系统中的进程发
sigkill（其中random是一个附助的生成随机整数的脚本）：
</p>

<div class="org-src-container">

<pre class="src src-sh"><span class="org-keyword">while</span> true; <span class="org-keyword">do </span><span class="org-builtin">kill</span> -9 $(<span class="org-sh-quoted-exec">random</span>); <span class="org-keyword">done</span>
</pre>
</div>

<p>
而上面那一段4方管道，显然需要有一个父进程(bash)帮助把这个管道创建出
来，把子进程创建出来，把输入输出配置好，再把相应的程序执行起来。
</p>

<p>
而Binder机制里，系统中所有的进程都可以参与其中，只要它们打开了
/dev/binder这个设备节点就可以。但其中有一个比较特殊一点，一般是第一
个打开/dev/binder节点并成为context manager的那个进程。
</p>
</li>
</ul>


<ul class="org-ul">
<li>角色

<p>
对，IPC中的各方是可以有不同的角色的。比如signal，有一个杀的，有一
个被杀的（kill:-)）。
</p>

<p>
而在Binder通讯机制里，有一个角色比较特殊，那就是context manager。
这个在kernel里是叫context manager，其实在user space里是叫service
manager。它允许系统里其它进程向它注册，比如这个进程向service
manager注册：“我的进程号是NNNN，我的名字叫media server”，以后别的
进程想进行多媒体相关的调用的话，就会向service manager查询，“media
server”的进程是哪个？
</p>

<p>
所以除了这个service manager之外，可以有很多其他的server，其实
service manager自身也是一个server，只不过是最特殊的那个罢了。其他
所有server都要向它来注册。
</p>
</li>
</ul>

<p>
大体看过Binder的一些特点之后，我们来场景分析一下Binder相关的一些细节。
您可以别看了，我写得太乱了&#x2026;
</p>


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Binder是一种面向对象的IPC机制</h2>
<div class="outline-text-2" id="text-1">
<p>
作为一种很牛逼的IPC机制，Binder想要作到让跨进程间通讯的远程调用，使用
起来感觉就像是进程内的函数调用一样。这个就有难度了。让我们来看看它是怎
么实现的。
</p>

<p>
首先，在远程server端会实现一套接口（Interface）。啊，算了，让我们先来
说一说如果没有binder机制，我们会怎么样来实现远程通讯吧。
</p>

<p>
我最熟悉的远程通讯就是tcp/ip了，这个通讯机制非常的通用，我们就不提那些
大家都熟知的http/ftp/ssh/telnet等协议了。
</p>

<p>
我曾经实现过一个手机测试命令工具箱，tcmd，采用了server/client机制实现。
首先一个server在一端监听某tcp端口，比如54321，客户端会给它发一个命令，
比如wifi-off，那么服务端读到这个命令之后，会以这样的代码去做相应的事情：
</p>

<div class="org-src-container">

<pre class="src src-c">    read(socket, cmd ...
    <span class="org-keyword">if</span> (strcmp(cmd, <span class="org-string">"wifi-on"</span>) == 0) {
        wifi_on();
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (strcmp(cmd, <span class="org-string">"wifi-off"</span>) == 0) {
        wifi_off();
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> ...

<span class="org-type">void</span> wifi_off()
{
    write 0 /sys/wifi/power
}
</pre>
</div>

<p>
也就是说，服务端系统会根据读到不同的命令去封装不同的函数。
</p>

<p>
比较妙的是，在客户端系统会去实现类似的逻辑，只不过是反过来，像一面镜子，它是往socket里写：
</p>

<div class="org-src-container">

<pre class="src src-c"><span class="org-type">void</span> <span class="org-function-name">client_wifi_on</span>()
{
    socket = open_socket(<span class="org-string">"localhost"</span>, 54321);
    write(socket, <span class="org-string">"wifi-on"</span>...
    close(socket);
}

<span class="org-type">void</span> <span class="org-variable-name">client_wifi_off</span>()
{
    socket = open_socket(<span class="org-string">"localhost"</span>, 54321);
    write(socket, <span class="org-string">"wifi-off"</span>...
    close(socket);
}
</pre>
</div>

<p>
这里你也看到了，我们可以像模板一样，生成很多的函数，每个函数做一个命令。
当然，没有什么能阴止你使用跟server端一样的名字，比如你的
<code>client_wifi_off</code> 完全也可以叫做 <code>wifi_off</code> ，这样做是有好处的，使两个本来非
常相关的函数变得更紧密了，但也有坏处，阅读代码的时候常常不知道该看哪个。
其实看多了很快会明白，所有的client端的实现都是个模板而已（boilerplate）。
</p>

<p>
然而我也非常喜欢这样的client实现：
</p>

<div class="org-src-container">

<pre class="src src-c"><span class="org-type">void</span> <span class="org-function-name">test_cmd</span>(<span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">cmd</span>)
{
    socket = open_socket(<span class="org-string">"localhost"</span>, 54321);
    write(socket, <span class="org-type">cmd</span>...
    <span class="org-variable-name">close</span>(socket);
}
</pre>
</div>

<p>
然后再用到 <code>client_wifi_on()</code> 的地方就代以 <code>test_cmd("wifi-on")</code> ，在用到
<code>wifi_off()</code> 的地方就代以 <code>test_cmd("wifi-off")</code> ，等等。这样做的好处是少了很
多函数和很多boilerplate代码（每个命令都要open/close socket！）。
</p>

<p>
当然，你也可以再在 <code>test_cmd</code> 的基础上把 <code>wifi_on/wifi_off</code> 给包装出来：
</p>

<div class="org-src-container">

<pre class="src src-c"><span class="org-type">void</span> <span class="org-function-name">wifi_on</span>()
{
    test_cmd(<span class="org-string">"wifi-on"</span>);
}
</pre>
</div>

<p>
太棒了，这就跟我们最终要看的binder机制有点像了。好，我们接着来看一下
binder机制是怎么做的。
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 接口、继承树</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Binder机制从最底层讲，只是数据的封装、传送、解析而已，所以它并不是只有
特定语言可以使用的，至少在Android系统里C/C++/Java都可以使用Binder。
</p>

<p>
但它最重要的优点之一，应该是它与面向对象编程之间比较友好的关系。我们就
先来看看Java里面是怎么使用Binder机制的。
</p>

<p>
题外话：我在用ajoke.el/beagrep/ctags/global等开源软件阅读源代码，以下
会有一些这些工具的运行结果。
</p>

<p>
以MountService.java为例，它有一个shutdown函数，我们看看它是哪个binder
的：
</p>

<div class="org-src-container">

<pre class="src src-compout">-*- mode: compilation; default-directory: "~/src/android/frameworks/base/services/java/com/android/server/" -*-
Compilation started at Sat Jun 21 21:24:30

ajoke-get-hierarchy.pl com.android.server.MountService -m shutdown
<span class="org-function-name">make</span>: Entering directory `<span class="org-function-name">/home/bhj/src/android</span>'

=&gt; class com.android.server.MountService<span class="org-underline"> at </span><span class="org-underline"><span class="org-compilation-error">frameworks/base/services/java/com/android/server/MountService.java</span></span><span class="org-underline"> line </span><span class="org-underline"><span class="org-compilation-line-number">103</span></span><span class="org-underline">.</span>
      public void shutdown(final IMountShutdownObserver observer){
   =&gt; class android.os.storage.IMountService.Stub<span class="org-underline"> at </span><span class="org-underline"><span class="org-compilation-error">frameworks/base/core/java/android/os/storage/IMountService.java</span></span><span class="org-underline"> line </span><span class="org-underline"><span class="org-compilation-line-number">37</span></span><span class="org-underline">.</span>
      =&gt; class android.os.Binder<span class="org-underline"> at </span><span class="org-underline"><span class="org-compilation-error">frameworks/base/core/java/android/os/Binder.java</span></span><span class="org-underline"> line </span><span class="org-underline"><span class="org-compilation-line-number">43</span></span><span class="org-underline">.</span>
         =&gt; interface android.os.IBinder<span class="org-underline"> at </span><span class="org-underline"><span class="org-compilation-error">frameworks/base/core/java/android/os/IBinder.java</span></span><span class="org-underline"> line </span><span class="org-underline"><span class="org-compilation-line-number">86</span></span><span class="org-underline">.</span>
         =&gt; class java.lang.Object<span class="org-underline"> at </span><span class="org-underline"><span class="org-compilation-error">libcore/luni/src/main/java/java/lang/Object.java</span></span><span class="org-underline"> line </span><span class="org-underline"><span class="org-compilation-line-number">131</span></span><span class="org-underline">.</span>
      =&gt; interface android.os.storage.IMountService<span class="org-underline"> at </span><span class="org-underline"><span class="org-compilation-error">frameworks/base/core/java/android/os/storage/IMountService.java</span></span><span class="org-underline"> line </span><span class="org-underline"><span class="org-compilation-line-number">35</span></span><span class="org-underline">.</span>
            public void shutdown(IMountShutdownObserver observer)throws RemoteException;
         =&gt; interface android.os.IInterface<span class="org-underline"> at </span><span class="org-underline"><span class="org-compilation-error">frameworks/base/core/java/android/os/IInterface.java</span></span><span class="org-underline"> line </span><span class="org-underline"><span class="org-compilation-line-number">23</span></span><span class="org-underline">.</span>
   =&gt; interface com.android.server.INativeDaemonConnectorCallbacks<span class="org-underline"> at </span><span class="org-underline"><span class="org-compilation-error">frameworks/base/services/java/com/android/server/INativeDaemonConnectorCallbacks.java</span></span><span class="org-underline"> line </span><span class="org-underline"><span class="org-compilation-line-number">20</span></span><span class="org-underline">.</span>
   =&gt; interface com.android.server.Watchdog.Monitor<span class="org-underline"> at </span><span class="org-underline"><span class="org-compilation-error">frameworks/base/services/java/com/android/server/Watchdog.java</span></span><span class="org-underline"> line </span><span class="org-underline"><span class="org-compilation-line-number">170</span></span><span class="org-underline">.</span>

Compilation <span class="org-compilation-info">finished</span> at Sat Jun 21 21:24:31
</pre>
</div>

<p>
哦，对了，你看到的上面这段代码就是它在我的Emacs编辑器里显示的样子，为
了让它正确的代码高亮，我还颇费了一番功夫呢！首先，上面的代码是
compilation-mode，这个在Emacs里是一种read-only的模式，然而org-html-fontify-code的代码是这样写的：
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(setq code (<span class="org-keyword">with-temp-buffer</span>
             <span class="org-comment-delimiter">;; </span><span class="org-comment">Switch to language-specific mode.</span>
             (funcall lang-mode)
             (insert code)
             <span class="org-comment-delimiter">;; </span><span class="org-comment">Fontify buffer.</span>
             (font-lock-fontify-buffer)
</pre>
</div>

<p>
可见，它先设置了mode <code>(funcall lang-mode)</code> 为compilation-mode，然后再
插入code <code>(insert code)</code> ，这就出问题了，compilation-mode是只读的，不
允许插入。为了绕过这个问题，我定义了一种新的compout-mode，很简单，就是可写的compilation-mode：
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">compout-mode</span> ()
  <span class="org-doc">"compilation mode, which is not buffer readonly for org export"</span>
  (interactive)
  (compilation-mode)
  (setq buffer-read-only nil))
</pre>
</div>

<p>
另外，做成这样之后，还是有问题，上面的代码输出到html之后没有全部高亮，
经查，应该是compilation-mode对temp-buffer有歧视，在temp-buffer里不会最
努力地高亮（见上面的 <code>with-temp-buffer</code> ）。
</p>

<p>
<code>with-temp-buffer</code> 的定义是这样的：
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span class="org-keyword">defmacro</span> <span class="org-function-name">with-temp-buffer</span> (<span class="org-type">&amp;rest</span> body)
  <span class="org-doc">"Create a temporary buffer, and evaluate BODY there like `</span><span class="org-doc"><span class="org-constant">progn</span></span><span class="org-doc">'.</span>
<span class="org-doc">See also `</span><span class="org-doc"><span class="org-constant">with-temp-file</span></span><span class="org-doc">' and `</span><span class="org-doc"><span class="org-constant">with-output-to-string</span></span><span class="org-doc">'."</span>
  (<span class="org-keyword">declare</span> (indent 0) (debug t))
  (<span class="org-keyword">let</span> ((temp-buffer (make-symbol <span class="org-string">"temp-buffer"</span>)))
    `(<span class="org-keyword">let</span> ((,temp-buffer (generate-new-buffer <span class="org-string">" *temp*"</span>)))
       <span class="org-comment-delimiter">;; </span><span class="org-comment">FIXME: kill-buffer can change current-buffer in some odd cases.</span>
       (<span class="org-keyword">with-current-buffer</span> ,temp-buffer
         (<span class="org-keyword">unwind-protect</span>
             (<span class="org-keyword">progn</span> ,@body)
           (and (buffer-name ,temp-buffer)
                (kill-buffer ,temp-buffer)))))))
</pre>
</div>

<p>
问题出在 <code>(generate-new-buffer " *temp*")</code> 这个语句，buffer名字不能叫
<code>*temp*</code> ，所以我定义了一个advice来绕开这个问题：
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span class="org-keyword">defun</span> <span class="org-function-name">org-html-fontify-code-compout</span> (orig-fun <span class="org-type">&amp;rest</span> args)
  <span class="org-doc">"Make compilation output htmlized."</span>
  (<span class="org-keyword">if</span> (string= (cadr args) <span class="org-string">"compout"</span>)
      (flet ((generate-new-buffer (name)
                                  (<span class="org-keyword">when</span> (string= name <span class="org-string">" *temp*"</span>)
                                    (setq name <span class="org-string">"temp-ox"</span>))
                                  (get-buffer-create (generate-new-buffer-name name))))
        (apply orig-fun args))
    (apply orig-fun args)))

(eval-after-load 'ox-html
  '(advice-add 'org-html-fontify-code <span class="org-builtin">:around</span> #'org-html-fontify-code-compout))
</pre>
</div>

<p>
当第二个参数 <code>(cadr args)</code> 为 "compout" 时，让generate-new-buffer的定
义发生变化，如果其参数名为 <code>*temp*</code> ，则改成 temp-ox 。
</p>

<p>
好了，从上面我用 ajoke-get-hierarchy 搞出来的继承树来看， shutdown 函数最早是在IMountService里定义的：
</p>

<div class="org-src-container">

<pre class="src src-compout">=&gt; interface android.os.storage.IMountService<span class="org-underline"> at </span><span class="org-underline"><span class="org-compilation-error">frameworks/base/core/java/android/os/storage/IMountService.java</span></span><span class="org-underline"> line </span><span class="org-underline"><span class="org-compilation-line-number">35</span></span><span class="org-underline">.</span>
      public void shutdown(IMountShutdownObserver observer)throws RemoteException;
</pre>
</div>

<div class="org-src-container">

<pre class="src src-grepout">-*- mode: grep; default-directory: "~/src/android/frameworks/base/core/java/android/os/" -*-
Grep started at Fri Jul 25 10:02:01

grep-func-call -e "IMountService.*asInterface" --nc -a -v /tests/


Entering directory `<span class="org-function-name">/home/bhj/src/android/frameworks/base/core/java/android/app</span>'
<span class="org-underline"><span class="org-compilation-info">ContextImpl.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">2172</span></span><span class="org-underline">:</span> &lt;=     private File[] ensureDirsExistOrFilter(File[] dirs) {
<span class="org-underline"><span class="org-compilation-info">ContextImpl.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">2182</span></span><span class="org-underline">:</span> =&gt;                         final IMountService mount = IMountService.Stub.asInterface(
Entering directory `<span class="org-function-name">/home/bhj/src/android/frameworks/base/core/java/android/os</span>'
<span class="org-underline"><span class="org-compilation-info">Environment.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">74</span></span><span class="org-underline">:</span> &lt;=     private static StorageVolume getPrimaryVolume() {
<span class="org-underline"><span class="org-compilation-info">Environment.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">83</span></span><span class="org-underline">:</span> =&gt;                         IMountService mountService = IMountService.Stub.asInterface(ServiceManager
<span class="org-underline"><span class="org-compilation-info">Environment.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">707</span></span><span class="org-underline">:</span> &lt;=     public static String getStorageState(File path) {
<span class="org-underline"><span class="org-compilation-info">Environment.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">717</span></span><span class="org-underline">:</span> =&gt;             final IMountService mountService = IMountService.Stub.asInterface(
Entering directory `<span class="org-function-name">/home/bhj/src/android/frameworks/base/core/java/android/os/storage</span>'
<span class="org-underline"><span class="org-compilation-info">IMountService.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">836</span></span><span class="org-underline">:</span> &lt;&gt;         public static IMountService asInterface(IBinder obj) {
<span class="org-underline"><span class="org-compilation-info">IMountService.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">857</span></span><span class="org-underline">:</span> &lt;=         public boolean onTransact(int code, Parcel data, Parcel reply,
<span class="org-underline"><span class="org-compilation-info">IMountService.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">867</span></span><span class="org-underline">:</span> =&gt;                     listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
<span class="org-underline"><span class="org-compilation-info">IMountService.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">875</span></span><span class="org-underline">:</span> =&gt;                     listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
Entering directory `<span class="org-function-name">/home/bhj/src/android/frameworks/base/core/java/android/os/storage</span>'
<span class="org-underline"><span class="org-compilation-info">StorageManager.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">315</span></span><span class="org-underline">:</span> &lt;=     public StorageManager(ContentResolver resolver, Looper tgtLooper) throws RemoteException {
<span class="org-underline"><span class="org-compilation-info">StorageManager.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">318</span></span><span class="org-underline">:</span> =&gt;         mMountService = IMountService.Stub.asInterface(ServiceManager.getService("mount"));
Entering directory `<span class="org-function-name">/home/bhj/src/android/frameworks/base/core/java/com/android/internal/content</span>'
<span class="org-underline"><span class="org-compilation-info">PackageHelper.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">61</span></span><span class="org-underline">:</span> &lt;=     public static IMountService getMountService() throws RemoteException {
<span class="org-underline"><span class="org-compilation-info">PackageHelper.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">64</span></span><span class="org-underline">:</span> =&gt;             return IMountService.Stub.asInterface(service);
Entering directory `<span class="org-function-name">/home/bhj/src/android/frameworks/base/core/java/com/android/internal/os/storage</span>'
<span class="org-underline"><span class="org-compilation-info">ExternalStorageFormatter.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">319</span></span><span class="org-underline">:</span> &lt;=     IMountService getMountService() {
<span class="org-underline"><span class="org-compilation-info">ExternalStorageFormatter.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">323</span></span><span class="org-underline">:</span> =&gt;                 mMountService = IMountService.Stub.asInterface(service);
Entering directory `<span class="org-function-name">/home/bhj/src/android/frameworks/base/core/java/com/android/internal/widget</span>'
<span class="org-underline"><span class="org-compilation-info">LockPatternUtils.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">632</span></span><span class="org-underline">:</span> &lt;=     private void updateEncryptionPassword(String password) {
<span class="org-underline"><span class="org-compilation-info">LockPatternUtils.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">645</span></span><span class="org-underline">:</span> =&gt;         IMountService mountService = IMountService.Stub.asInterface(service);
Entering directory `<span class="org-function-name">/home/bhj/src/android/frameworks/base/packages/BackupRestoreConfirmation/src/com/android/backupconfirm</span>'
<span class="org-underline"><span class="org-compilation-info">BackupRestoreConfirmation.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">131</span></span><span class="org-underline">:</span> &lt;=     public void onCreate(Bundle icicle) {
<span class="org-underline"><span class="org-compilation-info">BackupRestoreConfirmation.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">159</span></span><span class="org-underline">:</span> =&gt;         mMountService = IMountService.Stub.asInterface(ServiceManager.getService("mount"));
Entering directory `<span class="org-function-name">/home/bhj/src/android/frameworks/base/packages/SystemUI/src/com/android/systemui/usb</span>'
<span class="org-underline"><span class="org-compilation-info">UsbStorageActivity.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">202</span></span><span class="org-underline">:</span> &lt;=     private IMountService getMountService() {
<span class="org-underline"><span class="org-compilation-info">UsbStorageActivity.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">205</span></span><span class="org-underline">:</span> =&gt;             return IMountService.Stub.asInterface(service);
Entering directory `<span class="org-function-name">/home/bhj/src/android/frameworks/base/services/java/com/android/server</span>'
<span class="org-underline"><span class="org-compilation-info">BackupManagerService.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">773</span></span><span class="org-underline">:</span> &lt;=     public BackupManagerService(Context context) {
<span class="org-underline"><span class="org-compilation-info">BackupManagerService.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">781</span></span><span class="org-underline">:</span> =&gt;         mMountService = IMountService.Stub.asInterface(ServiceManager.getService("mount"));
Entering directory `<span class="org-function-name">/home/bhj/src/android/frameworks/base/services/java/com/android/server/power</span>'
<span class="org-underline"><span class="org-compilation-info">ShutdownThread.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">295</span></span><span class="org-underline">:</span> &lt;=     public void run() {
<span class="org-underline"><span class="org-compilation-info">ShutdownThread.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">374</span></span><span class="org-underline">:</span> =&gt;                 final IMountService mount = IMountService.Stub.asInterface(
Entering directory `<span class="org-function-name">/home/bhj/src/android/packages/apps/SettingsSmartisan/src/com/android/settings</span>'
<span class="org-underline"><span class="org-compilation-info">CryptKeeperConfirm.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">41</span></span><span class="org-underline">:</span> &lt;=         public void onCreate(Bundle savedInstanceState) {
<span class="org-underline"><span class="org-compilation-info">CryptKeeperConfirm.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">72</span></span><span class="org-underline">:</span> =&gt;                     IMountService mountService = IMountService.Stub.asInterface(service);
Entering directory `<span class="org-function-name">/home/bhj/src/android/packages/apps/SettingsSmartisan/src/com/android/settings</span>'
<span class="org-underline"><span class="org-compilation-info">CryptKeeper.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">614</span></span><span class="org-underline">:</span> &lt;=     private IMountService getMountService() {
<span class="org-underline"><span class="org-compilation-info">CryptKeeper.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">617</span></span><span class="org-underline">:</span> =&gt;             return IMountService.Stub.asInterface(service);
Entering directory `<span class="org-function-name">/home/bhj/src/android/packages/apps/SettingsSmartisan/src/com/android/settings/deviceinfo</span>'
<span class="org-underline"><span class="org-compilation-info">Memory.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">214</span></span><span class="org-underline">:</span> &lt;=     private synchronized IMountService getMountService() {
<span class="org-underline"><span class="org-compilation-info">Memory.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">218</span></span><span class="org-underline">:</span> =&gt;                mMountService = IMountService.Stub.asInterface(service);
Entering directory `<span class="org-function-name">/home/bhj/src/android/packages/apps/Settings/src/com/android/settings</span>'
<span class="org-underline"><span class="org-compilation-info">CryptKeeperConfirm.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">41</span></span><span class="org-underline">:</span> &lt;=         public void onCreate(Bundle savedInstanceState) {
<span class="org-underline"><span class="org-compilation-info">CryptKeeperConfirm.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">72</span></span><span class="org-underline">:</span> =&gt;                     IMountService mountService = IMountService.Stub.asInterface(service);
Entering directory `<span class="org-function-name">/home/bhj/src/android/packages/apps/Settings/src/com/android/settings</span>'
<span class="org-underline"><span class="org-compilation-info">CryptKeeper.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">614</span></span><span class="org-underline">:</span> &lt;=     private IMountService getMountService() {
<span class="org-underline"><span class="org-compilation-info">CryptKeeper.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">617</span></span><span class="org-underline">:</span> =&gt;             return IMountService.Stub.asInterface(service);
Entering directory `<span class="org-function-name">/home/bhj/src/android/packages/apps/Settings/src/com/android/settings/deviceinfo</span>'
<span class="org-underline"><span class="org-compilation-info">Memory.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">203</span></span><span class="org-underline">:</span> &lt;=     private synchronized IMountService getMountService() {
<span class="org-underline"><span class="org-compilation-info">Memory.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">207</span></span><span class="org-underline">:</span> =&gt;                mMountService = IMountService.Stub.asInterface(service);
Entering directory `<span class="org-function-name">/home/bhj/src/android/packages/apps/SystemUISmartisan/src/com/smartisanos/systemui/usb</span>'
<span class="org-underline"><span class="org-compilation-info">UsbStorageActivity.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">204</span></span><span class="org-underline">:</span> &lt;=     private IMountService getMountService() {
<span class="org-underline"><span class="org-compilation-info">UsbStorageActivity.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">207</span></span><span class="org-underline">:</span> =&gt;             return IMountService.Stub.asInterface(service);
Entering directory `<span class="org-function-name">/home/bhj/src/android/vendor/qcom/proprietary/QualcommSettings/src/com/qualcomm/qualcommsettings</span>'
<span class="org-underline"><span class="org-compilation-info">QualcommSettings.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">687</span></span><span class="org-underline">:</span> &lt;=    private void updateUsbMassStorageStatus() {
<span class="org-underline"><span class="org-compilation-info">QualcommSettings.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">689</span></span><span class="org-underline">:</span> =&gt;         IMountService mountService = IMountService.Stub.asInterface(ServiceManager

Grep finished (<span class="org-compilation-info">matches found</span>) at Fri Jul 25 10:02:02
</pre>
</div>

<p>
啊，还是看一看shutdown在I?MountService里都有谁定义的：
</p>

<div class="org-src-container">

<pre class="src src-grepout">-*- mode: grep; default-directory: "~/src/android/frameworks/base/core/java/android/os/storage/" -*-
Grep started at Fri Jul 25 10:17:13

grep-gtags -e "shutdown" -p MountServ
Found total 4/1728 definitions: Entering directory `<span class="org-function-name">/home/bhj/src/android</span>'
<span class="org-underline"><span class="org-compilation-info">frameworks/base/core/java/android/os/storage/IMountService.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">451</span></span><span class="org-underline">:</span> method: &lt;android.os.storage.IMountService.Stub.Proxy.shutdown&gt; : public void shutdown(IMountShutdownObserver observer) throws RemoteException {
<span class="org-underline"><span class="org-compilation-info">frameworks/base/core/java/android/os/storage/IMountService.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">1310</span></span><span class="org-underline">:</span> method: &lt;android.os.storage.IMountService.shutdown&gt; : public void shutdown(IMountShutdownObserver observer) throws RemoteException;
<span class="org-underline"><span class="org-compilation-info">frameworks/base/services/java/com/android/server/MountService.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">1423</span></span><span class="org-underline">:</span> method: &lt;com.android.server.MountService.shutdown&gt; : public void shutdown(final IMountShutdownObserver observer) {
<span class="org-underline"><span class="org-compilation-info">frameworks/base/libs/storage/IMountService.cpp</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">403</span></span><span class="org-underline">:</span> function: &lt;android::BpMountService::shutdown&gt; : void shutdown(const sp&lt;IMountShutdownObserver&gt;&amp; observer) {
    403:     void shutdown(const sp&lt;IMountShutdownObserver&gt;&amp; observer)
    404:     {
    405:         Parcel data, reply;
    406:         data.writeInterfaceToken(IMountService::getInterfaceDescriptor());
    407:         data.writeStrongBinder(observer-&gt;asBinder());
    408:         if (remote()-&gt;transact(TRANSACTION_shutdown, data, &amp;reply) != NO_ERROR) {
    409:             ALOGD("shutdown could not contact remote\n");
    410:             return;
    411:         }
    412:         int32_t err = reply.readExceptionCode();
    413:         if (err &lt; 0) {
    ...

Grep finished (<span class="org-compilation-info">matches found</span>) at Fri Jul 25 10:17:14
</pre>
</div>

<p>
可见有一个interface里声明了这个函数的原型android.os.storage.IMountService.shutdown，然后有一个stub.proxy的实现：
android.os.storage.IMountService.Stub.Proxy.shutdown，但它的实现只是进行了binder的系统调用而已：
</p>

<div class="org-src-container">

<pre class="src src-java"><span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">shutdown</span>(<span class="org-type">IMountShutdownObserver</span> <span class="org-variable-name">observer</span>)
        <span class="org-keyword">throws</span> <span class="org-type">RemoteException</span> {
    <span class="org-type">Parcel</span> <span class="org-variable-name">_data</span> = Parcel.obtain();
    <span class="org-type">Parcel</span> <span class="org-variable-name">_reply</span> = Parcel.obtain();
    <span class="org-keyword">try</span> {
        _data.writeInterfaceToken(DESCRIPTOR);
        _data.writeStrongBinder((observer != <span class="org-constant">null</span> ? observer.asBinder() : <span class="org-constant">null</span>));
        mRemote.transact(<span class="org-constant">Stub</span>.TRANSACTION_shutdown, _data, _reply, 0);
        _reply.readException();
    } <span class="org-keyword">finally</span> {
        _reply.recycle();
        _data.recycle();
    }
}
</pre>
</div>

<p>
然后 android.os.storage.IMountService.Stub 实现了这个Interface，但 android.server.MountService 又扩展了这个 Stub:
</p>
<div class="org-src-container">

<pre class="src src-java">    <span class="org-keyword">public</span> <span class="org-keyword">static</span> <span class="org-keyword">abstract</span> <span class="org-keyword">class</span> <span class="org-type">Stub</span> <span class="org-keyword">extends</span> <span class="org-type">Binder</span> <span class="org-keyword">implements</span> <span class="org-type">IMountService</span> {}
<span class="org-keyword">class</span> <span class="org-type">MountService</span> <span class="org-keyword">extends</span> <span class="org-constant">IMountService</span>.<span class="org-type">Stub</span>
        <span class="org-keyword">implements</span> <span class="org-type">INativeDaemonConnectorCallbacks</span>, <span class="org-constant">Watchdog</span>.<span class="org-type">Monitor</span> {}
</pre>
</div>

<p>
然后注意上面proxy里的实现，发了一个 TRANSACTION_shutdown 的transact，先搜一下 TRANSACTION_shutdown 吧：
</p>
<div class="org-src-container">

<pre class="src src-grepout">-*- mode: grep; default-directory: "~/system-config/doc/baohaojun/blog/2014/06/04/" -*-
Grep started at Fri Jul 25 10:27:07

beagrep -e "TRANSACTION_shutdown" -d ~/src/android
<span class="org-underline"><span class="org-compilation-info">/home/bhj/src/android/frameworks/base/core/java/android/os/storage/IMountService.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">458</span></span><span class="org-underline">:</span>                    mRemote.transact(Stub.TRANSACTION_shutdown, _data, _reply, 0);
<span class="org-underline"><span class="org-compilation-info">/home/bhj/src/android/frameworks/base/core/java/android/os/storage/IMountService.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">800</span></span><span class="org-underline">:</span>        static final int TRANSACTION_shutdown = IBinder.FIRST_CALL_TRANSACTION + 19;
<span class="org-underline"><span class="org-compilation-info">/home/bhj/src/android/frameworks/base/core/java/android/os/storage/IMountService.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">1048</span></span><span class="org-underline">:</span>                case TRANSACTION_shutdown: {
<span class="org-underline"><span class="org-compilation-info">/home/bhj/src/android/frameworks/base/libs/storage/IMountService.cpp</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">44</span></span><span class="org-underline">:</span>    TRANSACTION_shutdown,
<span class="org-underline"><span class="org-compilation-info">/home/bhj/src/android/frameworks/base/libs/storage/IMountService.cpp</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">408</span></span><span class="org-underline">:</span>        if (remote()-&gt;transact(TRANSACTION_shutdown, data, &amp;reply) != NO_ERROR) {

Grep finished (<span class="org-compilation-info">matches found</span>) at Fri Jul 25 10:27:07
</pre>
</div>

<p>
.cpp的那个我们就不看了，完全在拷贝.java这边的代码。当然也可能是.java在拷贝.cpp的。
</p>

<p>
处理的地方是在IMountService.java:1048:行，这个是Stub里定义的，也就是说
Stub只实现了针对每个 TRANSACTION_xxx 应该怎么调用由子类(MountService)
实现的函数，它自己是一个也没有实现过的。
</p>

<p>
再看一下Stub自己一共定义了多少个函数吧：
</p>
<div class="org-src-container">

<pre class="src src-grepout">-*- mode: grep; default-directory: "~/src/android/frameworks/base/core/java/android/os/storage/" -*-
Grep started at Fri Jul 25 14:44:33

grep-gtags -e "android.os.storage.IMountService.Stub..*" -t method |grep -v Proxy
Found total 42/38 definitions: Entering directory `<span class="org-function-name">/home/bhj/src/android</span>'
<span class="org-underline"><span class="org-compilation-info">frameworks/base/core/java/android/os/storage/IMountService.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">836</span></span><span class="org-underline">:</span> method: &lt;android-os-storage-IMountService-Stub-asInterface&gt; : public static IMountService asInterface(IBinder obj) {
<span class="org-underline"><span class="org-compilation-info">frameworks/base/core/java/android/os/storage/IMountService.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">848</span></span><span class="org-underline">:</span> method: &lt;android-os-storage-IMountService-Stub-Stub&gt; : public Stub() {
<span class="org-underline"><span class="org-compilation-info">frameworks/base/core/java/android/os/storage/IMountService.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">852</span></span><span class="org-underline">:</span> method: &lt;android-os-storage-IMountService-Stub-asBinder&gt; : public IBinder asBinder() {
<span class="org-underline"><span class="org-compilation-info">frameworks/base/core/java/android/os/storage/IMountService.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">857</span></span><span class="org-underline">:</span> method: &lt;android-os-storage-IMountService-Stub-onTransact&gt; : public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {

Grep finished (<span class="org-compilation-info">matches found</span>) at Fri Jul 25 14:44:36
</pre>
</div>

<p>
其中asInterface的定义：
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-keyword">public</span> <span class="org-keyword">static</span> <span class="org-type">IMountService</span> <span class="org-function-name">asInterface</span>(<span class="org-type">IBinder</span> <span class="org-variable-name">obj</span>) {
    <span class="org-keyword">if</span> (obj == <span class="org-constant">null</span>) {
        <span class="org-keyword">return</span> <span class="org-constant">null</span>;
    }
    <span class="org-type">IInterface</span> <span class="org-variable-name">iin</span> = obj.queryLocalInterface(DESCRIPTOR);
    <span class="org-keyword">if</span> (iin != <span class="org-constant">null</span> &amp;&amp; iin <span class="org-keyword">instanceof</span> IMountService) {
        <span class="org-keyword">return</span> (<span class="org-type">IMountService</span>) iin;
    }
    <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-constant">IMountService</span>.<span class="org-constant">Stub</span>.<span class="org-type">Proxy</span>(obj);
}
</pre>
</div>

<p>
会传进来一个obj，这个obj会被调到queryLocalInterface，最后调到的应该是：
</p>

<div class="org-src-container">

<pre class="src src-java"><span class="org-keyword">public</span> <span class="org-type">IInterface</span> <span class="org-function-name">queryLocalInterface</span>(<span class="org-type">String</span> <span class="org-variable-name">descriptor</span>) {
    <span class="org-keyword">if</span> (mDescriptor.equals(descriptor)) {
        <span class="org-keyword">return</span> mOwner;
    }
    <span class="org-keyword">return</span> <span class="org-constant">null</span>;
}
</pre>
</div>
<p>
这个在Binder.java里。mOwner被设值的地方：
</p>

<div class="org-src-container">

<pre class="src src-java"><span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">attachInterface</span>(<span class="org-type">IInterface</span> <span class="org-variable-name">owner</span>, <span class="org-type">String</span> <span class="org-variable-name">descriptor</span>) {
    mOwner = owner;
    mDescriptor = descriptor;
}
</pre>
</div>

<p>
attachInterface 是在MountService的Stub里调用的：
</p>

<div class="org-src-container">

<pre class="src src-grepout">-*- mode: grep; default-directory: "~/src/android/frameworks/base/core/java/android/os/storage/" -*-
Grep started at Sat Jul 26 22:04:08

grep-gtags -e "Stub" -d ~/src/android -o
Found total 2/8 definitions: Entering directory `<span class="org-function-name">/home/bhj/src/android</span>'
<span class="org-underline"><span class="org-compilation-info">frameworks/base/core/java/android/os/storage/IMountService.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">37</span></span><span class="org-underline">:</span> class: &lt;android.os.storage.IMountService.Stub&gt; : public static abstract class Stub extends Binder implements IMountService {
    37:     public static abstract class Stub extends Binder implements IMountService {
<span class="org-underline"><span class="org-compilation-info">frameworks/base/core/java/android/os/storage/IMountService.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">830</span></span><span class="org-underline">:</span> method: &lt;android.os.storage.IMountService.Stub.Stub&gt; : public Stub() {
    830:         public Stub() {
    831:             attachInterface(this, DESCRIPTOR);
    832:         }
    833:

Grep finished (<span class="org-compilation-info">matches found</span>) at Sat Jul 26 22:04:09
</pre>
</div>

<p>
再看一下这个Stub的继承树：
</p>

<div class="org-src-container">

<pre class="src src-compout">-*- mode: compilation; default-directory: "~/src/android/frameworks/base/core/java/android/os/storage/" -*-
Compilation started at Sat Jul 26 22:06:28

ajoke-get-hierarchy.pl android.os.storage.IMountService.Stub -m Stub
<span class="org-function-name">make</span>: Entering directory `<span class="org-function-name">/home/bhj/src/android</span>'

=&gt; class android.os.storage.IMountService.Stub<span class="org-underline"> at </span><span class="org-underline"><span class="org-compilation-error">frameworks/base/core/java/android/os/storage/IMountService.java</span></span><span class="org-underline"> line </span><span class="org-underline"><span class="org-compilation-line-number">37</span></span><span class="org-underline">.</span>
      public Stub(){
   =&gt; class android.os.Binder<span class="org-underline"> at </span><span class="org-underline"><span class="org-compilation-error">frameworks/base/core/java/android/os/Binder.java</span></span><span class="org-underline"> line </span><span class="org-underline"><span class="org-compilation-line-number">43</span></span><span class="org-underline">.</span>
      =&gt; interface android.os.IBinder<span class="org-underline"> at </span><span class="org-underline"><span class="org-compilation-error">frameworks/base/core/java/android/os/IBinder.java</span></span><span class="org-underline"> line </span><span class="org-underline"><span class="org-compilation-line-number">86</span></span><span class="org-underline">.</span>
      =&gt; class java.lang.Object<span class="org-underline"> at </span><span class="org-underline"><span class="org-compilation-error">libcore/luni/src/main/java/java/lang/Object.java</span></span><span class="org-underline"> line </span><span class="org-underline"><span class="org-compilation-line-number">131</span></span><span class="org-underline">.</span>
   =&gt; interface android.os.storage.IMountService<span class="org-underline"> at </span><span class="org-underline"><span class="org-compilation-error">frameworks/base/core/java/android/os/storage/IMountService.java</span></span><span class="org-underline"> line </span><span class="org-underline"><span class="org-compilation-line-number">35</span></span><span class="org-underline">.</span>
         public static abstract class Stub extends Binder implements IMountService{
      =&gt; interface android.os.IInterface<span class="org-underline"> at </span><span class="org-underline"><span class="org-compilation-error">frameworks/base/core/java/android/os/IInterface.java</span></span><span class="org-underline"> line </span><span class="org-underline"><span class="org-compilation-line-number">23</span></span><span class="org-underline">.</span>

Compilation <span class="org-compilation-info">finished</span> at Sat Jul 26 22:06:30
</pre>
</div>

<p>
这时候就非常清楚的可以看到了，C++里的RTTI（Run Time Type Infomation）
的一种机制，在这个java代码里用obj+descriptor的方式重新实现了一遍。为什
么不直接用isinstanceof呢？有点想不明白。可能是这些源码的作者想尽量保持
java与c++接口名字上的一致性？
</p>

<p>
回到IMountService，asInterface用到的地方：
</p>

<div class="org-src-container">

<pre class="src src-grepout">asIt-*- mode: grep; default-directory: "~/src/android/frameworks/base/core/java/android/os/storage/" -*-
Grep started at Fri Jul 25 14:53:30

grep-func-call -e "IMountService.*asInterface" --nc -a -v /tests/


Entering directory `<span class="org-function-name">/home/bhj/src/android/frameworks/base/core/java/android/app</span>'
<span class="org-underline"><span class="org-compilation-info">ContextImpl.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">2172</span></span><span class="org-underline">:</span> &lt;=     private File[] ensureDirsExistOrFilter(File[] dirs) {
<span class="org-underline"><span class="org-compilation-info">ContextImpl.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">2182</span></span><span class="org-underline">:</span> =&gt;                         final IMountService mount = IMountService.Stub.asInterface(
Entering directory `<span class="org-function-name">/home/bhj/src/android/frameworks/base/core/java/android/os</span>'
<span class="org-underline"><span class="org-compilation-info">Environment.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">74</span></span><span class="org-underline">:</span> &lt;=     private static StorageVolume getPrimaryVolume() {
<span class="org-underline"><span class="org-compilation-info">Environment.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">83</span></span><span class="org-underline">:</span> =&gt;                         IMountService mountService = IMountService.Stub.asInterface(ServiceManager
<span class="org-underline"><span class="org-compilation-info">Environment.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">707</span></span><span class="org-underline">:</span> &lt;=     public static String getStorageState(File path) {
<span class="org-underline"><span class="org-compilation-info">Environment.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">717</span></span><span class="org-underline">:</span> =&gt;             final IMountService mountService = IMountService.Stub.asInterface(
Entering directory `<span class="org-function-name">/home/bhj/src/android/frameworks/base/core/java/android/os/storage</span>'
<span class="org-underline"><span class="org-compilation-info">IMountService.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">836</span></span><span class="org-underline">:</span> &lt;&gt;         public static IMountService asInterface(IBinder obj) {
<span class="org-underline"><span class="org-compilation-info">IMountService.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">857</span></span><span class="org-underline">:</span> &lt;=         public boolean onTransact(int code, Parcel data, Parcel reply,
<span class="org-underline"><span class="org-compilation-info">IMountService.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">867</span></span><span class="org-underline">:</span> =&gt;                     listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
<span class="org-underline"><span class="org-compilation-info">IMountService.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">875</span></span><span class="org-underline">:</span> =&gt;                     listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
Entering directory `<span class="org-function-name">/home/bhj/src/android/frameworks/base/core/java/android/os/storage</span>'
<span class="org-underline"><span class="org-compilation-info">StorageManager.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">315</span></span><span class="org-underline">:</span> &lt;=     public StorageManager(ContentResolver resolver, Looper tgtLooper) throws RemoteException {
<span class="org-underline"><span class="org-compilation-info">StorageManager.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">318</span></span><span class="org-underline">:</span> =&gt;         mMountService = IMountService.Stub.asInterface(ServiceManager.getService("mount"));
Entering directory `<span class="org-function-name">/home/bhj/src/android/frameworks/base/core/java/com/android/internal/content</span>'
<span class="org-underline"><span class="org-compilation-info">PackageHelper.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">61</span></span><span class="org-underline">:</span> &lt;=     public static IMountService getMountService() throws RemoteException {
<span class="org-underline"><span class="org-compilation-info">PackageHelper.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">64</span></span><span class="org-underline">:</span> =&gt;             return IMountService.Stub.asInterface(service);
Entering directory `<span class="org-function-name">/home/bhj/src/android/frameworks/base/core/java/com/android/internal/os/storage</span>'
<span class="org-underline"><span class="org-compilation-info">ExternalStorageFormatter.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">319</span></span><span class="org-underline">:</span> &lt;=     IMountService getMountService() {
<span class="org-underline"><span class="org-compilation-info">ExternalStorageFormatter.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">323</span></span><span class="org-underline">:</span> =&gt;                 mMountService = IMountService.Stub.asInterface(service);
Entering directory `<span class="org-function-name">/home/bhj/src/android/frameworks/base/core/java/com/android/internal/widget</span>'
<span class="org-underline"><span class="org-compilation-info">LockPatternUtils.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">632</span></span><span class="org-underline">:</span> &lt;=     private void updateEncryptionPassword(String password) {
<span class="org-underline"><span class="org-compilation-info">LockPatternUtils.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">645</span></span><span class="org-underline">:</span> =&gt;         IMountService mountService = IMountService.Stub.asInterface(service);
Entering directory `<span class="org-function-name">/home/bhj/src/android/frameworks/base/packages/BackupRestoreConfirmation/src/com/android/backupconfirm</span>'
<span class="org-underline"><span class="org-compilation-info">BackupRestoreConfirmation.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">131</span></span><span class="org-underline">:</span> &lt;=     public void onCreate(Bundle icicle) {
<span class="org-underline"><span class="org-compilation-info">BackupRestoreConfirmation.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">159</span></span><span class="org-underline">:</span> =&gt;         mMountService = IMountService.Stub.asInterface(ServiceManager.getService("mount"));
Entering directory `<span class="org-function-name">/home/bhj/src/android/frameworks/base/packages/SystemUI/src/com/android/systemui/usb</span>'
<span class="org-underline"><span class="org-compilation-info">UsbStorageActivity.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">202</span></span><span class="org-underline">:</span> &lt;=     private IMountService getMountService() {
<span class="org-underline"><span class="org-compilation-info">UsbStorageActivity.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">205</span></span><span class="org-underline">:</span> =&gt;             return IMountService.Stub.asInterface(service);
Entering directory `<span class="org-function-name">/home/bhj/src/android/frameworks/base/services/java/com/android/server</span>'
<span class="org-underline"><span class="org-compilation-info">BackupManagerService.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">773</span></span><span class="org-underline">:</span> &lt;=     public BackupManagerService(Context context) {
<span class="org-underline"><span class="org-compilation-info">BackupManagerService.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">781</span></span><span class="org-underline">:</span> =&gt;         mMountService = IMountService.Stub.asInterface(ServiceManager.getService("mount"));
Entering directory `<span class="org-function-name">/home/bhj/src/android/frameworks/base/services/java/com/android/server/power</span>'
<span class="org-underline"><span class="org-compilation-info">ShutdownThread.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">295</span></span><span class="org-underline">:</span> &lt;=     public void run() {
<span class="org-underline"><span class="org-compilation-info">ShutdownThread.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">374</span></span><span class="org-underline">:</span> =&gt;                 final IMountService mount = IMountService.Stub.asInterface(
Entering directory `<span class="org-function-name">/home/bhj/src/android/packages/apps/SettingsSmartisan/src/com/android/settings</span>'
<span class="org-underline"><span class="org-compilation-info">CryptKeeperConfirm.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">41</span></span><span class="org-underline">:</span> &lt;=         public void onCreate(Bundle savedInstanceState) {
<span class="org-underline"><span class="org-compilation-info">CryptKeeperConfirm.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">72</span></span><span class="org-underline">:</span> =&gt;                     IMountService mountService = IMountService.Stub.asInterface(service);
Entering directory `<span class="org-function-name">/home/bhj/src/android/packages/apps/SettingsSmartisan/src/com/android/settings</span>'
<span class="org-underline"><span class="org-compilation-info">CryptKeeper.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">614</span></span><span class="org-underline">:</span> &lt;=     private IMountService getMountService() {
<span class="org-underline"><span class="org-compilation-info">CryptKeeper.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">617</span></span><span class="org-underline">:</span> =&gt;             return IMountService.Stub.asInterface(service);
Entering directory `<span class="org-function-name">/home/bhj/src/android/packages/apps/SettingsSmartisan/src/com/android/settings/deviceinfo</span>'
<span class="org-underline"><span class="org-compilation-info">Memory.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">214</span></span><span class="org-underline">:</span> &lt;=     private synchronized IMountService getMountService() {
<span class="org-underline"><span class="org-compilation-info">Memory.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">218</span></span><span class="org-underline">:</span> =&gt;                mMountService = IMountService.Stub.asInterface(service);
Entering directory `<span class="org-function-name">/home/bhj/src/android/packages/apps/Settings/src/com/android/settings</span>'
<span class="org-underline"><span class="org-compilation-info">CryptKeeperConfirm.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">41</span></span><span class="org-underline">:</span> &lt;=         public void onCreate(Bundle savedInstanceState) {
<span class="org-underline"><span class="org-compilation-info">CryptKeeperConfirm.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">72</span></span><span class="org-underline">:</span> =&gt;                     IMountService mountService = IMountService.Stub.asInterface(service);
Entering directory `<span class="org-function-name">/home/bhj/src/android/packages/apps/Settings/src/com/android/settings</span>'
<span class="org-underline"><span class="org-compilation-info">CryptKeeper.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">614</span></span><span class="org-underline">:</span> &lt;=     private IMountService getMountService() {
<span class="org-underline"><span class="org-compilation-info">CryptKeeper.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">617</span></span><span class="org-underline">:</span> =&gt;             return IMountService.Stub.asInterface(service);
Entering directory `<span class="org-function-name">/home/bhj/src/android/packages/apps/Settings/src/com/android/settings/deviceinfo</span>'
<span class="org-underline"><span class="org-compilation-info">Memory.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">203</span></span><span class="org-underline">:</span> &lt;=     private synchronized IMountService getMountService() {
<span class="org-underline"><span class="org-compilation-info">Memory.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">207</span></span><span class="org-underline">:</span> =&gt;                mMountService = IMountService.Stub.asInterface(service);
Entering directory `<span class="org-function-name">/home/bhj/src/android/packages/apps/SystemUISmartisan/src/com/smartisanos/systemui/usb</span>'
<span class="org-underline"><span class="org-compilation-info">UsbStorageActivity.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">204</span></span><span class="org-underline">:</span> &lt;=     private IMountService getMountService() {
<span class="org-underline"><span class="org-compilation-info">UsbStorageActivity.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">207</span></span><span class="org-underline">:</span> =&gt;             return IMountService.Stub.asInterface(service);
Entering directory `<span class="org-function-name">/home/bhj/src/android/vendor/qcom/proprietary/QualcommSettings/src/com/qualcomm/qualcommsettings</span>'
<span class="org-underline"><span class="org-compilation-info">QualcommSettings.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">687</span></span><span class="org-underline">:</span> &lt;=    private void updateUsbMassStorageStatus() {
<span class="org-underline"><span class="org-compilation-info">QualcommSettings.java</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">689</span></span><span class="org-underline">:</span> =&gt;         IMountService mountService = IMountService.Stub.asInterface(ServiceManager

Grep finished (<span class="org-compilation-info">matches found</span>) at Fri Jul 25 14:53:31
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> ServiceManager.getService()</h2>
<div class="outline-text-2" id="text-2">
<p>
这个函数：
</p>

<div class="org-src-container">

<pre class="src src-java"><span class="org-keyword">public</span> <span class="org-keyword">static</span> <span class="org-type">IBinder</span> <span class="org-function-name">getService</span>(<span class="org-type">String</span> <span class="org-variable-name">name</span>) {
    <span class="org-keyword">try</span> {
        <span class="org-type">IBinder</span> <span class="org-variable-name">service</span> = sCache.get(name);
        <span class="org-keyword">if</span> (service != <span class="org-constant">null</span>) {
            <span class="org-keyword">return</span> service;
        } <span class="org-keyword">else</span> {
            <span class="org-keyword">return</span> getIServiceManager().getService(name);
        }
    } <span class="org-keyword">catch</span> (<span class="org-type">RemoteException</span> <span class="org-variable-name">e</span>) {
        Log.e(TAG, <span class="org-string">"error in getService"</span>, e);
    }
    <span class="org-keyword">return</span> <span class="org-constant">null</span>;
}
</pre>
</div>


<p>
会调到 getIServiceManager：
</p>

<div class="org-src-container">

<pre class="src src-java"><span class="org-keyword">private</span> <span class="org-keyword">static</span> <span class="org-type">IServiceManager</span> <span class="org-function-name">getIServiceManager</span>() {
    <span class="org-keyword">if</span> (sServiceManager != <span class="org-constant">null</span>) {
        <span class="org-keyword">return</span> sServiceManager;
    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">Find the service manager</span>
    sServiceManager = ServiceManagerNative.asInterface(BinderInternal.getContextObject());
    <span class="org-keyword">return</span> sServiceManager;
}
</pre>
</div>

<p>
会调到 ServiceManagerNative.asInterface(BinderInternal.getContextObject())
</p>

<p>
其中 BinderInternal.getContextObject() 是个native的函数，它会调到 c++ 的 getContextObject：
</p>

<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">sp</span>&lt;IBinder&gt; <span class="org-constant">ProcessState</span>::<span class="org-function-name">getContextObject</span>(<span class="org-keyword">const</span> <span class="org-type">sp</span>&lt;IBinder&gt;&amp; <span class="org-variable-name">caller</span>)
{
    <span class="org-keyword">return</span> getStrongProxyForHandle(0);
}
</pre>
</div>

<p>
可以看到，这里的caller参数都没有用到，不知道是为什么要有这个caller参数。
</p>

<p>
getStrongProxyForHandle的定义如下：
</p>

<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">sp</span>&lt;IBinder&gt; <span class="org-constant">ProcessState</span>::<span class="org-function-name">getStrongProxyForHandle</span>(<span class="org-type">int32_t</span> <span class="org-variable-name">handle</span>)
{
    <span class="org-type">sp</span>&lt;IBinder&gt; <span class="org-variable-name">result</span>;

    <span class="org-type">AutoMutex</span> <span class="org-variable-name">_l</span>(mLock);

    <span class="org-type">handle_entry</span>* <span class="org-variable-name">e</span> = lookupHandleLocked(handle);

    <span class="org-keyword">if</span> (e != <span class="org-constant">NULL</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">We need to create a new BpBinder if there isn't currently one, OR we</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">are unable to acquire a weak reference on this current one.  See comment</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">in getWeakProxyForHandle() for more info about this.</span>
        <span class="org-type">IBinder</span>* <span class="org-variable-name">b</span> = e-&gt;binder;
        <span class="org-keyword">if</span> (b == <span class="org-constant">NULL</span> || <span class="org-negation-char">!</span>e-&gt;refs-&gt;attemptIncWeak(<span class="org-keyword">this</span>)) {
            b = <span class="org-keyword">new</span> <span class="org-type">BpBinder</span>(handle);
            e-&gt;binder = b;
            <span class="org-keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();
            result = b;
        } <span class="org-keyword">else</span> {
            <span class="org-comment-delimiter">// </span><span class="org-comment">This little bit of nastyness is to allow us to add a primary</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">reference to the remote proxy when this team doesn't have one</span>
            <span class="org-comment-delimiter">// </span><span class="org-comment">but another team is sending the handle to us.</span>
            result.force_set(b);
            e-&gt;refs-&gt;decWeak(<span class="org-keyword">this</span>);
        }
    }

    <span class="org-keyword">return</span> result;
}
</pre>
</div>

<p>
所以这里我们要看一下 lookupHandleLocked 这个函数，此处传进去的handle为0。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span class="org-constant">ProcessState</span>::<span class="org-type">handle_entry</span>* <span class="org-constant">ProcessState</span>::<span class="org-function-name">lookupHandleLocked</span>(<span class="org-type">int32_t</span> <span class="org-variable-name">handle</span>)
{
    <span class="org-keyword">const</span> <span class="org-type">size_t</span> <span class="org-variable-name">N</span>=mHandleToObject.size();
    <span class="org-keyword">if</span> (N &lt;= (<span class="org-type">size_t</span>)handle) {
        <span class="org-type">handle_entry</span> <span class="org-variable-name">e</span>;
        e.binder = <span class="org-constant">NULL</span>;
        e.refs = <span class="org-constant">NULL</span>;
        <span class="org-type">status_t</span> <span class="org-variable-name">err</span> = mHandleToObject.insertAt(e, N, handle+1-N);
        <span class="org-keyword">if</span> (err &lt; NO_ERROR) <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
    }
    <span class="org-keyword">return</span> &amp;mHandleToObject.editItemAt(handle);
}
</pre>
</div>

<p>
因为handle为0，所以 mHandleToObject 的.size() 和 handle 一比，如果
handle 不在 mHandleToObject 里，就需要插一个新的 handle_entry 进去，否
则直接从 mHandleToObject 里抽一个 editItemAt 出来交差。
</p>

<p>
看一下 mHandleToObject 是怎么初始化的：
</p>

<div class="org-src-container">

<pre class="src src-grepout">-*- mode: grep; default-directory: "~/src/android/frameworks/native/libs/binder/" -*-
Grep started at Sun Jul 27 22:16:08

beagrep -e "mHandleToObject"
<span class="org-underline"><span class="org-compilation-info">/home/bhj/src/android/frameworks/native/include/binder/ProcessState.h</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">96</span></span><span class="org-underline">:</span>            Vector&lt;handle_entry&gt;mHandleToObject;
<span class="org-underline"><span class="org-compilation-info">/home/bhj/src/android/frameworks/native/libs/binder/ProcessState.cpp</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">172</span></span><span class="org-underline">:</span>    const size_t N=mHandleToObject.size();
<span class="org-underline"><span class="org-compilation-info">/home/bhj/src/android/frameworks/native/libs/binder/ProcessState.cpp</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">177</span></span><span class="org-underline">:</span>        status_t err = mHandleToObject.insertAt(e, N, handle+1-N);
<span class="org-underline"><span class="org-compilation-info">/home/bhj/src/android/frameworks/native/libs/binder/ProcessState.cpp</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">180</span></span><span class="org-underline">:</span>    return &amp;mHandleToObject.editItemAt(handle);

Grep finished (<span class="org-compilation-info">matches found</span>) at Sun Jul 27 22:16:08
</pre>
</div>

<p>
完了，mHandleToObject根本没有正规的初始化，都是在 lookupHandleLocked里
完成对它的操作的，如果handle没有找到的话，就放一个handle_entry进去跟这
个handle对应，其binder和refs均为空值。然后在 getStrongProxyForHandle里，
看到了 binder 成员为空，就会 new 一个 BpBinder(handle) 出来赋给它，这
样就建立起了BpBinder与handle之间的关系。
</p>

<p>
BpBinder有一个mHandle的成员变量，会被赋上这个handle的值，然后这个
mHandle 会在 transact 函数中用到：
</p>

<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">status_t</span> <span class="org-constant">BpBinder</span>::<span class="org-function-name">transact</span>(
    <span class="org-type">uint32_t</span> <span class="org-variable-name">code</span>, <span class="org-keyword">const</span> <span class="org-type">Parcel</span>&amp; <span class="org-variable-name">data</span>, <span class="org-type">Parcel</span>* <span class="org-variable-name">reply</span>, <span class="org-type">uint32_t</span> <span class="org-variable-name">flags</span>)
{
    <span class="org-comment-delimiter">// </span><span class="org-comment">Once a binder has died, it will never come back to life.</span>
    <span class="org-keyword">if</span> (mAlive) {
        <span class="org-type">status_t</span> <span class="org-variable-name">status</span> = <span class="org-constant">IPCThreadState</span>::self()-&gt;transact(
            mHandle, code, data, reply, flags);
        <span class="org-keyword">if</span> (status == DEAD_OBJECT) mAlive = 0;
        <span class="org-keyword">return</span> status;
    }

    <span class="org-keyword">return</span> DEAD_OBJECT;
}
</pre>
</div>

<p>
会调到 IPCThreadState::self()-&gt;transact()：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">status_t</span> <span class="org-constant">IPCThreadState</span>::<span class="org-function-name">transact</span>(<span class="org-type">int32_t</span> <span class="org-variable-name">handle</span>,
                                  <span class="org-type">uint32_t</span> <span class="org-variable-name">code</span>, <span class="org-keyword">const</span> <span class="org-type">Parcel</span>&amp; <span class="org-variable-name">data</span>,
                                  <span class="org-type">Parcel</span>* <span class="org-variable-name">reply</span>, <span class="org-type">uint32_t</span> <span class="org-variable-name">flags</span>)
{
    <span class="org-type">status_t</span> <span class="org-variable-name">err</span> = data.errorCheck();

    flags |= TF_ACCEPT_FDS;

    <span class="org-keyword">if</span> (err == NO_ERROR) {
        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="org-constant">NULL</span>);
    }

    <span class="org-keyword">if</span> (err != NO_ERROR) {
        <span class="org-keyword">if</span> (reply) reply-&gt;setError(err);
        <span class="org-keyword">return</span> (mLastError = err);
    }

    <span class="org-keyword">if</span> ((flags &amp; TF_ONE_WAY) == 0) {
        <span class="org-keyword">if</span> (reply) {
            err = waitForResponse(reply);
        } <span class="org-keyword">else</span> {
            <span class="org-type">Parcel</span> <span class="org-variable-name">fakeReply</span>;
            err = waitForResponse(&amp;fakeReply);
        }
    } <span class="org-keyword">else</span> {
        err = waitForResponse(<span class="org-constant">NULL</span>, <span class="org-constant">NULL</span>);
    }

    <span class="org-keyword">return</span> err;
}
</pre>
</div>
<p>
上面这个函数里所有的多余的注释和 <code>#if 0</code> 之类的代码都已经去掉了。所以其逻辑也比较明了，主要调了一个 writeTransactionData 和一个 waitForResponse 函数。
</p>

<p>
先看 writeTransactionData
</p>

<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">status_t</span> <span class="org-constant">IPCThreadState</span>::<span class="org-function-name">writeTransactionData</span>(<span class="org-type">int32_t</span> <span class="org-variable-name">cmd</span>, <span class="org-type">uint32_t</span> <span class="org-variable-name">binderFlags</span>,
    <span class="org-type">int32_t</span> <span class="org-variable-name">handle</span>, <span class="org-type">uint32_t</span> <span class="org-variable-name">code</span>, <span class="org-keyword">const</span> <span class="org-type">Parcel</span>&amp; <span class="org-variable-name">data</span>, <span class="org-type">status_t</span>* <span class="org-variable-name">statusBuffer</span>)
{
    <span class="org-type">binder_transaction_data</span> <span class="org-variable-name">tr</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;struct&#26159;&#22312;kernel&#37324;&#23450;&#20041;&#30340;</span>

    tr.target.handle = handle;
    tr.code = code;
    tr.flags = binderFlags;
    tr.cookie = 0;
    tr.sender_pid = 0;
    tr.sender_euid = 0;

    <span class="org-keyword">const</span> <span class="org-type">status_t</span> <span class="org-variable-name">err</span> = data.errorCheck(); <span class="org-comment-delimiter">// </span><span class="org-comment">status_t &#26159; system/core/include/utils/Errors.h &#37324;&#23450;&#20041;&#30340;</span>
    <span class="org-keyword">if</span> (err == NO_ERROR) {
        tr.data_size = data.ipcDataSize();
        tr.data.ptr.buffer = data.ipcData();
        tr.offsets_size = data.ipcObjectsCount()*<span class="org-keyword">sizeof</span>(size_t);
        tr.data.ptr.offsets = data.ipcObjects();
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (statusBuffer) {
        tr.flags |= TF_STATUS_CODE;
        *statusBuffer = err;
        tr.data_size = <span class="org-keyword">sizeof</span>(status_t);
        tr.data.ptr.buffer = statusBuffer;
        tr.offsets_size = 0;
        tr.data.ptr.offsets = <span class="org-constant">NULL</span>;
    } <span class="org-keyword">else</span> {
        <span class="org-keyword">return</span> (mLastError = err);
    }

    mOut.writeInt32(cmd);
    mOut.write(&amp;tr, <span class="org-keyword">sizeof</span>(tr));

    <span class="org-keyword">return</span> NO_ERROR;
}
</pre>
</div>
<p>
code 在 IServiceManager 里是 一个如 Stub.TRANSACTION_registerListener
这样的值。 cmd刚才看到是 BC_TRANSACTION 。在transact调用里，
writeTransactionData 的 statusBuffer 的参数是 NULL，所以先不用看。然后
看到的是 mOut 里写了个 cmd，再写了个 tr ，这个函数就返回了，所以它跟内
核里的 binder 设备还没有交互过呢。
</p>

<p>
交互应该是在 waitForResponse 里:
</p>

<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">status_t</span> <span class="org-constant">IPCThreadState</span>::<span class="org-function-name">waitForResponse</span>(<span class="org-type">Parcel</span> *<span class="org-variable-name">reply</span>, <span class="org-type">status_t</span> *<span class="org-variable-name">acquireResult</span>)
{
    <span class="org-type">int32_t</span> <span class="org-variable-name">cmd</span>;
    <span class="org-type">int32_t</span> <span class="org-variable-name">err</span>;

    <span class="org-keyword">while</span> (1) {
        <span class="org-keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="org-keyword">break</span>;
        err = mIn.errorCheck();
        <span class="org-keyword">if</span> (err &lt; NO_ERROR) <span class="org-keyword">break</span>;
        <span class="org-keyword">if</span> (mIn.dataAvail() == 0) <span class="org-keyword">continue</span>;

        cmd = mIn.readInt32();

        <span class="org-keyword">switch</span> (cmd) {
        <span class="org-keyword">case</span> BR_TRANSACTION_COMPLETE:
            <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>reply &amp;&amp; <span class="org-negation-char">!</span>acquireResult) <span class="org-keyword">goto</span> <span class="org-constant">finish</span>;
            <span class="org-keyword">break</span>;

        <span class="org-keyword">case</span> BR_DEAD_REPLY:
            err = DEAD_OBJECT;
            <span class="org-keyword">goto</span> <span class="org-constant">finish</span>;

        <span class="org-keyword">case</span> BR_FAILED_REPLY:
            err = FAILED_TRANSACTION;
            <span class="org-keyword">goto</span> <span class="org-constant">finish</span>;

        <span class="org-keyword">case</span> BR_ACQUIRE_RESULT:
            {
                ALOG_ASSERT(acquireResult != <span class="org-constant">NULL</span>, <span class="org-string">"Unexpected brACQUIRE_RESULT"</span>);
                <span class="org-keyword">const</span> <span class="org-type">int32_t</span> <span class="org-variable-name">result</span> = mIn.readInt32();
                <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>acquireResult) <span class="org-keyword">continue</span>;
                *acquireResult = result ? NO_ERROR : INVALID_OPERATION;
            }
            <span class="org-keyword">goto</span> <span class="org-constant">finish</span>;

        <span class="org-keyword">case</span> BR_REPLY:
            {
                <span class="org-type">binder_transaction_data</span> <span class="org-variable-name">tr</span>;
                err = mIn.read(&amp;tr, <span class="org-keyword">sizeof</span>(tr));
                ALOG_ASSERT(err == NO_ERROR, <span class="org-string">"Not enough command data for brREPLY"</span>);
                <span class="org-keyword">if</span> (err != NO_ERROR) <span class="org-keyword">goto</span> <span class="org-constant">finish</span>;

                <span class="org-keyword">if</span> (reply) {
                    <span class="org-keyword">if</span> ((tr.flags &amp; TF_STATUS_CODE) == 0) {
                        reply-&gt;ipcSetDataReference(
                            <span class="org-keyword">reinterpret_cast</span>&lt;<span class="org-keyword">const</span> uint8_t*&gt;(tr.data.ptr.buffer),
                            tr.data_size,
                            <span class="org-keyword">reinterpret_cast</span>&lt;<span class="org-keyword">const</span> size_t*&gt;(tr.data.ptr.offsets),
                            tr.offsets_size/<span class="org-keyword">sizeof</span>(size_t),
                            freeBuffer, <span class="org-keyword">this</span>);
                    } <span class="org-keyword">else</span> {
                        err = *<span class="org-keyword">static_cast</span>&lt;<span class="org-keyword">const</span> status_t*&gt;(tr.data.ptr.buffer);
                        freeBuffer(<span class="org-constant">NULL</span>,
                            <span class="org-keyword">reinterpret_cast</span>&lt;<span class="org-keyword">const</span> uint8_t*&gt;(tr.data.ptr.buffer),
                            tr.data_size,
                            <span class="org-keyword">reinterpret_cast</span>&lt;<span class="org-keyword">const</span> size_t*&gt;(tr.data.ptr.offsets),
                            tr.offsets_size/<span class="org-keyword">sizeof</span>(size_t), <span class="org-keyword">this</span>);
                    }
                } <span class="org-keyword">else</span> {
                    freeBuffer(<span class="org-constant">NULL</span>,
                        <span class="org-keyword">reinterpret_cast</span>&lt;<span class="org-keyword">const</span> uint8_t*&gt;(tr.data.ptr.buffer),
                        tr.data_size,
                        <span class="org-keyword">reinterpret_cast</span>&lt;<span class="org-keyword">const</span> size_t*&gt;(tr.data.ptr.offsets),
                        tr.offsets_size/<span class="org-keyword">sizeof</span>(size_t), <span class="org-keyword">this</span>);
                    <span class="org-keyword">continue</span>;
                }
            }
            <span class="org-keyword">goto</span> <span class="org-constant">finish</span>;

        <span class="org-keyword">default</span>:
            err = executeCommand(cmd);
            <span class="org-keyword">if</span> (err != NO_ERROR) <span class="org-keyword">goto</span> <span class="org-constant">finish</span>;
            <span class="org-keyword">break</span>;
        }
    }

<span class="org-constant">finish</span>:
    <span class="org-keyword">if</span> (err != NO_ERROR) {
        <span class="org-keyword">if</span> (acquireResult) *acquireResult = err;
        <span class="org-keyword">if</span> (reply) reply-&gt;setError(err);
        mLastError = err;
    }

    <span class="org-keyword">return</span> err;
}
</pre>
</div>

<p>
最关键的函数应该是那个 talkWithDriver 了，这个才真正把命令发过去，并把返回结果读回来。
</p>

<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">status_t</span> <span class="org-constant">IPCThreadState</span>::<span class="org-function-name">talkWithDriver</span>(<span class="org-type">bool</span> <span class="org-variable-name">doReceive</span>)
{
    <span class="org-type">binder_write_read</span> <span class="org-variable-name">bwr</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Is the read buffer empty?</span>
    <span class="org-keyword">const</span> <span class="org-type">bool</span> <span class="org-variable-name">needRead</span> = mIn.dataPosition() &gt;= mIn.dataSize();

    <span class="org-comment-delimiter">// </span><span class="org-comment">We don't want to write anything if we are still reading</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">from data left in the input buffer and the caller</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">has requested to read the next data.</span>
    <span class="org-keyword">const</span> <span class="org-type">size_t</span> <span class="org-variable-name">outAvail</span> = (<span class="org-negation-char">!</span>doReceive || needRead) ? mOut.dataSize() : 0;

    bwr.write_size = outAvail;
    bwr.write_buffer = (<span class="org-type">long</span> <span class="org-type">unsigned</span> <span class="org-type">int</span>)mOut.data();

    <span class="org-comment-delimiter">// </span><span class="org-comment">This is what we'll read.</span>
    <span class="org-keyword">if</span> (doReceive &amp;&amp; needRead) {
        bwr.read_size = mIn.dataCapacity();
        bwr.read_buffer = (<span class="org-type">long</span> <span class="org-type">unsigned</span> <span class="org-type">int</span>)mIn.data();
    } <span class="org-keyword">else</span> {
        bwr.read_size = 0;
        bwr.read_buffer = 0;
    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">Return immediately if there is nothing to do.</span>
    <span class="org-keyword">if</span> ((bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)) <span class="org-keyword">return</span> NO_ERROR;

    bwr.write_consumed = 0;
    bwr.read_consumed = 0;
    <span class="org-type">status_t</span> <span class="org-variable-name">err</span>;
    <span class="org-keyword">do</span> {
        <span class="org-keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0)
            err = NO_ERROR;
        <span class="org-keyword">else</span>
            err = -errno;
        <span class="org-keyword">if</span> (mProcess-&gt;mDriverFD &lt;= 0) {
            err = -EBADF;
        }
    } <span class="org-keyword">while</span> (err == -EINTR);

    <span class="org-keyword">if</span> (err &gt;= NO_ERROR) {
        <span class="org-keyword">if</span> (bwr.write_consumed &gt; 0) {
            <span class="org-keyword">if</span> (bwr.write_consumed &lt; (<span class="org-type">ssize_t</span>)mOut.dataSize())
                mOut.remove(0, bwr.write_consumed);
            <span class="org-keyword">else</span>
                mOut.setDataSize(0);
        }
        <span class="org-keyword">if</span> (bwr.read_consumed &gt; 0) {
            mIn.setDataSize(bwr.read_consumed);
            mIn.setDataPosition(0);
        }
        <span class="org-keyword">return</span> NO_ERROR;
    }

    <span class="org-keyword">return</span> err;
}
</pre>
</div>

<p>
这里面的关键就在于一个简简单单的 ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) 函数调用。
</p>

<p>
这个函数最后会调到kernel里：
</p>

<div class="org-src-container">

<pre class="src src-c"><span class="org-keyword">static</span> <span class="org-type">long</span> <span class="org-function-name">binder_ioctl</span>(<span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">filp</span>, <span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">cmd</span>, <span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-variable-name">arg</span>)
{
        <span class="org-type">int</span> <span class="org-variable-name">ret</span>;
        <span class="org-keyword">struct</span> <span class="org-type">binder_proc</span> *<span class="org-variable-name">proc</span> = filp-&gt;private_data;
        <span class="org-keyword">struct</span> <span class="org-type">binder_thread</span> *<span class="org-variable-name">thread</span>;
        <span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">size</span> = _IOC_SIZE(cmd);
        <span class="org-type">void</span> <span class="org-variable-name">__user</span> *ubuf = (<span class="org-type">void</span> <span class="org-variable-name">__user</span> *)arg;

        <span class="org-comment-delimiter">/*</span><span class="org-comment">printk(KERN_INFO "binder_ioctl: %d:%d %x %lx\n", proc-&gt;pid, current-&gt;pid, cmd, arg);</span><span class="org-comment-delimiter">*/</span>

        ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2);
        <span class="org-keyword">if</span> (ret)
                <span class="org-keyword">return</span> ret;

        mutex_lock(&amp;binder_lock);
        thread = binder_get_thread(proc);
        <span class="org-keyword">if</span> (thread == <span class="org-constant">NULL</span>) {
                ret = -ENOMEM;
                <span class="org-keyword">goto</span> <span class="org-constant">err</span>;
        }

        <span class="org-keyword">switch</span> (cmd) {
        <span class="org-keyword">case</span> BINDER_WRITE_READ: {
                <span class="org-keyword">struct</span> <span class="org-type">binder_write_read</span> <span class="org-variable-name">bwr</span>;
                <span class="org-keyword">if</span> (size != <span class="org-keyword">sizeof</span>(<span class="org-keyword">struct</span> <span class="org-type">binder_write_read</span>)) {
                        ret = -EINVAL;
                        <span class="org-keyword">goto</span> <span class="org-constant">err</span>;
                }
                <span class="org-keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="org-keyword">sizeof</span>(bwr))) {
                        ret = -EFAULT;
                        <span class="org-keyword">goto</span> <span class="org-constant">err</span>;
                }
                binder_debug(BINDER_DEBUG_READ_WRITE,
                             <span class="org-string">"binder: %d:%d write %ld at %08lx, read %ld at %08lx\n"</span>,
                             proc-&gt;pid, thread-&gt;pid, bwr.write_size, bwr.write_buffer,
                             bwr.read_size, bwr.read_buffer);

                <span class="org-keyword">if</span> (bwr.write_size &gt; 0) {
                        ret = binder_thread_write(proc, thread, (<span class="org-type">void</span> <span class="org-variable-name">__user</span> *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);
                        <span class="org-keyword">if</span> (ret &lt; 0) {
                                bwr.read_consumed = 0;
                                <span class="org-keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="org-keyword">sizeof</span>(bwr)))
                                        ret = -EFAULT;
                                <span class="org-keyword">goto</span> <span class="org-constant">err</span>;
                        }
                }
                <span class="org-keyword">if</span> (bwr.read_size &gt; 0) {
                        ret = binder_thread_read(proc, thread, (<span class="org-type">void</span> <span class="org-variable-name">__user</span> *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);
                        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>list_empty(&amp;proc-&gt;todo))
                                wake_up_interruptible(&amp;proc-&gt;wait);
                        <span class="org-keyword">if</span> (ret &lt; 0) {
                                <span class="org-keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="org-keyword">sizeof</span>(bwr)))
                                        ret = -EFAULT;
                                <span class="org-keyword">goto</span> <span class="org-constant">err</span>;
                        }
                }
                binder_debug(BINDER_DEBUG_READ_WRITE,
                             <span class="org-string">"binder: %d:%d wrote %ld of %ld, read return %ld of %ld\n"</span>,
                             proc-&gt;pid, thread-&gt;pid, bwr.write_consumed, bwr.write_size,
                             bwr.read_consumed, bwr.read_size);
                <span class="org-keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="org-keyword">sizeof</span>(bwr))) {
                        ret = -EFAULT;
                        <span class="org-keyword">goto</span> <span class="org-constant">err</span>;
                }
                <span class="org-keyword">break</span>;
        }
        <span class="org-keyword">case</span> BINDER_SET_MAX_THREADS:
                <span class="org-keyword">if</span> (copy_from_user(&amp;proc-&gt;max_threads, ubuf, <span class="org-keyword">sizeof</span>(proc-&gt;max_threads))) {
                        ret = -EINVAL;
                        <span class="org-keyword">goto</span> <span class="org-constant">err</span>;
                }
                <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> BINDER_SET_CONTEXT_MGR:
                <span class="org-keyword">if</span> (binder_context_mgr_node != <span class="org-constant">NULL</span>) {
                        binder_debug(BINDER_DEBUG_TOP_ERRORS,
                                     <span class="org-string">"binder: BINDER_SET_CONTEXT_MGR already set\n"</span>);
                        ret = -EBUSY;
                        <span class="org-keyword">goto</span> <span class="org-constant">err</span>;
                }
                ret = security_binder_set_context_mgr(proc-&gt;tsk);
                <span class="org-keyword">if</span> (ret &lt; 0)
                        <span class="org-keyword">goto</span> <span class="org-constant">err</span>;
                <span class="org-keyword">if</span> (binder_context_mgr_uid != -1) {
                        <span class="org-keyword">if</span> (binder_context_mgr_uid != current-&gt;cred-&gt;euid) {
                                binder_debug(BINDER_DEBUG_TOP_ERRORS,
                                             <span class="org-string">"binder: BINDER_SET_"</span>
                                             <span class="org-string">"CONTEXT_MGR bad uid %d != %d\n"</span>,
                                             current-&gt;cred-&gt;euid,
                                             binder_context_mgr_uid);
                                ret = -EPERM;
                                <span class="org-keyword">goto</span> <span class="org-constant">err</span>;
                        }
                } <span class="org-keyword">else</span>
                        binder_context_mgr_uid = current-&gt;cred-&gt;euid;
                binder_context_mgr_node = binder_new_node(proc, <span class="org-constant">NULL</span>, <span class="org-constant">NULL</span>);
                <span class="org-keyword">if</span> (binder_context_mgr_node == <span class="org-constant">NULL</span>) {
                        ret = -ENOMEM;
                        <span class="org-keyword">goto</span> <span class="org-constant">err</span>;
                }
                binder_context_mgr_node-&gt;local_weak_refs++;
                binder_context_mgr_node-&gt;local_strong_refs++;
                binder_context_mgr_node-&gt;has_strong_ref = 1;
                binder_context_mgr_node-&gt;has_weak_ref = 1;
                <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> BINDER_THREAD_EXIT:
                binder_debug(BINDER_DEBUG_THREADS, <span class="org-string">"binder: %d:%d exit\n"</span>,
                             proc-&gt;pid, thread-&gt;pid);
                binder_free_thread(proc, thread);
                thread = <span class="org-constant">NULL</span>;
                <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> BINDER_VERSION:
                <span class="org-keyword">if</span> (size != <span class="org-keyword">sizeof</span>(<span class="org-keyword">struct</span> <span class="org-type">binder_version</span>)) {
                        ret = -EINVAL;
                        <span class="org-keyword">goto</span> <span class="org-constant">err</span>;
                }
                <span class="org-keyword">if</span> (put_user(BINDER_CURRENT_PROTOCOL_VERSION, &amp;((<span class="org-keyword">struct</span> <span class="org-type">binder_version</span> *)ubuf)-&gt;protocol_version)) {
                        ret = -EINVAL;
                        <span class="org-keyword">goto</span> <span class="org-constant">err</span>;
                }
                <span class="org-keyword">break</span>;
        <span class="org-keyword">default</span>:
                ret = -EINVAL;
                <span class="org-keyword">goto</span> <span class="org-constant">err</span>;
        }
        ret = 0;
<span class="org-constant">err</span>:
        <span class="org-keyword">if</span> (thread)
                thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_NEED_RETURN;
        mutex_unlock(&amp;binder_lock);
        wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2);
        <span class="org-keyword">if</span> (ret &amp;&amp; ret != -ERESTARTSYS)
                binder_debug(BINDER_DEBUG_TOP_ERRORS,
                             <span class="org-string">"binder: %d:%d ioctl %x %lx returned %d\n"</span>,
                             proc-&gt;pid, current-&gt;pid, cmd, arg, ret);
        <span class="org-keyword">return</span> ret;
}
</pre>
</div>

<p>
上来就 <code>struct binder_proc *proc = filp-&gt;private_data;</code> ，这个proc/private_data是在哪里初始化的呢？在binder_open里：
</p>

<div class="org-src-container">

<pre class="src src-c"><span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">binder_open</span>(<span class="org-keyword">struct</span> <span class="org-type">inode</span> *<span class="org-variable-name">nodp</span>, <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">filp</span>)
{
        <span class="org-keyword">struct</span> <span class="org-type">binder_proc</span> *<span class="org-variable-name">proc</span>;

        binder_debug(BINDER_DEBUG_OPEN_CLOSE, <span class="org-string">"binder_open: %d:%d\n"</span>,
                     current-&gt;group_leader-&gt;pid, current-&gt;pid);

        proc = kzalloc(<span class="org-keyword">sizeof</span>(*proc), GFP_KERNEL);
        <span class="org-keyword">if</span> (proc == <span class="org-constant">NULL</span>)
                <span class="org-keyword">return</span> -ENOMEM;
        get_task_struct(current);
        proc-&gt;tsk = current;
        INIT_LIST_HEAD(&amp;proc-&gt;todo);
        init_waitqueue_head(&amp;proc-&gt;wait);
        proc-&gt;default_priority = task_nice(current);
        mutex_lock(&amp;binder_lock);
        binder_stats_created(BINDER_STAT_PROC);
        hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);
        proc-&gt;pid = current-&gt;group_leader-&gt;pid;
        INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);
        filp-&gt;private_data = proc;
        mutex_unlock(&amp;binder_lock);

        <span class="org-keyword">if</span> (binder_debugfs_dir_entry_proc) {
                <span class="org-type">char</span> <span class="org-variable-name">strbuf</span>[11];
                snprintf(strbuf, <span class="org-keyword">sizeof</span>(strbuf), <span class="org-string">"%u"</span>, proc-&gt;pid);
                proc-&gt;debugfs_entry = debugfs_create_file(strbuf, S_IRUGO,
                        binder_debugfs_dir_entry_proc, proc, &amp;binder_proc_fops);
        }

        <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<p>
binder_open是 binder 设备的打开文件方法：
</p>

<div class="org-src-container">

<pre class="src src-c"><span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">file_operations</span> <span class="org-variable-name">binder_fops</span> = {
        .owner = THIS_MODULE,
        .poll = binder_poll,
        .unlocked_ioctl = binder_ioctl,
        .mmap = binder_mmap,
        .open = binder_open,
        .flush = binder_flush,
        .release = binder_release,
};
</pre>
</div>

<p>
如果需要写的话，就会调 binder_thread_write 函数：
</p>

<div class="org-src-container">

<pre class="src src-c"><span class="org-type">int</span> <span class="org-function-name">binder_thread_write</span>(<span class="org-keyword">struct</span> <span class="org-type">binder_proc</span> *<span class="org-variable-name">proc</span>, <span class="org-keyword">struct</span> <span class="org-type">binder_thread</span> *<span class="org-variable-name">thread</span>,
                        <span class="org-type">void</span> <span class="org-variable-name">__user</span> *buffer, <span class="org-type">int</span> <span class="org-variable-name">size</span>, <span class="org-type">signed</span> <span class="org-type">long</span> *<span class="org-variable-name">consumed</span>)
{
        <span class="org-type">uint32_t</span> <span class="org-variable-name">cmd</span>;
        <span class="org-type">void</span> <span class="org-variable-name">__user</span> *ptr = buffer + *consumed;
        <span class="org-type">void</span> <span class="org-variable-name">__user</span> *end = buffer + size;

        <span class="org-keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) {
                <span class="org-keyword">if</span> (get_user(cmd, (uint32_t <span class="org-type">__user</span> *)ptr))
                        <span class="org-keyword">return</span> -EFAULT;
                ptr += <span class="org-keyword">sizeof</span>(uint32_t);
                <span class="org-keyword">if</span> (_IOC_NR(cmd) &lt; ARRAY_SIZE(binder_stats.bc)) {
                        binder_stats.bc[_IOC_NR(cmd)]++;
                        proc-&gt;stats.bc[_IOC_NR(cmd)]++;
                        thread-&gt;stats.bc[_IOC_NR(cmd)]++;
                }
                <span class="org-keyword">switch</span> (cmd) {
                <span class="org-keyword">case</span> BC_INCREFS:
                <span class="org-keyword">case</span> BC_ACQUIRE:
                <span class="org-keyword">case</span> BC_RELEASE:
                <span class="org-keyword">case</span> BC_DECREFS: {
                        <span class="org-type">uint32_t</span> <span class="org-variable-name">target</span>;
                        <span class="org-keyword">struct</span> <span class="org-type">binder_ref</span> *<span class="org-variable-name">ref</span>;
                        <span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">debug_string</span>;

                        <span class="org-keyword">if</span> (get_user(target, (uint32_t <span class="org-type">__user</span> *)ptr))
                                <span class="org-keyword">return</span> -EFAULT;
                        ptr += <span class="org-keyword">sizeof</span>(uint32_t);
                        <span class="org-keyword">if</span> (target == 0 &amp;&amp; binder_context_mgr_node &amp;&amp;
                            (cmd == BC_INCREFS || cmd == BC_ACQUIRE)) {
                                ref = binder_get_ref_for_node(proc,
                                               binder_context_mgr_node);
                                <span class="org-keyword">if</span> (ref-&gt;desc != target) {
                                        binder_user_error(<span class="org-string">"binder: %d:"</span>
                                                <span class="org-string">"%d tried to acquire "</span>
                                                <span class="org-string">"reference to desc 0, "</span>
                                                <span class="org-string">"got %d instead\n"</span>,
                                                proc-&gt;pid, thread-&gt;pid,
                                                ref-&gt;desc);
                                }
                        } <span class="org-keyword">else</span>
                                ref = binder_get_ref(proc, target);
                        <span class="org-keyword">if</span> (ref == <span class="org-constant">NULL</span>) {
                                binder_user_error(<span class="org-string">"binder: %d:%d refcou"</span>
                                        <span class="org-string">"nt change on invalid ref %d\n"</span>,
                                        proc-&gt;pid, thread-&gt;pid, target);
                                <span class="org-keyword">break</span>;
                        }
                        <span class="org-keyword">switch</span> (cmd) {
                        <span class="org-keyword">case</span> BC_INCREFS:
                                debug_string = <span class="org-string">"IncRefs"</span>;
                                binder_inc_ref(ref, 0, <span class="org-constant">NULL</span>);
                                <span class="org-keyword">break</span>;
                        <span class="org-keyword">case</span> BC_ACQUIRE:
                                debug_string = <span class="org-string">"Acquire"</span>;
                                binder_inc_ref(ref, 1, <span class="org-constant">NULL</span>);
                                <span class="org-keyword">break</span>;
                        <span class="org-keyword">case</span> BC_RELEASE:
                                debug_string = <span class="org-string">"Release"</span>;
                                binder_dec_ref(ref, 1);
                                <span class="org-keyword">break</span>;
                        <span class="org-keyword">case</span> BC_DECREFS:
                        <span class="org-keyword">default</span>:
                                debug_string = <span class="org-string">"DecRefs"</span>;
                                binder_dec_ref(ref, 0);
                                <span class="org-keyword">break</span>;
                        }
                        binder_debug(BINDER_DEBUG_USER_REFS,
                                     <span class="org-string">"binder: %d:%d %s ref %d desc %d s %d w %d for node %d\n"</span>,
                                     proc-&gt;pid, thread-&gt;pid, debug_string, ref-&gt;debug_id,
                                     ref-&gt;desc, ref-&gt;strong, ref-&gt;weak, ref-&gt;node-&gt;debug_id);
                        <span class="org-keyword">break</span>;
                }
                <span class="org-keyword">case</span> BC_INCREFS_DONE:
                <span class="org-keyword">case</span> BC_ACQUIRE_DONE: {
                        <span class="org-type">void</span> <span class="org-variable-name">__user</span> *node_ptr;
                        <span class="org-type">void</span> *<span class="org-variable-name">cookie</span>;
                        <span class="org-keyword">struct</span> <span class="org-type">binder_node</span> *<span class="org-variable-name">node</span>;

                        <span class="org-keyword">if</span> (get_user(node_ptr, (<span class="org-type">void</span> * <span class="org-variable-name">__user</span> *)ptr))
                                <span class="org-keyword">return</span> -EFAULT;
                        ptr += <span class="org-keyword">sizeof</span>(<span class="org-type">void</span> *);
                        <span class="org-keyword">if</span> (get_user(cookie, (<span class="org-type">void</span> * <span class="org-variable-name">__user</span> *)ptr))
                                <span class="org-keyword">return</span> -EFAULT;
                        ptr += <span class="org-keyword">sizeof</span>(<span class="org-type">void</span> *);
                        node = binder_get_node(proc, node_ptr);
                        <span class="org-keyword">if</span> (node == <span class="org-constant">NULL</span>) {
                                binder_user_error(<span class="org-string">"binder: %d:%d "</span>
                                        <span class="org-string">"%s u%p no match\n"</span>,
                                        proc-&gt;pid, thread-&gt;pid,
                                        cmd == BC_INCREFS_DONE ?
                                        <span class="org-string">"BC_INCREFS_DONE"</span> :
                                        <span class="org-string">"BC_ACQUIRE_DONE"</span>,
                                        node_ptr);
                                <span class="org-keyword">break</span>;
                        }
                        <span class="org-keyword">if</span> (cookie != node-&gt;cookie) {
                                binder_user_error(<span class="org-string">"binder: %d:%d %s u%p node %d"</span>
                                        <span class="org-string">" cookie mismatch %p != %p\n"</span>,
                                        proc-&gt;pid, thread-&gt;pid,
                                        cmd == BC_INCREFS_DONE ?
                                        <span class="org-string">"BC_INCREFS_DONE"</span> : <span class="org-string">"BC_ACQUIRE_DONE"</span>,
                                        node_ptr, node-&gt;debug_id,
                                        cookie, node-&gt;cookie);
                                <span class="org-keyword">break</span>;
                        }
                        <span class="org-keyword">if</span> (cmd == BC_ACQUIRE_DONE) {
                                <span class="org-keyword">if</span> (node-&gt;pending_strong_ref == 0) {
                                        binder_user_error(<span class="org-string">"binder: %d:%d "</span>
                                                <span class="org-string">"BC_ACQUIRE_DONE node %d has "</span>
                                                <span class="org-string">"no pending acquire request\n"</span>,
                                                proc-&gt;pid, thread-&gt;pid,
                                                node-&gt;debug_id);
                                        <span class="org-keyword">break</span>;
                                }
                                node-&gt;pending_strong_ref = 0;
                        } <span class="org-keyword">else</span> {
                                <span class="org-keyword">if</span> (node-&gt;pending_weak_ref == 0) {
                                        binder_user_error(<span class="org-string">"binder: %d:%d "</span>
                                                <span class="org-string">"BC_INCREFS_DONE node %d has "</span>
                                                <span class="org-string">"no pending increfs request\n"</span>,
                                                proc-&gt;pid, thread-&gt;pid,
                                                node-&gt;debug_id);
                                        <span class="org-keyword">break</span>;
                                }
                                node-&gt;pending_weak_ref = 0;
                        }
                        binder_dec_node(node, cmd == BC_ACQUIRE_DONE, 0);
                        binder_debug(BINDER_DEBUG_USER_REFS,
                                     <span class="org-string">"binder: %d:%d %s node %d ls %d lw %d\n"</span>,
                                     proc-&gt;pid, thread-&gt;pid,
                                     cmd == BC_INCREFS_DONE ? <span class="org-string">"BC_INCREFS_DONE"</span> : <span class="org-string">"BC_ACQUIRE_DONE"</span>,
                                     node-&gt;debug_id, node-&gt;local_strong_refs, node-&gt;local_weak_refs);
                        <span class="org-keyword">break</span>;
                }
                <span class="org-keyword">case</span> BC_ATTEMPT_ACQUIRE:
                        binder_debug(BINDER_DEBUG_TOP_ERRORS,
                                     <span class="org-string">"binder: BC_ATTEMPT_ACQUIRE not supported\n"</span>);
                        <span class="org-keyword">return</span> -EINVAL;
                <span class="org-keyword">case</span> BC_ACQUIRE_RESULT:
                        binder_debug(BINDER_DEBUG_TOP_ERRORS,
                                     <span class="org-string">"binder: BC_ACQUIRE_RESULT not supported\n"</span>);
                        <span class="org-keyword">return</span> -EINVAL;

                <span class="org-keyword">case</span> BC_FREE_BUFFER: {
                        <span class="org-type">void</span> <span class="org-variable-name">__user</span> *data_ptr;
                        <span class="org-keyword">struct</span> <span class="org-type">binder_buffer</span> *<span class="org-variable-name">buffer</span>;

                        <span class="org-keyword">if</span> (get_user(data_ptr, (<span class="org-type">void</span> * <span class="org-variable-name">__user</span> *)ptr))
                                <span class="org-keyword">return</span> -EFAULT;
                        ptr += <span class="org-keyword">sizeof</span>(<span class="org-type">void</span> *);

                        buffer = binder_buffer_lookup(proc, data_ptr);
                        <span class="org-keyword">if</span> (buffer == <span class="org-constant">NULL</span>) {
                                binder_user_error(<span class="org-string">"binder: %d:%d "</span>
                                        <span class="org-string">"BC_FREE_BUFFER u%p no match\n"</span>,
                                        proc-&gt;pid, thread-&gt;pid, data_ptr);
                                <span class="org-keyword">break</span>;
                        }
                        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>buffer-&gt;allow_user_free) {
                                binder_user_error(<span class="org-string">"binder: %d:%d "</span>
                                        <span class="org-string">"BC_FREE_BUFFER u%p matched "</span>
                                        <span class="org-string">"unreturned buffer\n"</span>,
                                        proc-&gt;pid, thread-&gt;pid, data_ptr);
                                <span class="org-keyword">break</span>;
                        }
                        binder_debug(BINDER_DEBUG_FREE_BUFFER,
                                     <span class="org-string">"binder: %d:%d BC_FREE_BUFFER u%p found buffer %d for %s transaction\n"</span>,
                                     proc-&gt;pid, thread-&gt;pid, data_ptr, buffer-&gt;debug_id,
                                     buffer-&gt;transaction ? <span class="org-string">"active"</span> : <span class="org-string">"finished"</span>);

                        <span class="org-keyword">if</span> (buffer-&gt;transaction) {
                                buffer-&gt;transaction-&gt;buffer = <span class="org-constant">NULL</span>;
                                buffer-&gt;transaction = <span class="org-constant">NULL</span>;
                        }
                        <span class="org-keyword">if</span> (buffer-&gt;async_transaction &amp;&amp; buffer-&gt;target_node) {
                                BUG_ON(<span class="org-negation-char">!</span>buffer-&gt;target_node-&gt;has_async_transaction);
                                <span class="org-keyword">if</span> (list_empty(&amp;buffer-&gt;target_node-&gt;async_todo))
                                        buffer-&gt;target_node-&gt;has_async_transaction = 0;
                                <span class="org-keyword">else</span>
                                        list_move_tail(buffer-&gt;target_node-&gt;async_todo.next, &amp;thread-&gt;todo);
                        }
                        binder_transaction_buffer_release(proc, buffer, <span class="org-constant">NULL</span>);
                        binder_free_buf(proc, buffer);
                        <span class="org-keyword">break</span>;
                }

                <span class="org-keyword">case</span> BC_TRANSACTION:
                <span class="org-keyword">case</span> BC_REPLY: {
                        <span class="org-keyword">struct</span> <span class="org-type">binder_transaction_data</span> <span class="org-variable-name">tr</span>;

                        <span class="org-keyword">if</span> (copy_from_user(&amp;tr, ptr, <span class="org-keyword">sizeof</span>(tr)))
                                <span class="org-keyword">return</span> -EFAULT;
                        ptr += <span class="org-keyword">sizeof</span>(tr);
                        binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);
                        <span class="org-keyword">break</span>;
                }

                <span class="org-keyword">case</span> BC_REGISTER_LOOPER:
                        binder_debug(BINDER_DEBUG_THREADS,
                                     <span class="org-string">"binder: %d:%d BC_REGISTER_LOOPER\n"</span>,
                                     proc-&gt;pid, thread-&gt;pid);
                        <span class="org-keyword">if</span> (thread-&gt;looper &amp; BINDER_LOOPER_STATE_ENTERED) {
                                thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;
                                binder_user_error(<span class="org-string">"binder: %d:%d ERROR:"</span>
                                        <span class="org-string">" BC_REGISTER_LOOPER called "</span>
                                        <span class="org-string">"after BC_ENTER_LOOPER\n"</span>,
                                        proc-&gt;pid, thread-&gt;pid);
                        } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (proc-&gt;requested_threads == 0) {
                                thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;
                                binder_user_error(<span class="org-string">"binder: %d:%d ERROR:"</span>
                                        <span class="org-string">" BC_REGISTER_LOOPER called "</span>
                                        <span class="org-string">"without request\n"</span>,
                                        proc-&gt;pid, thread-&gt;pid);
                        } <span class="org-keyword">else</span> {
                                proc-&gt;requested_threads--;
                                proc-&gt;requested_threads_started++;
                        }
                        thread-&gt;looper |= BINDER_LOOPER_STATE_REGISTERED;
                        <span class="org-keyword">break</span>;
                <span class="org-keyword">case</span> BC_ENTER_LOOPER:
                        binder_debug(BINDER_DEBUG_THREADS,
                                     <span class="org-string">"binder: %d:%d BC_ENTER_LOOPER\n"</span>,
                                     proc-&gt;pid, thread-&gt;pid);
                        <span class="org-keyword">if</span> (thread-&gt;looper &amp; BINDER_LOOPER_STATE_REGISTERED) {
                                thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;
                                binder_user_error(<span class="org-string">"binder: %d:%d ERROR:"</span>
                                        <span class="org-string">" BC_ENTER_LOOPER called after "</span>
                                        <span class="org-string">"BC_REGISTER_LOOPER\n"</span>,
                                        proc-&gt;pid, thread-&gt;pid);
                        }
                        thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED;
                        <span class="org-keyword">break</span>;
                <span class="org-keyword">case</span> BC_EXIT_LOOPER:
                        binder_debug(BINDER_DEBUG_THREADS,
                                     <span class="org-string">"binder: %d:%d BC_EXIT_LOOPER\n"</span>,
                                     proc-&gt;pid, thread-&gt;pid);
                        thread-&gt;looper |= BINDER_LOOPER_STATE_EXITED;
                        <span class="org-keyword">break</span>;

                <span class="org-keyword">case</span> BC_REQUEST_DEATH_NOTIFICATION:
                <span class="org-keyword">case</span> BC_CLEAR_DEATH_NOTIFICATION: {
                        <span class="org-type">uint32_t</span> <span class="org-variable-name">target</span>;
                        <span class="org-type">void</span> <span class="org-variable-name">__user</span> *cookie;
                        <span class="org-keyword">struct</span> <span class="org-type">binder_ref</span> *<span class="org-variable-name">ref</span>;
                        <span class="org-keyword">struct</span> <span class="org-type">binder_ref_death</span> *<span class="org-variable-name">death</span>;

                        <span class="org-keyword">if</span> (get_user(target, (uint32_t <span class="org-type">__user</span> *)ptr))
                                <span class="org-keyword">return</span> -EFAULT;
                        ptr += <span class="org-keyword">sizeof</span>(uint32_t);
                        <span class="org-keyword">if</span> (get_user(cookie, (<span class="org-type">void</span> <span class="org-variable-name">__user</span> * __user *)ptr))
                                <span class="org-keyword">return</span> -EFAULT;
                        ptr += <span class="org-keyword">sizeof</span>(<span class="org-type">void</span> *);
                        ref = binder_get_ref(proc, target);
                        <span class="org-keyword">if</span> (ref == <span class="org-constant">NULL</span>) {
                                binder_user_error(<span class="org-string">"binder: %d:%d %s "</span>
                                        <span class="org-string">"invalid ref %d\n"</span>,
                                        proc-&gt;pid, thread-&gt;pid,
                                        cmd == BC_REQUEST_DEATH_NOTIFICATION ?
                                        <span class="org-string">"BC_REQUEST_DEATH_NOTIFICATION"</span> :
                                        <span class="org-string">"BC_CLEAR_DEATH_NOTIFICATION"</span>,
                                        target);
                                <span class="org-keyword">break</span>;
                        }

                        binder_debug(BINDER_DEBUG_DEATH_NOTIFICATION,
                                     <span class="org-string">"binder: %d:%d %s %p ref %d desc %d s %d w %d for node %d\n"</span>,
                                     proc-&gt;pid, thread-&gt;pid,
                                     cmd == BC_REQUEST_DEATH_NOTIFICATION ?
                                     <span class="org-string">"BC_REQUEST_DEATH_NOTIFICATION"</span> :
                                     <span class="org-string">"BC_CLEAR_DEATH_NOTIFICATION"</span>,
                                     cookie, ref-&gt;debug_id, ref-&gt;desc,
                                     ref-&gt;strong, ref-&gt;weak, ref-&gt;node-&gt;debug_id);

                        <span class="org-keyword">if</span> (cmd == BC_REQUEST_DEATH_NOTIFICATION) {
                                <span class="org-keyword">if</span> (ref-&gt;death) {
                                        binder_user_error(<span class="org-string">"binder: %d:%"</span>
                                                <span class="org-string">"d BC_REQUEST_DEATH_NOTI"</span>
                                                <span class="org-string">"FICATION death notific"</span>
                                                <span class="org-string">"ation already set\n"</span>,
                                                proc-&gt;pid, thread-&gt;pid);
                                        <span class="org-keyword">break</span>;
                                }
                                death = kzalloc(<span class="org-keyword">sizeof</span>(*death), GFP_KERNEL);
                                <span class="org-keyword">if</span> (death == <span class="org-constant">NULL</span>) {
                                        thread-&gt;return_error = BR_ERROR;
                                        binder_debug(BINDER_DEBUG_FAILED_TRANSACTION,
                                                     <span class="org-string">"binder: %d:%d "</span>
                                                     <span class="org-string">"BC_REQUEST_DEATH_NOTIFICATION failed\n"</span>,
                                                     proc-&gt;pid, thread-&gt;pid);
                                        <span class="org-keyword">break</span>;
                                }
                                binder_stats_created(BINDER_STAT_DEATH);
                                INIT_LIST_HEAD(&amp;death-&gt;work.entry);
                                death-&gt;cookie = cookie;
                                ref-&gt;death = death;
                                <span class="org-keyword">if</span> (ref-&gt;node-&gt;proc == <span class="org-constant">NULL</span>) {
                                        ref-&gt;death-&gt;work.type = BINDER_WORK_DEAD_BINDER;
                                        <span class="org-keyword">if</span> (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) {
                                                list_add_tail(&amp;ref-&gt;death-&gt;work.entry, &amp;thread-&gt;todo);
                                        } <span class="org-keyword">else</span> {
                                                list_add_tail(&amp;ref-&gt;death-&gt;work.entry, &amp;proc-&gt;todo);
                                                wake_up_interruptible(&amp;proc-&gt;wait);
                                        }
                                }
                        } <span class="org-keyword">else</span> {
                                <span class="org-keyword">if</span> (ref-&gt;death == <span class="org-constant">NULL</span>) {
                                        binder_user_error(<span class="org-string">"binder: %d:%"</span>
                                                <span class="org-string">"d BC_CLEAR_DEATH_NOTIFI"</span>
                                                <span class="org-string">"CATION death notificat"</span>
                                                <span class="org-string">"ion not active\n"</span>,
                                                proc-&gt;pid, thread-&gt;pid);
                                        <span class="org-keyword">break</span>;
                                }
                                death = ref-&gt;death;
                                <span class="org-keyword">if</span> (death-&gt;cookie != cookie) {
                                        binder_user_error(<span class="org-string">"binder: %d:%"</span>
                                                <span class="org-string">"d BC_CLEAR_DEATH_NOTIFI"</span>
                                                <span class="org-string">"CATION death notificat"</span>
                                                <span class="org-string">"ion cookie mismatch "</span>
                                                <span class="org-string">"%p != %p\n"</span>,
                                                proc-&gt;pid, thread-&gt;pid,
                                                death-&gt;cookie, cookie);
                                        <span class="org-keyword">break</span>;
                                }
                                ref-&gt;death = <span class="org-constant">NULL</span>;
                                <span class="org-keyword">if</span> (list_empty(&amp;death-&gt;work.entry)) {
                                        death-&gt;work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION;
                                        <span class="org-keyword">if</span> (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) {
                                                list_add_tail(&amp;death-&gt;work.entry, &amp;thread-&gt;todo);
                                        } <span class="org-keyword">else</span> {
                                                list_add_tail(&amp;death-&gt;work.entry, &amp;proc-&gt;todo);
                                                wake_up_interruptible(&amp;proc-&gt;wait);
                                        }
                                } <span class="org-keyword">else</span> {
                                        BUG_ON(death-&gt;work.type != BINDER_WORK_DEAD_BINDER);
                                        death-&gt;work.type = BINDER_WORK_DEAD_BINDER_AND_CLEAR;
                                }
                        }
                } <span class="org-keyword">break</span>;
                <span class="org-keyword">case</span> BC_DEAD_BINDER_DONE: {
                        <span class="org-keyword">struct</span> <span class="org-type">binder_work</span> *<span class="org-variable-name">w</span>;
                        <span class="org-type">void</span> <span class="org-variable-name">__user</span> *cookie;
                        <span class="org-keyword">struct</span> <span class="org-type">binder_ref_death</span> *<span class="org-variable-name">death</span> = <span class="org-constant">NULL</span>;
                        <span class="org-keyword">if</span> (get_user(cookie, (<span class="org-type">void</span> <span class="org-variable-name">__user</span> * __user *)ptr))
                                <span class="org-keyword">return</span> -EFAULT;

                        ptr += <span class="org-keyword">sizeof</span>(<span class="org-type">void</span> *);
                        <span class="org-variable-name">list_for_each_entry</span>(w, &amp;proc-&gt;delivered_death, entry) {
                                <span class="org-keyword">struct</span> <span class="org-type">binder_ref_death</span> *<span class="org-variable-name">tmp_death</span> = container_of(w, <span class="org-keyword">struct</span> <span class="org-type">binder_ref_death</span>, work);
                                <span class="org-keyword">if</span> (tmp_death-&gt;cookie == cookie) {
                                        death = tmp_death;
                                        <span class="org-keyword">break</span>;
                                }
                        }
                        binder_debug(BINDER_DEBUG_DEAD_BINDER,
                                     <span class="org-string">"binder: %d:%d BC_DEAD_BINDER_DONE %p found %p\n"</span>,
                                     proc-&gt;pid, thread-&gt;pid, cookie, death);
                        <span class="org-keyword">if</span> (death == <span class="org-constant">NULL</span>) {
                                binder_user_error(<span class="org-string">"binder: %d:%d BC_DEAD"</span>
                                        <span class="org-string">"_BINDER_DONE %p not found\n"</span>,
                                        proc-&gt;pid, thread-&gt;pid, cookie);
                                <span class="org-keyword">break</span>;
                        }

                        list_del_init(&amp;death-&gt;work.entry);
                        <span class="org-keyword">if</span> (death-&gt;work.type == BINDER_WORK_DEAD_BINDER_AND_CLEAR) {
                                death-&gt;work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION;
                                <span class="org-keyword">if</span> (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) {
                                        list_add_tail(&amp;death-&gt;work.entry, &amp;thread-&gt;todo);
                                } <span class="org-keyword">else</span> {
                                        list_add_tail(&amp;death-&gt;work.entry, &amp;proc-&gt;todo);
                                        wake_up_interruptible(&amp;proc-&gt;wait);
                                }
                        }
                } <span class="org-keyword">break</span>;

                <span class="org-keyword">default</span>:
                        binder_debug(BINDER_DEBUG_TOP_ERRORS,
                                     <span class="org-string">"binder: %d:%d unknown command %d\n"</span>,
                                     proc-&gt;pid, thread-&gt;pid, cmd);
                        <span class="org-keyword">return</span> -EINVAL;
                }
                *consumed = ptr - buffer;
        }
        <span class="org-keyword">return</span> 0;
}
</pre>
</div>
</div>
<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> <span class="todo TODO">TODO</span> 把binder底下的各个数据结构搞清楚，每个成员变量都是干什么用的。</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>State "TODO"       from ""           <span class="timestamp-wrapper"><span class="timestamp">[2014-07-30 Wed 18:26]</span></span>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> <span class="todo TODO">TODO</span> 为什么要 binder_set_nice</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>State "TODO"       from ""           <span class="timestamp-wrapper"><span class="timestamp">[2014-07-30 Wed 20:19]</span></span>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> binder_transaction 函数</h3>
<div class="outline-text-3" id="text-2-3">
<div class="org-src-container">

<pre class="src src-c"><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">binder_transaction</span>(<span class="org-keyword">struct</span> <span class="org-type">binder_proc</span> *<span class="org-variable-name">proc</span>,
                               <span class="org-keyword">struct</span> <span class="org-type">binder_thread</span> *<span class="org-variable-name">thread</span>,
                               <span class="org-keyword">struct</span> <span class="org-type">binder_transaction_data</span> *<span class="org-variable-name">tr</span>, <span class="org-type">int</span> <span class="org-variable-name">reply</span>)
{
        <span class="org-keyword">struct</span> <span class="org-type">binder_transaction</span> *<span class="org-variable-name">t</span>;
        <span class="org-keyword">struct</span> <span class="org-type">binder_work</span> *<span class="org-variable-name">tcomplete</span>;
        <span class="org-type">size_t</span> *<span class="org-variable-name">offp</span>, *<span class="org-variable-name">off_end</span>;
        <span class="org-keyword">struct</span> <span class="org-type">binder_proc</span> *<span class="org-variable-name">target_proc</span>;
        <span class="org-keyword">struct</span> <span class="org-type">binder_thread</span> *<span class="org-variable-name">target_thread</span> = <span class="org-constant">NULL</span>;
        <span class="org-keyword">struct</span> <span class="org-type">binder_node</span> *<span class="org-variable-name">target_node</span> = <span class="org-constant">NULL</span>;
        <span class="org-keyword">struct</span> <span class="org-type">list_head</span> *<span class="org-variable-name">target_list</span>;
        <span class="org-type">wait_queue_head_t</span> *<span class="org-variable-name">target_wait</span>;
        <span class="org-keyword">struct</span> <span class="org-type">binder_transaction</span> *<span class="org-variable-name">in_reply_to</span> = <span class="org-constant">NULL</span>;
        <span class="org-keyword">struct</span> <span class="org-type">binder_transaction_log_entry</span> *<span class="org-variable-name">e</span>;
        <span class="org-type">uint32_t</span> <span class="org-variable-name">return_error</span>;

        e = binder_transaction_log_add(&amp;binder_transaction_log);
        e-&gt;call_type = reply ? 2 : <span class="org-negation-char">!</span>!(tr-&gt;flags &amp; TF_ONE_WAY);
        e-&gt;from_proc = proc-&gt;pid;
        e-&gt;from_thread = thread-&gt;pid;
        e-&gt;target_handle = tr-&gt;target.handle;
        e-&gt;data_size = tr-&gt;data_size;
        e-&gt;offsets_size = tr-&gt;offsets_size;

        <span class="org-keyword">if</span> (reply) {
                in_reply_to = thread-&gt;transaction_stack;
                <span class="org-keyword">if</span> (in_reply_to == <span class="org-constant">NULL</span>) {
                        binder_user_error(<span class="org-string">"binder: %d:%d got reply transaction "</span>
                                          <span class="org-string">"with no transaction stack\n"</span>,
                                          proc-&gt;pid, thread-&gt;pid);
                        return_error = BR_FAILED_REPLY;
                        <span class="org-keyword">goto</span> <span class="org-constant">err_empty_call_stack</span>;
                }
                binder_set_nice(in_reply_to-&gt;saved_priority);
                <span class="org-keyword">if</span> (in_reply_to-&gt;to_thread != thread) {
                        binder_user_error(<span class="org-string">"binder: %d:%d got reply transaction "</span>
                                <span class="org-string">"with bad transaction stack,"</span>
                                <span class="org-string">" transaction %d has target %d:%d\n"</span>,
                                proc-&gt;pid, thread-&gt;pid, in_reply_to-&gt;debug_id,
                                in_reply_to-&gt;to_proc ?
                                in_reply_to-&gt;to_proc-&gt;pid : 0,
                                in_reply_to-&gt;to_thread ?
                                in_reply_to-&gt;to_thread-&gt;pid : 0);
                        return_error = BR_FAILED_REPLY;
                        in_reply_to = <span class="org-constant">NULL</span>;
                        <span class="org-keyword">goto</span> <span class="org-constant">err_bad_call_stack</span>;
                }
                thread-&gt;transaction_stack = in_reply_to-&gt;to_parent;
                target_thread = in_reply_to-&gt;from;
                <span class="org-keyword">if</span> (target_thread == <span class="org-constant">NULL</span>) {
                        return_error = BR_DEAD_REPLY;
                        <span class="org-keyword">goto</span> <span class="org-constant">err_dead_binder</span>;
                }
                <span class="org-keyword">if</span> (target_thread-&gt;transaction_stack != in_reply_to) {
                        binder_user_error(<span class="org-string">"binder: %d:%d got reply transaction "</span>
                                <span class="org-string">"with bad target transaction stack %d, "</span>
                                <span class="org-string">"expected %d\n"</span>,
                                proc-&gt;pid, thread-&gt;pid,
                                target_thread-&gt;transaction_stack ?
                                target_thread-&gt;transaction_stack-&gt;debug_id : 0,
                                in_reply_to-&gt;debug_id);
                        return_error = BR_FAILED_REPLY;
                        in_reply_to = <span class="org-constant">NULL</span>;
                        target_thread = <span class="org-constant">NULL</span>;
                        <span class="org-keyword">goto</span> <span class="org-constant">err_dead_binder</span>;
                }
                target_proc = target_thread-&gt;proc;
        } <span class="org-keyword">else</span> {
                <span class="org-keyword">if</span> (tr-&gt;target.handle) {
                        <span class="org-keyword">struct</span> <span class="org-type">binder_ref</span> *<span class="org-variable-name">ref</span>;
                        ref = binder_get_ref(proc, tr-&gt;target.handle);
                        <span class="org-keyword">if</span> (ref == <span class="org-constant">NULL</span>) {
                                binder_user_error(<span class="org-string">"binder: %d:%d got "</span>
                                        <span class="org-string">"transaction to invalid handle\n"</span>,
                                        proc-&gt;pid, thread-&gt;pid);
                                return_error = BR_FAILED_REPLY;
                                <span class="org-keyword">goto</span> <span class="org-constant">err_invalid_target_handle</span>;
                        }
                        target_node = ref-&gt;node;
                } <span class="org-keyword">else</span> {
                        target_node = binder_context_mgr_node;
                        <span class="org-keyword">if</span> (target_node == <span class="org-constant">NULL</span>) {
                                return_error = BR_DEAD_REPLY;
                                <span class="org-keyword">goto</span> <span class="org-constant">err_no_context_mgr_node</span>;
                        }
                }
                e-&gt;to_node = target_node-&gt;debug_id;
                target_proc = target_node-&gt;proc;
                <span class="org-keyword">if</span> (target_proc == <span class="org-constant">NULL</span>) {
                        return_error = BR_DEAD_REPLY;
                        <span class="org-keyword">goto</span> <span class="org-constant">err_dead_binder</span>;
                }
                <span class="org-keyword">if</span> (security_binder_transaction(proc-&gt;tsk, target_proc-&gt;tsk) &lt; 0) {
                        return_error = BR_FAILED_REPLY;
                        <span class="org-keyword">goto</span> <span class="org-constant">err_invalid_target_handle</span>;
                }
                <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>(tr-&gt;flags &amp; TF_ONE_WAY) &amp;&amp; thread-&gt;transaction_stack) {
                        <span class="org-keyword">struct</span> <span class="org-type">binder_transaction</span> *<span class="org-variable-name">tmp</span>;
                        tmp = thread-&gt;transaction_stack;
                        <span class="org-keyword">if</span> (tmp-&gt;to_thread != thread) {
                                binder_user_error(<span class="org-string">"binder: %d:%d got new "</span>
                                        <span class="org-string">"transaction with bad transaction stack"</span>
                                        <span class="org-string">", transaction %d has target %d:%d\n"</span>,
                                        proc-&gt;pid, thread-&gt;pid, tmp-&gt;debug_id,
                                        tmp-&gt;to_proc ? tmp-&gt;to_proc-&gt;pid : 0,
                                        tmp-&gt;to_thread ?
                                        tmp-&gt;to_thread-&gt;pid : 0);
                                return_error = BR_FAILED_REPLY;
                                <span class="org-keyword">goto</span> <span class="org-constant">err_bad_call_stack</span>;
                        }
                        <span class="org-keyword">while</span> (tmp) {
                                <span class="org-keyword">if</span> (tmp-&gt;from &amp;&amp; tmp-&gt;from-&gt;proc == target_proc)
                                        target_thread = tmp-&gt;from;
                                tmp = tmp-&gt;from_parent;
                        }
                }
        }
        <span class="org-keyword">if</span> (target_thread) {
                e-&gt;to_thread = target_thread-&gt;pid;
                target_list = &amp;target_thread-&gt;todo;
                target_wait = &amp;target_thread-&gt;wait;
        } <span class="org-keyword">else</span> {
                target_list = &amp;target_proc-&gt;todo;
                target_wait = &amp;target_proc-&gt;wait;
        }
        e-&gt;to_proc = target_proc-&gt;pid;

        <span class="org-comment-delimiter">/* </span><span class="org-comment">TODO: reuse incoming transaction for reply </span><span class="org-comment-delimiter">*/</span>
        t = kzalloc(<span class="org-keyword">sizeof</span>(*t), GFP_KERNEL);
        <span class="org-keyword">if</span> (t == <span class="org-constant">NULL</span>) {
                return_error = BR_FAILED_REPLY;
                <span class="org-keyword">goto</span> <span class="org-constant">err_alloc_t_failed</span>;
        }
        binder_stats_created(BINDER_STAT_TRANSACTION);

        tcomplete = kzalloc(<span class="org-keyword">sizeof</span>(*tcomplete), GFP_KERNEL);
        <span class="org-keyword">if</span> (tcomplete == <span class="org-constant">NULL</span>) {
                return_error = BR_FAILED_REPLY;
                <span class="org-keyword">goto</span> <span class="org-constant">err_alloc_tcomplete_failed</span>;
        }
        binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE);

        t-&gt;debug_id = ++binder_last_id;
        e-&gt;debug_id = t-&gt;debug_id;

        <span class="org-keyword">if</span> (reply)
                binder_debug(BINDER_DEBUG_TRANSACTION,
                             <span class="org-string">"binder: %d:%d BC_REPLY %d -&gt; %d:%d, "</span>
                             <span class="org-string">"data %p-%p size %zd-%zd\n"</span>,
                             proc-&gt;pid, thread-&gt;pid, t-&gt;debug_id,
                             target_proc-&gt;pid, target_thread-&gt;pid,
                             tr-&gt;data.ptr.buffer, tr-&gt;data.ptr.offsets,
                             tr-&gt;data_size, tr-&gt;offsets_size);
        <span class="org-keyword">else</span>
                binder_debug(BINDER_DEBUG_TRANSACTION,
                             <span class="org-string">"binder: %d:%d BC_TRANSACTION %d -&gt; "</span>
                             <span class="org-string">"%d - node %d, data %p-%p size %zd-%zd\n"</span>,
                             proc-&gt;pid, thread-&gt;pid, t-&gt;debug_id,
                             target_proc-&gt;pid, target_node-&gt;debug_id,
                             tr-&gt;data.ptr.buffer, tr-&gt;data.ptr.offsets,
                             tr-&gt;data_size, tr-&gt;offsets_size);

        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>reply &amp;&amp; <span class="org-negation-char">!</span>(tr-&gt;flags &amp; TF_ONE_WAY))
                t-&gt;from = thread;
        <span class="org-keyword">else</span>
                t-&gt;from = <span class="org-constant">NULL</span>;
        t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid;
        t-&gt;to_proc = target_proc;
        t-&gt;to_thread = target_thread;
        t-&gt;code = tr-&gt;code;
        t-&gt;flags = tr-&gt;flags;
        t-&gt;priority = task_nice(current);
        t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,
                tr-&gt;offsets_size, <span class="org-negation-char">!</span>reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));
        <span class="org-keyword">if</span> (t-&gt;buffer == <span class="org-constant">NULL</span>) {
                return_error = BR_FAILED_REPLY;
                <span class="org-keyword">goto</span> <span class="org-constant">err_binder_alloc_buf_failed</span>;
        }
        t-&gt;buffer-&gt;allow_user_free = 0;
        t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;
        t-&gt;buffer-&gt;transaction = t;
        t-&gt;buffer-&gt;target_node = target_node;
        <span class="org-keyword">if</span> (target_node)
                binder_inc_node(target_node, 1, 0, <span class="org-constant">NULL</span>);

        offp = (<span class="org-type">size_t</span> *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, <span class="org-keyword">sizeof</span>(<span class="org-type">void</span> *)));

        <span class="org-keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) {
                binder_user_error(<span class="org-string">"binder: %d:%d got transaction with invalid "</span>
                        <span class="org-string">"data ptr\n"</span>, proc-&gt;pid, thread-&gt;pid);
                return_error = BR_FAILED_REPLY;
                <span class="org-keyword">goto</span> <span class="org-constant">err_copy_data_failed</span>;
        }
        <span class="org-keyword">if</span> (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) {
                binder_user_error(<span class="org-string">"binder: %d:%d got transaction with invalid "</span>
                        <span class="org-string">"offsets ptr\n"</span>, proc-&gt;pid, thread-&gt;pid);
                return_error = BR_FAILED_REPLY;
                <span class="org-keyword">goto</span> <span class="org-constant">err_copy_data_failed</span>;
        }
        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>IS_ALIGNED(tr-&gt;offsets_size, <span class="org-keyword">sizeof</span>(size_t))) {
                binder_user_error(<span class="org-string">"binder: %d:%d got transaction with "</span>
                        <span class="org-string">"invalid offsets size, %zd\n"</span>,
                        proc-&gt;pid, thread-&gt;pid, tr-&gt;offsets_size);
                return_error = BR_FAILED_REPLY;
                <span class="org-keyword">goto</span> <span class="org-constant">err_bad_offset</span>;
        }
        off_end = (<span class="org-type">void</span> *)offp + tr-&gt;offsets_size;
        <span class="org-keyword">for</span> (; offp &lt; off_end; offp++) {
                <span class="org-keyword">struct</span> <span class="org-type">flat_binder_object</span> *<span class="org-variable-name">fp</span>;
                <span class="org-keyword">if</span> (*offp &gt; t-&gt;buffer-&gt;data_size - <span class="org-keyword">sizeof</span>(*fp) ||
                    t-&gt;buffer-&gt;data_size &lt; <span class="org-keyword">sizeof</span>(*fp) ||
                    <span class="org-negation-char">!</span>IS_ALIGNED(*offp, <span class="org-keyword">sizeof</span>(<span class="org-type">void</span> *))) {
                        binder_user_error(<span class="org-string">"binder: %d:%d got transaction with "</span>
                                <span class="org-string">"invalid offset, %zd\n"</span>,
                                proc-&gt;pid, thread-&gt;pid, *offp);
                        return_error = BR_FAILED_REPLY;
                        <span class="org-keyword">goto</span> <span class="org-constant">err_bad_offset</span>;
                }
                fp = (<span class="org-keyword">struct</span> <span class="org-type">flat_binder_object</span> *)(t-&gt;buffer-&gt;data + *offp);
                <span class="org-keyword">switch</span> (fp-&gt;type) {
                <span class="org-keyword">case</span> BINDER_TYPE_BINDER:
                <span class="org-keyword">case</span> BINDER_TYPE_WEAK_BINDER: {
                        <span class="org-keyword">struct</span> <span class="org-type">binder_ref</span> *<span class="org-variable-name">ref</span>;
                        <span class="org-keyword">struct</span> <span class="org-type">binder_node</span> *<span class="org-variable-name">node</span> = binder_get_node(proc, fp-&gt;binder);
                        <span class="org-keyword">if</span> (node == <span class="org-constant">NULL</span>) {
                                node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie);
                                <span class="org-keyword">if</span> (node == <span class="org-constant">NULL</span>) {
                                        return_error = BR_FAILED_REPLY;
                                        <span class="org-keyword">goto</span> <span class="org-constant">err_binder_new_node_failed</span>;
                                }
                                node-&gt;min_priority = fp-&gt;flags &amp; FLAT_BINDER_FLAG_PRIORITY_MASK;
                                node-&gt;accept_fds = <span class="org-negation-char">!</span>!(fp-&gt;flags &amp; FLAT_BINDER_FLAG_ACCEPTS_FDS);
                        }
                        <span class="org-keyword">if</span> (fp-&gt;cookie != node-&gt;cookie) {
                                binder_user_error(<span class="org-string">"binder: %d:%d sending u%p "</span>
                                        <span class="org-string">"node %d, cookie mismatch %p != %p\n"</span>,
                                        proc-&gt;pid, thread-&gt;pid,
                                        fp-&gt;binder, node-&gt;debug_id,
                                        fp-&gt;cookie, node-&gt;cookie);
                                <span class="org-keyword">goto</span> <span class="org-constant">err_binder_get_ref_for_node_failed</span>;
                        }
                        <span class="org-keyword">if</span> (security_binder_transfer_binder(proc-&gt;tsk, target_proc-&gt;tsk)) {
                                return_error = BR_FAILED_REPLY;
                                <span class="org-keyword">goto</span> <span class="org-constant">err_binder_get_ref_for_node_failed</span>;
                        }
                        ref = binder_get_ref_for_node(target_proc, node);
                        <span class="org-keyword">if</span> (ref == <span class="org-constant">NULL</span>) {
                                return_error = BR_FAILED_REPLY;
                                <span class="org-keyword">goto</span> <span class="org-constant">err_binder_get_ref_for_node_failed</span>;
                        }
                        <span class="org-keyword">if</span> (fp-&gt;type == BINDER_TYPE_BINDER)
                                fp-&gt;type = BINDER_TYPE_HANDLE;
                        <span class="org-keyword">else</span>
                                fp-&gt;type = BINDER_TYPE_WEAK_HANDLE;
                        fp-&gt;handle = ref-&gt;desc;
                        binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE,
                                       &amp;thread-&gt;todo);

                        binder_debug(BINDER_DEBUG_TRANSACTION,
                                     <span class="org-string">"        node %d u%p -&gt; ref %d desc %d\n"</span>,
                                     node-&gt;debug_id, node-&gt;ptr, ref-&gt;debug_id,
                                     ref-&gt;desc);
                } <span class="org-keyword">break</span>;
                <span class="org-keyword">case</span> BINDER_TYPE_HANDLE:
                <span class="org-keyword">case</span> BINDER_TYPE_WEAK_HANDLE: {
                        <span class="org-keyword">struct</span> <span class="org-type">binder_ref</span> *<span class="org-variable-name">ref</span> = binder_get_ref(proc, fp-&gt;handle);
                        <span class="org-keyword">if</span> (ref == <span class="org-constant">NULL</span>) {
                                binder_user_error(<span class="org-string">"binder: %d:%d got "</span>
                                        <span class="org-string">"transaction with invalid "</span>
                                        <span class="org-string">"handle, %ld\n"</span>, proc-&gt;pid,
                                        thread-&gt;pid, fp-&gt;handle);
                                return_error = BR_FAILED_REPLY;
                                <span class="org-keyword">goto</span> <span class="org-constant">err_binder_get_ref_failed</span>;
                        }
                        <span class="org-keyword">if</span> (security_binder_transfer_binder(proc-&gt;tsk, target_proc-&gt;tsk)) {
                                return_error = BR_FAILED_REPLY;
                                <span class="org-keyword">goto</span> <span class="org-constant">err_binder_get_ref_failed</span>;
                        }
                        <span class="org-keyword">if</span> (ref-&gt;node-&gt;proc == target_proc) {
                                <span class="org-keyword">if</span> (fp-&gt;type == BINDER_TYPE_HANDLE)
                                        fp-&gt;type = BINDER_TYPE_BINDER;
                                <span class="org-keyword">else</span>
                                        fp-&gt;type = BINDER_TYPE_WEAK_BINDER;
                                fp-&gt;binder = ref-&gt;node-&gt;ptr;
                                fp-&gt;cookie = ref-&gt;node-&gt;cookie;
                                binder_inc_node(ref-&gt;node, fp-&gt;type == BINDER_TYPE_BINDER, 0, <span class="org-constant">NULL</span>);
                                binder_debug(BINDER_DEBUG_TRANSACTION,
                                             <span class="org-string">"        ref %d desc %d -&gt; node %d u%p\n"</span>,
                                             ref-&gt;debug_id, ref-&gt;desc, ref-&gt;node-&gt;debug_id,
                                             ref-&gt;node-&gt;ptr);
                        } <span class="org-keyword">else</span> {
                                <span class="org-keyword">struct</span> <span class="org-type">binder_ref</span> *<span class="org-variable-name">new_ref</span>;
                                new_ref = binder_get_ref_for_node(target_proc, ref-&gt;node);
                                <span class="org-keyword">if</span> (new_ref == <span class="org-constant">NULL</span>) {
                                        return_error = BR_FAILED_REPLY;
                                        <span class="org-keyword">goto</span> <span class="org-constant">err_binder_get_ref_for_node_failed</span>;
                                }
                                fp-&gt;handle = new_ref-&gt;desc;
                                binder_inc_ref(new_ref, fp-&gt;type == BINDER_TYPE_HANDLE, <span class="org-constant">NULL</span>);
                                binder_debug(BINDER_DEBUG_TRANSACTION,
                                             <span class="org-string">"        ref %d desc %d -&gt; ref %d desc %d (node %d)\n"</span>,
                                             ref-&gt;debug_id, ref-&gt;desc, new_ref-&gt;debug_id,
                                             new_ref-&gt;desc, ref-&gt;node-&gt;debug_id);
                        }
                } <span class="org-keyword">break</span>;

                <span class="org-keyword">case</span> BINDER_TYPE_FD: {
                        <span class="org-type">int</span> <span class="org-variable-name">target_fd</span>;
                        <span class="org-keyword">struct</span> <span class="org-type">file</span> *<span class="org-variable-name">file</span>;

                        <span class="org-keyword">if</span> (reply) {
                                <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>(in_reply_to-&gt;flags &amp; TF_ACCEPT_FDS)) {
                                        binder_user_error(<span class="org-string">"binder: %d:%d got reply with fd, %ld, but target does not allow fds\n"</span>,
                                                proc-&gt;pid, thread-&gt;pid, fp-&gt;handle);
                                        return_error = BR_FAILED_REPLY;
                                        <span class="org-keyword">goto</span> <span class="org-constant">err_fd_not_allowed</span>;
                                }
                        } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>target_node-&gt;accept_fds) {
                                binder_user_error(<span class="org-string">"binder: %d:%d got transaction with fd, %ld, but target does not allow fds\n"</span>,
                                        proc-&gt;pid, thread-&gt;pid, fp-&gt;handle);
                                return_error = BR_FAILED_REPLY;
                                <span class="org-keyword">goto</span> <span class="org-constant">err_fd_not_allowed</span>;
                        }

                        file = fget(fp-&gt;handle);
                        <span class="org-keyword">if</span> (file == <span class="org-constant">NULL</span>) {
                                binder_user_error(<span class="org-string">"binder: %d:%d got transaction with invalid fd, %ld\n"</span>,
                                        proc-&gt;pid, thread-&gt;pid, fp-&gt;handle);
                                return_error = BR_FAILED_REPLY;
                                <span class="org-keyword">goto</span> <span class="org-constant">err_fget_failed</span>;
                        }
                        <span class="org-keyword">if</span> (security_binder_transfer_file(proc-&gt;tsk, target_proc-&gt;tsk, file) &lt; 0) {
                                fput(file);
                                return_error = BR_FAILED_REPLY;
                                <span class="org-keyword">goto</span> <span class="org-constant">err_get_unused_fd_failed</span>;
                        }
                        target_fd = task_get_unused_fd_flags(target_proc, O_CLOEXEC);
                        <span class="org-keyword">if</span> (target_fd &lt; 0) {
                                fput(file);
                                return_error = BR_FAILED_REPLY;
                                <span class="org-keyword">goto</span> <span class="org-constant">err_get_unused_fd_failed</span>;
                        }
                        task_fd_install(target_proc, target_fd, file);
                        binder_debug(BINDER_DEBUG_TRANSACTION,
                                     <span class="org-string">"        fd %ld -&gt; %d\n"</span>, fp-&gt;handle, target_fd);
                        <span class="org-comment-delimiter">/* </span><span class="org-comment">TODO: fput? </span><span class="org-comment-delimiter">*/</span>
                        fp-&gt;handle = target_fd;
                } <span class="org-keyword">break</span>;

                <span class="org-keyword">default</span>:
                        binder_user_error(<span class="org-string">"binder: %d:%d got transactio"</span>
                                <span class="org-string">"n with invalid object type, %lx\n"</span>,
                                proc-&gt;pid, thread-&gt;pid, fp-&gt;type);
                        return_error = BR_FAILED_REPLY;
                        <span class="org-keyword">goto</span> <span class="org-constant">err_bad_object_type</span>;
                }
        }
        <span class="org-keyword">if</span> (reply) {
                BUG_ON(t-&gt;buffer-&gt;async_transaction != 0);
                binder_pop_transaction(target_thread, in_reply_to);
        } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>(t-&gt;flags &amp; TF_ONE_WAY)) {
                BUG_ON(t-&gt;buffer-&gt;async_transaction != 0);
                t-&gt;need_reply = 1;
                t-&gt;from_parent = thread-&gt;transaction_stack;
                thread-&gt;transaction_stack = t;
        } <span class="org-keyword">else</span> {
                BUG_ON(target_node == <span class="org-constant">NULL</span>);
                BUG_ON(t-&gt;buffer-&gt;async_transaction != 1);
                <span class="org-keyword">if</span> (target_node-&gt;has_async_transaction) {
                        target_list = &amp;target_node-&gt;async_todo;
                        target_wait = <span class="org-constant">NULL</span>;
                } <span class="org-keyword">else</span>
                        target_node-&gt;has_async_transaction = 1;
        }
        t-&gt;work.type = BINDER_WORK_TRANSACTION;
        list_add_tail(&amp;t-&gt;work.entry, target_list);
        tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;
        list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);
        <span class="org-keyword">if</span> (target_wait)
                wake_up_interruptible(target_wait);
        <span class="org-keyword">return</span>;

<span class="org-constant">err_get_unused_fd_failed</span>:
<span class="org-constant">err_fget_failed</span>:
<span class="org-constant">err_fd_not_allowed</span>:
<span class="org-constant">err_binder_get_ref_for_node_failed</span>:
<span class="org-constant">err_binder_get_ref_failed</span>:
<span class="org-constant">err_binder_new_node_failed</span>:
<span class="org-constant">err_bad_object_type</span>:
<span class="org-constant">err_bad_offset</span>:
<span class="org-constant">err_copy_data_failed</span>:
        binder_transaction_buffer_release(target_proc, t-&gt;buffer, offp);
        t-&gt;buffer-&gt;transaction = <span class="org-constant">NULL</span>;
        binder_free_buf(target_proc, t-&gt;buffer);
<span class="org-constant">err_binder_alloc_buf_failed</span>:
        kfree(tcomplete);
        binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);
<span class="org-constant">err_alloc_tcomplete_failed</span>:
        kfree(t);
        binder_stats_deleted(BINDER_STAT_TRANSACTION);
<span class="org-constant">err_alloc_t_failed</span>:
<span class="org-constant">err_bad_call_stack</span>:
<span class="org-constant">err_empty_call_stack</span>:
<span class="org-constant">err_dead_binder</span>:
<span class="org-constant">err_invalid_target_handle</span>:
<span class="org-constant">err_no_context_mgr_node</span>:
        binder_debug(BINDER_DEBUG_FAILED_TRANSACTION,
                     <span class="org-string">"binder: %d:%d transaction failed %d, size %zd-%zd\n"</span>,
                     proc-&gt;pid, thread-&gt;pid, return_error,
                     tr-&gt;data_size, tr-&gt;offsets_size);

        {
                <span class="org-keyword">struct</span> <span class="org-type">binder_transaction_log_entry</span> *<span class="org-variable-name">fe</span>;
                fe = binder_transaction_log_add(&amp;binder_transaction_log_failed);
                *fe = *e;
        }

        BUG_ON(thread-&gt;return_error != BR_OK);
        <span class="org-keyword">if</span> (in_reply_to) {
                thread-&gt;return_error = BR_TRANSACTION_COMPLETE;
                binder_send_failed_reply(in_reply_to, return_error);
        } <span class="org-keyword">else</span>
                thread-&gt;return_error = return_error;
}
</pre>
</div>
<p>
这个函数会先把数据从user space拷到kernel space里来。然后，对于数据中的
“对象”，也就是那些Binder/Handle/FileDescriptor进行处理，具体的做法就是，
如果看到一个Binder，就把它改成相应的Handle；看到一个Handle，就把它改成
相应的Binder（Binder Node）。而如果看到一个fd文件描述符的话，就把它从
呼出进程拷贝到呼入进程。通过BinderNode（一个结构体、类、对象？）与
Handle之间相互切换，在呼出进程（调用方、发起方）和呼入进程（被调用方、
接受方）之间建立起了相互的对应关系。这个关系就像tcp/ip里一个ip地址+一
个tpc端口对应着另一端的一个ip地址+一个tcp端口，非常地高大上，是吧！
</p>

<p>
中间会做一系列的错误检测，比如Handle和BinderNode都必须保证是能找得到的，
如果发现找不到的话，就表明出错了。又比如看到fd的话，要检查被调用的
BinderNode是不是接受fd的，有一些Binder的接口根本不涉及到fd，你给它传一
个fd进去，也肯定是出错了。
</p>

<p>
最后，我们看到的那个ioctl还会调用到binder_thread_read，这个函数是会
block的，binder_thread_write函数不会，它把需要工作的内容贴出去就好了。
但如果它需要往回读的话，那一般就要贴出去的工作被处理完了才能返回来数据
以供读取。
</p>

<p>
或者是那种server，那么他一般不会发起bc_transaction，主动给别人写数据，
而是一上来就进入读等待，当有client把工作内容贴过来之后，server可以给一
个br_reply，这样client就只需要读回去，但也有可能server可以贴一个
br_transaction，返回去的数据需要继续进行br_transaction。不管是
bc_transaciton还是br_transaction，它们都会对应一个交易码，通过这个交易
码，最后又会对应到一段可执行的代码，从而达到进程间的代码调用。
</p>

<p>
binder_thread_read函数返回之后，一般会回到 waitForResponse 这个函数里，
它是最普通的进行binder IPC调用的函数。我们看看它如果读到Binder应答会做些什么吧。
</p>

<p>
首先，如果读回来的应答是一个BR_REPLY的话，会读用
reply-&gt;ipcSetDataReference()，这样 <code>reply</code> 这个Parcel就会指向内核传上
来的读据，这块数据所在的buffer是在内核和用户空间里都有映射的，在用户空
间里是一个只读的映射。这样，上层的代码可以读取这个数据，没有问题。
</p>

<p>
然后除了一些特殊情况比如 BR_DEAD_REPLY 之类异常的情况之外，最后代码
default调用了 <code>err = executeCommand(cmd);</code> ，在这个函数里，
BR_TRANSACTION得到了处理：
</p>

<div class="org-src-container">

<pre class="src src-c"><span class="org-keyword">case</span> BR_TRANSACTION:
    {
        <span class="org-type">binder_transaction_data</span> <span class="org-variable-name">tr</span>;
        result = mIn.read(&amp;tr, <span class="org-keyword">sizeof</span>(tr));
        ALOG_ASSERT(result == NO_ERROR,
            <span class="org-string">"Not enough command data for brTRANSACTION"</span>);
        <span class="org-keyword">if</span> (result != NO_ERROR) <span class="org-keyword">break</span>;

        <span class="org-type">Parcel</span> <span class="org-variable-name">buffer</span>;
        buffer.ipcSetDataReference(
            reinterpret_cast&lt;<span class="org-keyword">const</span> uint8_t*&gt;(tr.data.ptr.buffer),
            tr.data_size,
            reinterpret_cast&lt;<span class="org-keyword">const</span> size_t*&gt;(tr.data.ptr.offsets),
            tr.offsets_size/<span class="org-keyword">sizeof</span>(size_t), freeBuffer, this);

        <span class="org-keyword">const</span> <span class="org-type">pid_t</span> <span class="org-variable-name">origPid</span> = mCallingPid;
        <span class="org-keyword">const</span> <span class="org-type">uid_t</span> <span class="org-variable-name">origUid</span> = mCallingUid;

        mCallingPid = tr.sender_pid;
        mCallingUid = tr.sender_euid;

        <span class="org-type">int</span> <span class="org-variable-name">curPrio</span> = getpriority(PRIO_PROCESS, mMyThreadId);
        <span class="org-keyword">if</span> (gDisableBackgroundScheduling) {
            <span class="org-keyword">if</span> (curPrio &gt; ANDROID_PRIORITY_NORMAL) {
                <span class="org-comment-delimiter">// </span><span class="org-comment">We have inherited a reduced priority from the caller, but do not</span>
                <span class="org-comment-delimiter">// </span><span class="org-comment">want to run in that state in this process.  The driver set our</span>
                <span class="org-comment-delimiter">// </span><span class="org-comment">priority already (though not our scheduling class), so bounce</span>
                <span class="org-comment-delimiter">// </span><span class="org-comment">it back to the default before invoking the transaction.</span>
                setpriority(PRIO_PROCESS, mMyThreadId, ANDROID_PRIORITY_NORMAL);
            }
        } <span class="org-keyword">else</span> {
            <span class="org-keyword">if</span> (curPrio &gt;= ANDROID_PRIORITY_BACKGROUND) {
                <span class="org-comment-delimiter">// </span><span class="org-comment">We want to use the inherited priority from the caller.</span>
                <span class="org-comment-delimiter">// </span><span class="org-comment">Ensure this thread is in the background scheduling class,</span>
                <span class="org-comment-delimiter">// </span><span class="org-comment">since the driver won't modify scheduling classes for us.</span>
                <span class="org-comment-delimiter">// </span><span class="org-comment">The scheduling group is reset to default by the caller</span>
                <span class="org-comment-delimiter">// </span><span class="org-comment">once this method returns after the transaction is complete.</span>
                set_sched_policy(mMyThreadId, SP_BACKGROUND);
            }
        }

        <span class="org-comment-delimiter">//</span><span class="org-comment">ALOGI("&gt;&gt;&gt;&gt; TRANSACT from pid %d uid %d\n", mCallingPid, mCallingUid);</span>

        <span class="org-type">Parcel</span> <span class="org-variable-name">reply</span>;
        <span class="org-keyword">if</span> (tr.target.ptr) {
            sp&lt;BBinder&gt; b((<span class="org-type">BBinder</span>*)tr.cookie);
            <span class="org-keyword">const</span> <span class="org-type">status_t</span> <span class="org-variable-name">error</span> = b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);
            <span class="org-keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);

        } <span class="org-keyword">else</span> {
            <span class="org-keyword">const</span> <span class="org-type">status_t</span> <span class="org-variable-name">error</span> = the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);
            <span class="org-keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);
        }

        <span class="org-comment-delimiter">//</span><span class="org-comment">ALOGI("&lt;&lt;&lt;&lt; TRANSACT from pid %d restore pid %d uid %d\n",</span>
        <span class="org-comment-delimiter">//     </span><span class="org-comment">mCallingPid, origPid, origUid);</span>

        <span class="org-keyword">if</span> ((tr.flags &amp; TF_ONE_WAY) == 0) {
            LOG_ONEWAY(<span class="org-string">"Sending reply to %d!"</span>, mCallingPid);
            sendReply(reply, 0);
        } <span class="org-keyword">else</span> {
            LOG_ONEWAY(<span class="org-string">"NOT sending reply to %d!"</span>, mCallingPid);
        }

        mCallingPid = origPid;
        mCallingUid = origUid;

        <span class="org-variable-name">IF_LOG_TRANSACTIONS</span>() {
            TextOutput::Bundle _b(alog);
            alog &lt;&lt; <span class="org-string">"BC_REPLY thr "</span> &lt;&lt; (<span class="org-type">void</span>*)pthread_self() &lt;&lt; <span class="org-string">" / obj "</span>
                &lt;&lt; tr.target.ptr &lt;&lt; <span class="org-string">": "</span> &lt;&lt; indent &lt;&lt; reply &lt;&lt; dedent &lt;&lt; endl;
        }

    }
    <span class="org-keyword">break</span>;
</pre>
</div>
<p>
注意这段代码：
</p>

<div class="org-src-container">

<pre class="src src-c"><span class="org-keyword">if</span> (tr.target.ptr) {
    sp&lt;BBinder&gt; b((<span class="org-type">BBinder</span>*)tr.cookie);
    <span class="org-keyword">const</span> <span class="org-type">status_t</span> <span class="org-variable-name">error</span> = b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);
    <span class="org-keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);

}
</pre>
</div>

<p>
在这里直接把tr.cookie cast成一个BBinder指针了，然后调用它的transact函数：
</p>

<div class="org-src-container">

<pre class="src src-c"><span class="org-type">status_t</span> <span class="org-function-name">BBinder</span>::transact(
    <span class="org-type">uint32_t</span> <span class="org-variable-name">code</span>, <span class="org-keyword">const</span> <span class="org-type">Parcel</span>&amp; data, Parcel* reply, <span class="org-type">uint32_t</span> <span class="org-variable-name">flags</span>)
{
    data.setDataPosition(0);

    <span class="org-type">status_t</span> <span class="org-variable-name">err</span> = NO_ERROR;
    <span class="org-keyword">switch</span> (code) {
        <span class="org-keyword">case</span> PING_TRANSACTION:
            reply-&gt;writeInt32(pingBinder());
            <span class="org-keyword">break</span>;
        <span class="org-keyword">default</span>:
            err = onTransact(code, data, reply, flags);
            <span class="org-keyword">break</span>;
    }

    <span class="org-keyword">if</span> (reply != <span class="org-constant">NULL</span>) {
        reply-&gt;setDataPosition(0);
    }

    <span class="org-keyword">return</span> err;
}
</pre>
</div>

<p>
如果是 PING_TRANSACTION 交易码的话，直接处理了，否则就调用 onTransact
函数，注意这是一个虚函数！所以最后被调用的应该是各个 Binder 服务自己的
交易逻辑，这样我们就回到了 IMountService 的服务处理：
</p>

<p>
哦，请稍等一下， IMountService 它是一个Java的代码，我们需要看一下Java的Binder实现。
</p>

<p>
基本上呢，在JNI里会有一个JavaBBinder，奥妙全在这里面。首先，它实现了一
个onTransact虚函数，在里面它会调用java的Binder对象的 execTransact 私有
函数，这个Java函数的调用接口在Jni初始化的时候保存在了 mExecTransact 里。
最后，这个 execTransact 函数会调用 Java 的 onTransact 函数。
</p>

<p>
好了，代码读到这里，差不多我自己对Binder的实现有了一个比以前更清晰的了
解，您呢？
</p>
<nav>
  <ul id="prev_next_posts">
    <li class="prev_post">
      <a href="../../05/20/0-build-tar-for-android-under-x86-64-debian.html"> <!-- prev-url -->
        <i class="icon-chevron-left">《</i>
        在Debian下为安卓做一个GNU tar程序 <!-- prev-title -->
      </a>
    </li>
    <li class="next_post" style="text-align: right;">
      <a href="../23/0-sending-weixin-weibo-etc-with-emacs-and-smartisa-t1.html"> <!-- next-url -->
        在Linux下用Emacs+Smartisan T1手机发weixin/weibo/qq/email/sms <!-- next-title -->
        <i class="icon-chevron-right">》</i>
      </a>
    </li>
  </ul>
</nav>
</div>
</div>
</div>
</div>
<!-- {%html-mode%} -->

<div id="disqus_container">
  <script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: THIS CODE IS ONLY AN EXAMPLE * * */
    var disqus_shortname = 'baohaojun'; // Required - Replace example with your forum shortname
    var disqus_url = 'http://baohaojun.github.io/blog/2014/06/04/0-binder.html';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
    <div style="margin-bottom:20px">
    <script type="text/javascript" charset="utf-8">
      (function(){
      var _w = 86 , _h = 16;
      var param = {
      url:location.href,
      type:'6',
      count:'', /**是否显示分享数，1显示(可选)*/
      appkey:'', /**您申请的应用appkey,显示分享来源(可选)*/
      title:'', /**分享的文字内容(可选，默认为所在页面的title)*/
      pic:'', /**分享图片的路径(可选)*/
      ralateUid:'1611427581', /**关联用户的UID，分享微博会@该用户(可选)*/
      language:'zh_cn', /**设置语言，zh_cn|zh_tw(可选)*/
      rnd:new Date().valueOf()
      }
      var temp = [];
      for( var p in param ){
      temp.push(p + '=' + encodeURIComponent( param[p] || '' ) )
      }
      document.write('<iframe allowTransparency="true" frameborder="0" scrolling="no" src="http://hits.sinajs.cn/A1/weiboshare.html?' + temp.join('&') + '" width="'+ _w+'" height="'+_h+'"></iframe>')
      })()
    </script>
  </div>
  <div id="disqus_thread"></div>
</div>

</div> <!-- bhj_leftpane -->
<div id="sidebar"><div id="sidebar2">


  <!-- Begin #profile-container -->

   <div id="profile-container"><h2 class="sidebar-title">About Me</h2>
<dl class="profile-datablock"><dt class="profile-img"><a href="/images/bhj.png""><img src="/images/bhj-thumb.png" alt="My Photo" height="58" width="80"></a></dt>
<dd class="profile-data"><strong>Name:</strong> <a rel="author" href="https://www.github.com/baohaojun"> Bao Haojun </a></dd>
<dd class="profile-data"><strong>Location:</strong>  Beijing, China </dd></dl>

<p class="profile-link"><a rel="author" href="/blog/2011/12/23/index.html">View my complete profile</a></p></div>

  <!-- End #profile -->



  <h2 class="sidebar-title">Feeds</h2>
    <ul>
        <li><a href="/atom.xml">Atom</a></li>
    </ul>

  <h2 class="sidebar-title">Projects</h2>
    <dl>
        <dt><a href="/blog/2011/12/23/beagrep.html"> Beagrep </a></dt>
        <dd> Grep 2G source code in 0.23 second </dd>

        <dt><a href="/blog/2013/04/13/skeleton-complete.html"> Skeletom-complete.el </a></dt>
        <dd> Type a bare skeleton, complete to a symbol/partial line/sexp/paragraph </dd>

        <dt><a href="/blog/2011/12/28/org-jira.html"> Org-jira.el </a></dt>
        <dd> Use JIRA with org-mode </dd>
    </dl>

    <h2>Tags</h2>
    <ul>
                <li><a href="../../../../meta/tags/code-reading.html" title="Reading source code">code-reading</a></li>
    </ul>

  <h2 class="sidebar-title">Previous Posts</h2>
    <ul id="recently">
        <li><a href='../../05/20/0-build-tar-for-android-under-x86-64-debian.html'> 在Debian下为安卓做一个GNU tar程序 </a></li>
<li><a href='../../01/28/0-Firefor-urlbar-dropdown-list-not-showing-anymore.html'> Firefor urlbar dropdown list not showing anymore </a></li>
<li><a href='../../01/16/0-Use-GreaseMonkey-to-disable-google-redirect.html'> 用GreaseMonkey禁止Google搜索重定向绑架 </a></li>
<li><a href='../../01/03/0-7-habits-of-highly-effective-editting.html'> 高效文本编辑的七个习惯 </a></li>
<li><a href='../../../2013/12/11/0-ssh-remote-command-and-bash--c-string.html'> ssh执行远程命令和bash -c string的用法 </a></li>
<li><a href='../../../2013/11/07/0-programming-discovery.html'> 发现式编程 </a></li>
<li><a href='../../../2013/10/16/0-Interactive-Git-Add.html'> Interactive Git Add </a></li>
<li><a href='../../../2013/10/05/0-My-Own-Win32-Input-Method.html'> 自己写了一个输入法, Windows下的五笔 </a></li>
<li><a href='../../../2013/10/04/0-Win32-IME-Programming.html'> 我的Win32输入法编程心得 </a></li>
<li><a href='../../../2013/10/01/0-Inside-Ajoke.html'> Inside Ajoke </a></li>
    </ul>

    <h2 class="sidebar-title">Archive</h2>
      <ul id="archives">
        <li><a href="/meta/Archive.html"> The complete archive </a></li>
      </ul>

  <!--
  <p>This is a paragraph of text that could go in the sidebar.</p>
  -->



</div></div>
<!-- End #sidebar -->
</div> <!-- End #bhj_article -->
<!-- {%/html-mode%} -->
<div id="postamble" class="status">
<!-- {%html-mode%} -->

<!-- {%/html-mode%} -->
</div>
</body>
</html>
