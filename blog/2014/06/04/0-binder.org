#+title: binder
# bhj-tags: code-reading
关于android下的binder IPC机制，网上已经有不少人分析过了，我总是嫌看起
来有些雾里看花，所以一咬牙自己看一遍吧。

首先，众所周知，IPC也即进程间通信，Inter Process Communication，它的形
式非常多种多样，比大家所熟知的那几种要多得多。在我看来，一些普遍不被认
为是IPC的机制，其实也可以认为是一种IPC，只不过可能原始一点，或者不够健
壮。

比如文件，两个进程完全可以通过IPC来进行通信嘛。进程A先往文件
/tmp/ab-ipc-file写一句话，“今晚打老虎”，然后sleep 10秒，进程B读此文件，
回复“好的”（把“好的”写到这个文件里去，覆盖了原来的内容），然后退出，然
后A醒来，重新读一下这个文件，获得了B传给它的信息。这样，它们就完成了一
次双向的IPC。

如果把进程间通信跟人类之间的沟通做一个类比的话，能更深的理解的确有很多
种机制均可以被打破常规的认为是IPC。沟通指的是信息的交换。而信息之所以
成为信息，是因为它可以被交换。可以被产生，被观察到，被消化掉。一个只被
产生出来，却从来没有被观察、被消化过的信息，是无法想像的。是不存在的。
比如一个女人，生了一个孩子，这件事本身好像不存在信息交换，孩子刚出生，
还不会跟妈妈交换信息嘛。可如果把范围划得广一点，就会发现在生孩子的过程
中，发生了很多信息交换，比如孩子它爸不停地在妈妈身边喊，“加油！加油！”。
等等等等。产房外焦急等待的长辈在不停地poll产房里的情况...

可惜，把范围定得这么广的话我们就没法继续讨论下去了。所以我还是稍微收一
下。

Binder IPC机制跟其它常见的IPC机制一样，里面包含一些基本的元素：

- 参与者

  您肯定听说过，signal也是一种IPC机制，一个基本上是单向的IPC机制。进程
  A通过Kill命令/系统调用向进程B发一个信号，发送成功的话进程B可能会做出
  一些动作来响应这个信号。这里的A和B就是参与者。但有时候进程A是不存在
  的，比如当一个子进程退出的时候，父进程会收到一个sigchld的信号，但这
  个信号是sigchld是谁发给父进程的呢？刚刚退出的子进程发的吗？可它没有
  调过kill系统调用啊？答案是操作系统发的。所以进程间通讯真的不是那么绝
  对的。

  有时候进程间通讯可以是多方的，比如管道，大家可能会认为肯定只能是两方
  参与，但其实弄4个进程出来通过一个管道通信也不是什么难事：

  #+BEGIN_EXAMPLE
  (echo hello; echo world) | ( dd bs=1 count=6 && perl -npe '' )
  #+END_EXAMPLE

  这些参与者参与到某种通信机制的方式随机制的不同而不同。比如signal机制，
  我可以写这样的一段淘气的脚本，不停地随机地给系统中的进程发
  sigkill（其中random是一个附助的生成随机整数的脚本）：

  #+BEGIN_SRC sh
  while true; do kill -9 $(random); done
  #+END_SRC

  而上面那一段4方管道，显然需要有一个父进程(bash)帮助把这个管道创建出
  来，把子进程创建出来，把输入输出配置好，再把相应的程序执行起来。

  而Binder机制里，系统中所有的进程都可以参与其中，只要它们打开了
  /dev/binder这个设备节点就可以。但其中有一个比较特殊一点，一般是第一
  个打开/dev/binder节点并成为context manager的那个进程。


  * 角色

    对，IPC中的各方是可以有不同的角色的。比如signal，有一个杀的，有一
    个被杀的（kill:-)）。

    而在Binder通讯机制里，有一个角色比较特殊，那就是context manager。
    这个在kernel里是叫context manager，其实在user space里是叫service
    manager。它允许系统里其它进程向它注册，比如这个进程向service
    manager注册：“我的进程号是NNNN，我的名字叫media server”，以后别的
    进程想进行多媒体相关的调用的话，就会向service manager查询，“media
    server”的进程是哪个？

    所以除了这个service manager之外，可以有很多其他的server，其实
    service manager自身也是一个server，只不过是最特殊的那个罢了。其他
    所有server都要向它来注册。

大体看过Binder的一些特点之后，我们来场景分析一下Binder相关的一些细节。
您可以别看了，我写得太乱了...


* Binder是一种面向对象的IPC机制

作为一种很牛逼的IPC机制，Binder想要作到让跨进程间通讯的远程调用，使用
起来感觉就像是进程内的函数调用一样。这个就有难度了。让我们来看看它是怎
么实现的。

首先，在远程server端会实现一套接口（Interface）。啊，算了，让我们先来
说一说如果没有binder机制，我们会怎么样来实现远程通讯吧。

我最熟悉的远程通讯就是tcp/ip了，这个通讯机制非常的通用，我们就不提那些
大家都熟知的http/ftp/ssh/telnet等协议了。

我曾经实现过一个手机测试命令工具箱，tcmd，采用了server/client机制实现。
首先一个server在一端监听某tcp端口，比如54321，客户端会给它发一个命令，
比如wifi-off，那么服务端读到这个命令之后，会以这样的代码去做相应的事情：

#+BEGIN_SRC c
    read(socket, cmd ...
    if (strcmp(cmd, "wifi-on") == 0) {
        wifi_on();
    } else if (strcmp(cmd, "wifi-off") == 0) {
        wifi_off();
    } else if ...

void wifi_off()
{
    write 0 /sys/wifi/power
}
#+END_SRC

也就是说，服务端系统会根据读到不同的命令去封装不同的函数。

比较妙的是，在客户端系统会去实现类似的逻辑，只不过是反过来，像一面镜子，它是往socket里写：

#+BEGIN_SRC c
void client_wifi_on()
{
    socket = open_socket("localhost", 54321);
    write(socket, "wifi-on"...
    close(socket);
}

void client_wifi_off()
{
    socket = open_socket("localhost", 54321);
    write(socket, "wifi-off"...
    close(socket);
}
#+END_SRC

这里你也看到了，我们可以像模板一样，生成很多的函数，每个函数做一个命令。
当然，没有什么能阴止你使用跟server端一样的名字，比如你的
=client_wifi_off= 完全也可以叫做 =wifi_off= ，这样做是有好处的，使两个本来非
常相关的函数变得更紧密了，但也有坏处，阅读代码的时候常常不知道该看哪个。
其实看多了很快会明白，所有的client端的实现都是个模板而已（boilerplate）。

然而我也非常喜欢这样的client实现：

#+BEGIN_SRC c
void test_cmd(const char *cmd)
{
    socket = open_socket("localhost", 54321);
    write(socket, cmd...
    close(socket);
}
#+END_SRC

然后再用到 =client_wifi_on()= 的地方就代以 =test_cmd("wifi-on")= ，在用到
=wifi_off()= 的地方就代以 =test_cmd("wifi-off")= ，等等。这样做的好处是少了很
多函数和很多boilerplate代码（每个命令都要open/close socket！）。

当然，你也可以再在 =test_cmd= 的基础上把 =wifi_on/wifi_off= 给包装出来：

#+BEGIN_SRC c
void wifi_on()
{
    test_cmd("wifi-on");
}
#+END_SRC

太棒了，这就跟我们最终要看的binder机制有点像了。好，我们接着来看一下
binder机制是怎么做的。

** 接口、继承树

Binder机制从最底层讲，只是数据的封装、传送、解析而已，所以它并不是只有
特定语言可以使用的，至少在Android系统里C/C++/Java都可以使用Binder。

但它最重要的优点之一，应该是它与面向对象编程之间比较友好的关系。我们就
先来看看Java里面是怎么使用Binder机制的。

题外话：我在用ajoke.el/beagrep/ctags/global等开源软件阅读源代码，以下
会有一些这些工具的运行结果。

以MountService.java为例，它有一个shutdown函数，我们看看它是哪个binder
的：

#+BEGIN_SRC compout
-*- mode: compilation; default-directory: "~/src/android/frameworks/base/services/java/com/android/server/" -*-
Compilation started at Sat Jun 21 21:24:30

ajoke-get-hierarchy.pl com.android.server.MountService -m shutdown
make: Entering directory `/home/bhj/src/android'

=> class com.android.server.MountService at frameworks/base/services/java/com/android/server/MountService.java line 103.
      public void shutdown(final IMountShutdownObserver observer){
   => class android.os.storage.IMountService.Stub at frameworks/base/core/java/android/os/storage/IMountService.java line 37.
      => class android.os.Binder at frameworks/base/core/java/android/os/Binder.java line 43.
         => interface android.os.IBinder at frameworks/base/core/java/android/os/IBinder.java line 86.
         => class java.lang.Object at libcore/luni/src/main/java/java/lang/Object.java line 131.
      => interface android.os.storage.IMountService at frameworks/base/core/java/android/os/storage/IMountService.java line 35.
            public void shutdown(IMountShutdownObserver observer)throws RemoteException;
         => interface android.os.IInterface at frameworks/base/core/java/android/os/IInterface.java line 23.
   => interface com.android.server.INativeDaemonConnectorCallbacks at frameworks/base/services/java/com/android/server/INativeDaemonConnectorCallbacks.java line 20.
   => interface com.android.server.Watchdog.Monitor at frameworks/base/services/java/com/android/server/Watchdog.java line 170.

Compilation finished at Sat Jun 21 21:24:31
#+END_SRC

哦，对了，你看到的上面这段代码就是它在我的Emacs编辑器里显示的样子，为
了让它正确的代码高亮，我还颇费了一番功夫呢！首先，上面的代码是
compilation-mode，这个在Emacs里是一种read-only的模式，然而org-html-fontify-code的代码是这样写的：

#+BEGIN_SRC emacs-lisp
          (setq code (with-temp-buffer
                       ;; Switch to language-specific mode.
                       (funcall lang-mode)
                       (insert code)
                       ;; Fontify buffer.
                       (font-lock-fontify-buffer)
#+END_SRC

可见，它先设置了mode =(funcall lang-mode)= 为compilation-mode，然后再
插入code =(insert code)= ，这就出问题了，compilation-mode是只读的，不
允许插入。为了绕过这个问题，我定义了一种新的compout-mode，很简单，就是可写的compilation-mode：

#+BEGIN_SRC emacs-lisp
(defun compout-mode ()
  "compilation mode, which is not buffer readonly for org export"
  (interactive)
  (compilation-mode)
  (setq buffer-read-only nil))
#+END_SRC

另外，做成这样之后，还是有问题，上面的代码输出到html之后没有全部高亮，
经查，应该是compilation-mode对temp-buffer有歧视，在temp-buffer里不会最
努力地高亮（见上面的 =with-temp-buffer= ）。

=with-temp-buffer= 的定义是这样的：

#+BEGIN_SRC emacs-lisp
(defmacro with-temp-buffer (&rest body)
  "Create a temporary buffer, and evaluate BODY there like `progn'.
See also `with-temp-file' and `with-output-to-string'."
  (declare (indent 0) (debug t))
  (let ((temp-buffer (make-symbol "temp-buffer")))
    `(let ((,temp-buffer (generate-new-buffer " *temp*")))
       ;; FIXME: kill-buffer can change current-buffer in some odd cases.
       (with-current-buffer ,temp-buffer
         (unwind-protect
             (progn ,@body)
           (and (buffer-name ,temp-buffer)
                (kill-buffer ,temp-buffer)))))))
#+END_SRC

问题出在 =(generate-new-buffer " *temp*")= 这个语句，buffer名字不能叫
=*temp*= ，所以我定义了一个advice来绕开这个问题：

#+BEGIN_SRC emacs-lisp
(defun org-html-fontify-code-compout (orig-fun &rest args)
  "Make compilation output htmlized."
  (if (string= (cadr args) "compout")
      (flet ((generate-new-buffer (name)
                                  (when (string= name " *temp*")
                                    (setq name "temp-ox"))
                                  (get-buffer-create (generate-new-buffer-name name))))
        (apply orig-fun args))
    (apply orig-fun args)))

(eval-after-load 'ox-html
  '(advice-add 'org-html-fontify-code :around #'org-html-fontify-code-compout))
#+END_SRC

当第二个参数 =(cadr args)= 为 "compout" 时，让generate-new-buffer的定
义发生变化，如果其参数名为 =*temp*= ，则改成 temp-ox 。

好了，从上面我用 ajoke-get-hierarchy 搞出来的继承树来看， shutdown 函数最早是在IMountService里定义的：

#+BEGIN_SRC compout
      => interface android.os.storage.IMountService at frameworks/base/core/java/android/os/storage/IMountService.java line 35.
            public void shutdown(IMountShutdownObserver observer)throws RemoteException;
#+END_SRC

#+BEGIN_SRC grepout
-*- mode: grep; default-directory: "~/src/android/frameworks/base/core/java/android/os/" -*-
Grep started at Fri Jul 25 10:02:01

grep-func-call -e "IMountService.*asInterface" --nc -a -v /tests/


Entering directory `/home/bhj/src/android/frameworks/base/core/java/android/app'
ContextImpl.java:2172: <=     private File[] ensureDirsExistOrFilter(File[] dirs) {
ContextImpl.java:2182: =>                         final IMountService mount = IMountService.Stub.asInterface(
Entering directory `/home/bhj/src/android/frameworks/base/core/java/android/os'
Environment.java:74: <=     private static StorageVolume getPrimaryVolume() {
Environment.java:83: =>                         IMountService mountService = IMountService.Stub.asInterface(ServiceManager
Environment.java:707: <=     public static String getStorageState(File path) {
Environment.java:717: =>             final IMountService mountService = IMountService.Stub.asInterface(
Entering directory `/home/bhj/src/android/frameworks/base/core/java/android/os/storage'
IMountService.java:836: <>         public static IMountService asInterface(IBinder obj) {
IMountService.java:857: <=         public boolean onTransact(int code, Parcel data, Parcel reply,
IMountService.java:867: =>                     listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
IMountService.java:875: =>                     listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
Entering directory `/home/bhj/src/android/frameworks/base/core/java/android/os/storage'
StorageManager.java:315: <=     public StorageManager(ContentResolver resolver, Looper tgtLooper) throws RemoteException {
StorageManager.java:318: =>         mMountService = IMountService.Stub.asInterface(ServiceManager.getService("mount"));
Entering directory `/home/bhj/src/android/frameworks/base/core/java/com/android/internal/content'
PackageHelper.java:61: <=     public static IMountService getMountService() throws RemoteException {
PackageHelper.java:64: =>             return IMountService.Stub.asInterface(service);
Entering directory `/home/bhj/src/android/frameworks/base/core/java/com/android/internal/os/storage'
ExternalStorageFormatter.java:319: <=     IMountService getMountService() {
ExternalStorageFormatter.java:323: =>                 mMountService = IMountService.Stub.asInterface(service);
Entering directory `/home/bhj/src/android/frameworks/base/core/java/com/android/internal/widget'
LockPatternUtils.java:632: <=     private void updateEncryptionPassword(String password) {
LockPatternUtils.java:645: =>         IMountService mountService = IMountService.Stub.asInterface(service);
Entering directory `/home/bhj/src/android/frameworks/base/packages/BackupRestoreConfirmation/src/com/android/backupconfirm'
BackupRestoreConfirmation.java:131: <=     public void onCreate(Bundle icicle) {
BackupRestoreConfirmation.java:159: =>         mMountService = IMountService.Stub.asInterface(ServiceManager.getService("mount"));
Entering directory `/home/bhj/src/android/frameworks/base/packages/SystemUI/src/com/android/systemui/usb'
UsbStorageActivity.java:202: <=     private IMountService getMountService() {
UsbStorageActivity.java:205: =>             return IMountService.Stub.asInterface(service);
Entering directory `/home/bhj/src/android/frameworks/base/services/java/com/android/server'
BackupManagerService.java:773: <=     public BackupManagerService(Context context) {
BackupManagerService.java:781: =>         mMountService = IMountService.Stub.asInterface(ServiceManager.getService("mount"));
Entering directory `/home/bhj/src/android/frameworks/base/services/java/com/android/server/power'
ShutdownThread.java:295: <=     public void run() {
ShutdownThread.java:374: =>                 final IMountService mount = IMountService.Stub.asInterface(
Entering directory `/home/bhj/src/android/packages/apps/SettingsSmartisan/src/com/android/settings'
CryptKeeperConfirm.java:41: <=         public void onCreate(Bundle savedInstanceState) {
CryptKeeperConfirm.java:72: =>                     IMountService mountService = IMountService.Stub.asInterface(service);
Entering directory `/home/bhj/src/android/packages/apps/SettingsSmartisan/src/com/android/settings'
CryptKeeper.java:614: <=     private IMountService getMountService() {
CryptKeeper.java:617: =>             return IMountService.Stub.asInterface(service);
Entering directory `/home/bhj/src/android/packages/apps/SettingsSmartisan/src/com/android/settings/deviceinfo'
Memory.java:214: <=     private synchronized IMountService getMountService() {
Memory.java:218: =>                mMountService = IMountService.Stub.asInterface(service);
Entering directory `/home/bhj/src/android/packages/apps/Settings/src/com/android/settings'
CryptKeeperConfirm.java:41: <=         public void onCreate(Bundle savedInstanceState) {
CryptKeeperConfirm.java:72: =>                     IMountService mountService = IMountService.Stub.asInterface(service);
Entering directory `/home/bhj/src/android/packages/apps/Settings/src/com/android/settings'
CryptKeeper.java:614: <=     private IMountService getMountService() {
CryptKeeper.java:617: =>             return IMountService.Stub.asInterface(service);
Entering directory `/home/bhj/src/android/packages/apps/Settings/src/com/android/settings/deviceinfo'
Memory.java:203: <=     private synchronized IMountService getMountService() {
Memory.java:207: =>                mMountService = IMountService.Stub.asInterface(service);
Entering directory `/home/bhj/src/android/packages/apps/SystemUISmartisan/src/com/smartisanos/systemui/usb'
UsbStorageActivity.java:204: <=     private IMountService getMountService() {
UsbStorageActivity.java:207: =>             return IMountService.Stub.asInterface(service);
Entering directory `/home/bhj/src/android/vendor/qcom/proprietary/QualcommSettings/src/com/qualcomm/qualcommsettings'
QualcommSettings.java:687: <=    private void updateUsbMassStorageStatus() {
QualcommSettings.java:689: =>         IMountService mountService = IMountService.Stub.asInterface(ServiceManager

Grep finished (matches found) at Fri Jul 25 10:02:02
#+END_SRC

啊，还是看一看shutdown在I?MountService里都有谁定义的：

#+BEGIN_SRC grepout
-*- mode: grep; default-directory: "~/src/android/frameworks/base/core/java/android/os/storage/" -*-
Grep started at Fri Jul 25 10:17:13

grep-gtags -e "shutdown" -p MountServ
Found total 4/1728 definitions: Entering directory `/home/bhj/src/android'
frameworks/base/core/java/android/os/storage/IMountService.java:451: method: <android.os.storage.IMountService.Stub.Proxy.shutdown> : public void shutdown(IMountShutdownObserver observer) throws RemoteException {
frameworks/base/core/java/android/os/storage/IMountService.java:1310: method: <android.os.storage.IMountService.shutdown> : public void shutdown(IMountShutdownObserver observer) throws RemoteException;
frameworks/base/services/java/com/android/server/MountService.java:1423: method: <com.android.server.MountService.shutdown> : public void shutdown(final IMountShutdownObserver observer) {
frameworks/base/libs/storage/IMountService.cpp:403: function: <android::BpMountService::shutdown> : void shutdown(const sp<IMountShutdownObserver>& observer) {
    403:     void shutdown(const sp<IMountShutdownObserver>& observer)
    404:     {
    405:         Parcel data, reply;
    406:         data.writeInterfaceToken(IMountService::getInterfaceDescriptor());
    407:         data.writeStrongBinder(observer->asBinder());
    408:         if (remote()->transact(TRANSACTION_shutdown, data, &reply) != NO_ERROR) {
    409:             ALOGD("shutdown could not contact remote\n");
    410:             return;
    411:         }
    412:         int32_t err = reply.readExceptionCode();
    413:         if (err < 0) {
    ...

Grep finished (matches found) at Fri Jul 25 10:17:14
#+END_SRC

可见有一个interface里声明了这个函数的原型android.os.storage.IMountService.shutdown，然后有一个stub.proxy的实现：
android.os.storage.IMountService.Stub.Proxy.shutdown，但它的实现只是进行了binder的系统调用而已：

#+BEGIN_SRC java
            public void shutdown(IMountShutdownObserver observer)
                    throws RemoteException {
                Parcel _data = Parcel.obtain();
                Parcel _reply = Parcel.obtain();
                try {
                    _data.writeInterfaceToken(DESCRIPTOR);
                    _data.writeStrongBinder((observer != null ? observer.asBinder() : null));
                    mRemote.transact(Stub.TRANSACTION_shutdown, _data, _reply, 0);
                    _reply.readException();
                } finally {
                    _reply.recycle();
                    _data.recycle();
                }
            }
#+END_SRC

然后 android.os.storage.IMountService.Stub 实现了这个Interface，但 android.server.MountService 又扩展了这个 Stub:
#+BEGIN_SRC java
    public static abstract class Stub extends Binder implements IMountService {}
class MountService extends IMountService.Stub
        implements INativeDaemonConnectorCallbacks, Watchdog.Monitor {}
#+END_SRC

然后注意上面proxy里的实现，发了一个 TRANSACTION_shutdown 的transact，先搜一下 TRANSACTION_shutdown 吧：
#+BEGIN_SRC grepout
-*- mode: grep; default-directory: "~/system-config/doc/baohaojun/blog/2014/06/04/" -*-
Grep started at Fri Jul 25 10:27:07

beagrep -e "TRANSACTION_shutdown" -d ~/src/android
/home/bhj/src/android/frameworks/base/core/java/android/os/storage/IMountService.java:458:                    mRemote.transact(Stub.TRANSACTION_shutdown, _data, _reply, 0);
/home/bhj/src/android/frameworks/base/core/java/android/os/storage/IMountService.java:800:        static final int TRANSACTION_shutdown = IBinder.FIRST_CALL_TRANSACTION + 19;
/home/bhj/src/android/frameworks/base/core/java/android/os/storage/IMountService.java:1048:                case TRANSACTION_shutdown: {
/home/bhj/src/android/frameworks/base/libs/storage/IMountService.cpp:44:    TRANSACTION_shutdown,
/home/bhj/src/android/frameworks/base/libs/storage/IMountService.cpp:408:        if (remote()->transact(TRANSACTION_shutdown, data, &reply) != NO_ERROR) {

Grep finished (matches found) at Fri Jul 25 10:27:07
#+END_SRC

.cpp的那个我们就不看了，完全在拷贝.java这边的代码。当然也可能是.java在拷贝.cpp的。

处理的地方是在IMountService.java:1048:行，这个是Stub里定义的，也就是说
Stub只实现了针对每个 TRANSACTION_xxx 应该怎么调用由子类(MountService)
实现的函数，它自己是一个也没有实现过的。

再看一下Stub自己一共定义了多少个函数吧：
#+BEGIN_SRC grepout
-*- mode: grep; default-directory: "~/src/android/frameworks/base/core/java/android/os/storage/" -*-
Grep started at Fri Jul 25 14:44:33

grep-gtags -e "android.os.storage.IMountService.Stub..*" -t method |grep -v Proxy
Found total 42/38 definitions: Entering directory `/home/bhj/src/android'
frameworks/base/core/java/android/os/storage/IMountService.java:836: method: <android-os-storage-IMountService-Stub-asInterface> : public static IMountService asInterface(IBinder obj) {
frameworks/base/core/java/android/os/storage/IMountService.java:848: method: <android-os-storage-IMountService-Stub-Stub> : public Stub() {
frameworks/base/core/java/android/os/storage/IMountService.java:852: method: <android-os-storage-IMountService-Stub-asBinder> : public IBinder asBinder() {
frameworks/base/core/java/android/os/storage/IMountService.java:857: method: <android-os-storage-IMountService-Stub-onTransact> : public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {

Grep finished (matches found) at Fri Jul 25 14:44:36
#+END_SRC

其中asInterface的定义：
#+BEGIN_SRC java
        public static IMountService asInterface(IBinder obj) {
            if (obj == null) {
                return null;
            }
            IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
            if (iin != null && iin instanceof IMountService) {
                return (IMountService) iin;
            }
            return new IMountService.Stub.Proxy(obj);
        }
#+END_SRC

会传进来一个obj，这个obj会被调到queryLocalInterface，最后调到的应该是：

#+BEGIN_SRC java
    public IInterface queryLocalInterface(String descriptor) {
        if (mDescriptor.equals(descriptor)) {
            return mOwner;
        }
        return null;
    }
#+END_SRC
这个在Binder.java里。mOwner被设值的地方：

#+BEGIN_SRC java
    public void attachInterface(IInterface owner, String descriptor) {
        mOwner = owner;
        mDescriptor = descriptor;
    }
#+END_SRC

attachInterface 是在MountService的Stub里调用的：

#+BEGIN_SRC grepout
-*- mode: grep; default-directory: "~/src/android/frameworks/base/core/java/android/os/storage/" -*-
Grep started at Sat Jul 26 22:04:08

grep-gtags -e "Stub" -d ~/src/android -o
Found total 2/8 definitions: Entering directory `/home/bhj/src/android'
frameworks/base/core/java/android/os/storage/IMountService.java:37: class: <android.os.storage.IMountService.Stub> : public static abstract class Stub extends Binder implements IMountService {
    37:     public static abstract class Stub extends Binder implements IMountService {
frameworks/base/core/java/android/os/storage/IMountService.java:830: method: <android.os.storage.IMountService.Stub.Stub> : public Stub() {
    830:         public Stub() {
    831:             attachInterface(this, DESCRIPTOR);
    832:         }
    833:

Grep finished (matches found) at Sat Jul 26 22:04:09
#+END_SRC

再看一下这个Stub的继承树：

#+BEGIN_SRC compout
-*- mode: compilation; default-directory: "~/src/android/frameworks/base/core/java/android/os/storage/" -*-
Compilation started at Sat Jul 26 22:06:28

ajoke-get-hierarchy.pl android.os.storage.IMountService.Stub -m Stub
make: Entering directory `/home/bhj/src/android'

=> class android.os.storage.IMountService.Stub at frameworks/base/core/java/android/os/storage/IMountService.java line 37.
      public Stub(){
   => class android.os.Binder at frameworks/base/core/java/android/os/Binder.java line 43.
      => interface android.os.IBinder at frameworks/base/core/java/android/os/IBinder.java line 86.
      => class java.lang.Object at libcore/luni/src/main/java/java/lang/Object.java line 131.
   => interface android.os.storage.IMountService at frameworks/base/core/java/android/os/storage/IMountService.java line 35.
         public static abstract class Stub extends Binder implements IMountService{
      => interface android.os.IInterface at frameworks/base/core/java/android/os/IInterface.java line 23.

Compilation finished at Sat Jul 26 22:06:30
#+END_SRC

这时候就非常清楚的可以看到了，C++里的RTTI（Run Time Type Infomation）
的一种机制，在这个java代码里用obj+descriptor的方式重新实现了一遍。为什
么不直接用isinstanceof呢？有点想不明白。可能是这些源码的作者想尽量保持
java与c++接口名字上的一致性？

回到IMountService，asInterface用到的地方：

#+BEGIN_SRC grepout
asIt-*- mode: grep; default-directory: "~/src/android/frameworks/base/core/java/android/os/storage/" -*-
Grep started at Fri Jul 25 14:53:30

grep-func-call -e "IMountService.*asInterface" --nc -a -v /tests/


Entering directory `/home/bhj/src/android/frameworks/base/core/java/android/app'
ContextImpl.java:2172: <=     private File[] ensureDirsExistOrFilter(File[] dirs) {
ContextImpl.java:2182: =>                         final IMountService mount = IMountService.Stub.asInterface(
Entering directory `/home/bhj/src/android/frameworks/base/core/java/android/os'
Environment.java:74: <=     private static StorageVolume getPrimaryVolume() {
Environment.java:83: =>                         IMountService mountService = IMountService.Stub.asInterface(ServiceManager
Environment.java:707: <=     public static String getStorageState(File path) {
Environment.java:717: =>             final IMountService mountService = IMountService.Stub.asInterface(
Entering directory `/home/bhj/src/android/frameworks/base/core/java/android/os/storage'
IMountService.java:836: <>         public static IMountService asInterface(IBinder obj) {
IMountService.java:857: <=         public boolean onTransact(int code, Parcel data, Parcel reply,
IMountService.java:867: =>                     listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
IMountService.java:875: =>                     listener = IMountServiceListener.Stub.asInterface(data.readStrongBinder());
Entering directory `/home/bhj/src/android/frameworks/base/core/java/android/os/storage'
StorageManager.java:315: <=     public StorageManager(ContentResolver resolver, Looper tgtLooper) throws RemoteException {
StorageManager.java:318: =>         mMountService = IMountService.Stub.asInterface(ServiceManager.getService("mount"));
Entering directory `/home/bhj/src/android/frameworks/base/core/java/com/android/internal/content'
PackageHelper.java:61: <=     public static IMountService getMountService() throws RemoteException {
PackageHelper.java:64: =>             return IMountService.Stub.asInterface(service);
Entering directory `/home/bhj/src/android/frameworks/base/core/java/com/android/internal/os/storage'
ExternalStorageFormatter.java:319: <=     IMountService getMountService() {
ExternalStorageFormatter.java:323: =>                 mMountService = IMountService.Stub.asInterface(service);
Entering directory `/home/bhj/src/android/frameworks/base/core/java/com/android/internal/widget'
LockPatternUtils.java:632: <=     private void updateEncryptionPassword(String password) {
LockPatternUtils.java:645: =>         IMountService mountService = IMountService.Stub.asInterface(service);
Entering directory `/home/bhj/src/android/frameworks/base/packages/BackupRestoreConfirmation/src/com/android/backupconfirm'
BackupRestoreConfirmation.java:131: <=     public void onCreate(Bundle icicle) {
BackupRestoreConfirmation.java:159: =>         mMountService = IMountService.Stub.asInterface(ServiceManager.getService("mount"));
Entering directory `/home/bhj/src/android/frameworks/base/packages/SystemUI/src/com/android/systemui/usb'
UsbStorageActivity.java:202: <=     private IMountService getMountService() {
UsbStorageActivity.java:205: =>             return IMountService.Stub.asInterface(service);
Entering directory `/home/bhj/src/android/frameworks/base/services/java/com/android/server'
BackupManagerService.java:773: <=     public BackupManagerService(Context context) {
BackupManagerService.java:781: =>         mMountService = IMountService.Stub.asInterface(ServiceManager.getService("mount"));
Entering directory `/home/bhj/src/android/frameworks/base/services/java/com/android/server/power'
ShutdownThread.java:295: <=     public void run() {
ShutdownThread.java:374: =>                 final IMountService mount = IMountService.Stub.asInterface(
Entering directory `/home/bhj/src/android/packages/apps/SettingsSmartisan/src/com/android/settings'
CryptKeeperConfirm.java:41: <=         public void onCreate(Bundle savedInstanceState) {
CryptKeeperConfirm.java:72: =>                     IMountService mountService = IMountService.Stub.asInterface(service);
Entering directory `/home/bhj/src/android/packages/apps/SettingsSmartisan/src/com/android/settings'
CryptKeeper.java:614: <=     private IMountService getMountService() {
CryptKeeper.java:617: =>             return IMountService.Stub.asInterface(service);
Entering directory `/home/bhj/src/android/packages/apps/SettingsSmartisan/src/com/android/settings/deviceinfo'
Memory.java:214: <=     private synchronized IMountService getMountService() {
Memory.java:218: =>                mMountService = IMountService.Stub.asInterface(service);
Entering directory `/home/bhj/src/android/packages/apps/Settings/src/com/android/settings'
CryptKeeperConfirm.java:41: <=         public void onCreate(Bundle savedInstanceState) {
CryptKeeperConfirm.java:72: =>                     IMountService mountService = IMountService.Stub.asInterface(service);
Entering directory `/home/bhj/src/android/packages/apps/Settings/src/com/android/settings'
CryptKeeper.java:614: <=     private IMountService getMountService() {
CryptKeeper.java:617: =>             return IMountService.Stub.asInterface(service);
Entering directory `/home/bhj/src/android/packages/apps/Settings/src/com/android/settings/deviceinfo'
Memory.java:203: <=     private synchronized IMountService getMountService() {
Memory.java:207: =>                mMountService = IMountService.Stub.asInterface(service);
Entering directory `/home/bhj/src/android/packages/apps/SystemUISmartisan/src/com/smartisanos/systemui/usb'
UsbStorageActivity.java:204: <=     private IMountService getMountService() {
UsbStorageActivity.java:207: =>             return IMountService.Stub.asInterface(service);
Entering directory `/home/bhj/src/android/vendor/qcom/proprietary/QualcommSettings/src/com/qualcomm/qualcommsettings'
QualcommSettings.java:687: <=    private void updateUsbMassStorageStatus() {
QualcommSettings.java:689: =>         IMountService mountService = IMountService.Stub.asInterface(ServiceManager

Grep finished (matches found) at Fri Jul 25 14:53:31
#+END_SRC

* ServiceManager.getService()

这个函数：

#+BEGIN_SRC java
    public static IBinder getService(String name) {
        try {
            IBinder service = sCache.get(name);
            if (service != null) {
                return service;
            } else {
                return getIServiceManager().getService(name);
            }
        } catch (RemoteException e) {
            Log.e(TAG, "error in getService", e);
        }
        return null;
    }
#+END_SRC


会调到 getIServiceManager：

#+BEGIN_SRC java
    private static IServiceManager getIServiceManager() {
        if (sServiceManager != null) {
            return sServiceManager;
        }

        // Find the service manager
        sServiceManager = ServiceManagerNative.asInterface(BinderInternal.getContextObject());
        return sServiceManager;
    }
#+END_SRC

会调到 ServiceManagerNative.asInterface(BinderInternal.getContextObject())

其中 BinderInternal.getContextObject() 是个native的函数，它会调到 c++ 的 getContextObject：

#+BEGIN_SRC c++
sp<IBinder> ProcessState::getContextObject(const sp<IBinder>& caller)
{
    return getStrongProxyForHandle(0);
}
#+END_SRC

可以看到，这里的caller参数都没有用到，不知道是为什么要有这个caller参数。

getStrongProxyForHandle的定义如下：

#+BEGIN_SRC c++
sp<IBinder> ProcessState::getStrongProxyForHandle(int32_t handle)
{
    sp<IBinder> result;

    AutoMutex _l(mLock);

    handle_entry* e = lookupHandleLocked(handle);

    if (e != NULL) {
        // We need to create a new BpBinder if there isn't currently one, OR we
        // are unable to acquire a weak reference on this current one.  See comment
        // in getWeakProxyForHandle() for more info about this.
        IBinder* b = e->binder;
        if (b == NULL || !e->refs->attemptIncWeak(this)) {
            b = new BpBinder(handle);
            e->binder = b;
            if (b) e->refs = b->getWeakRefs();
            result = b;
        } else {
            // This little bit of nastyness is to allow us to add a primary
            // reference to the remote proxy when this team doesn't have one
            // but another team is sending the handle to us.
            result.force_set(b);
            e->refs->decWeak(this);
        }
    }

    return result;
}
#+END_SRC

所以这里我们要看一下 lookupHandleLocked 这个函数，此处传进去的handle为0。

#+BEGIN_SRC c++
ProcessState::handle_entry* ProcessState::lookupHandleLocked(int32_t handle)
{
    const size_t N=mHandleToObject.size();
    if (N <= (size_t)handle) {
        handle_entry e;
        e.binder = NULL;
        e.refs = NULL;
        status_t err = mHandleToObject.insertAt(e, N, handle+1-N);
        if (err < NO_ERROR) return NULL;
    }
    return &mHandleToObject.editItemAt(handle);
}
#+END_SRC

因为handle为0，所以 mHandleToObject 的.size() 和 handle 一比，如果
handle 不在 mHandleToObject 里，就需要插一个新的 handle_entry 进去，否
则直接从 mHandleToObject 里抽一个 editItemAt 出来交差。

看一下 mHandleToObject 是怎么初始化的：

#+BEGIN_SRC grepout
-*- mode: grep; default-directory: "~/src/android/frameworks/native/libs/binder/" -*-
Grep started at Sun Jul 27 22:16:08

beagrep -e "mHandleToObject"
/home/bhj/src/android/frameworks/native/include/binder/ProcessState.h:96:            Vector<handle_entry>mHandleToObject;
/home/bhj/src/android/frameworks/native/libs/binder/ProcessState.cpp:172:    const size_t N=mHandleToObject.size();
/home/bhj/src/android/frameworks/native/libs/binder/ProcessState.cpp:177:        status_t err = mHandleToObject.insertAt(e, N, handle+1-N);
/home/bhj/src/android/frameworks/native/libs/binder/ProcessState.cpp:180:    return &mHandleToObject.editItemAt(handle);

Grep finished (matches found) at Sun Jul 27 22:16:08
#+END_SRC

完了，mHandleToObject根本没有正规的初始化，都是在 lookupHandleLocked
里完成对它的操作的，如果handle没有找到的话，就放一个handle_entry进去跟
这个handle对应，其binder和refs均为空值。
