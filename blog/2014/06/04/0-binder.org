#+title: binder
# bhj-tags: code-reading
关于android下的binder IPC机制，网上已经有不少人分析过了，我总是嫌看起
来有些雾里看花，所以一咬牙自己看一遍吧。

首先，众所周知，IPC也即进程间通信，Inter Process Communication，它的形
式非常多种多样，比大家所熟知的那几种要多得多。在我看来，一些普遍不被认
为是IPC的机制，其实也可以认为是一种IPC，只不过可能原始一点，或者不够健
壮。

比如文件，两个进程完全可以通过IPC来进行通信嘛。进程A先往文件
/tmp/ab-ipc-file写一句话，“今晚打老虎”，然后sleep 10秒，进程B读此文件，
回复“好的”（把“好的”写到这个文件里去，覆盖了原来的内容），然后退出，然
后A醒来，重新读一下这个文件，获得了B传给它的信息。这样，它们就完成了一
次双向的IPC。

如果把进程间通信跟人类之间的沟通做一个类比的话，能更深的理解的确有很多
种机制均可以被打破常规的认为是IPC。沟通指的是信息的交换。而信息之所以
成为信息，是因为它可以被交换。可以被产生，被观察到，被消化掉。一个只被
产生出来，却从来没有被观察、被消化过的信息，是无法想像的。是不存在的。
比如一个女人，生了一个孩子，这件事本身好像不存在信息交换，孩子刚出生，
还不会跟妈妈交换信息嘛。可如果把范围划得广一点，就会发现在生孩子的过程
中，发生了很多信息交换，比如孩子它爸不停地在妈妈身边喊，“加油！加油！”。
等等等等。产房外焦急等待的长辈在不停地poll产房里的情况...

可惜，把范围定得这么广的话我们就没法继续讨论下去了。所以我还是稍微收一
下。

Binder IPC机制跟其它常见的IPC机制一样，里面包含一些基本的元素：

- 参与者

  您肯定听说过，signal也是一种IPC机制，一个基本上是单向的IPC机制。进程
  A通过Kill命令/系统调用向进程B发一个信号，发送成功的话进程B可能会做出
  一些动作来响应这个信号。这里的A和B就是参与者。但有时候进程A是不存在
  的，比如当一个子进程退出的时候，父进程会收到一个sigchld的信号，但这
  个信号是sigchld是谁发给父进程的呢？刚刚退出的子进程发的吗？可它没有
  调过kill系统调用啊？答案是操作系统发的。所以进程间通讯真的不是那么绝
  对的。

  有时候进程间通讯可以是多方的，比如管道，大家可能会认为肯定只能是两方
  参与，但其实弄4个进程出来通过一个管道通信也不是什么难事：

  #+BEGIN_EXAMPLE
  (echo hello; echo world) | ( dd bs=1 count=6 && perl -npe '' )
  #+END_EXAMPLE

  这些参与者参与到某种通信机制的方式随机制的不同而不同。比如signal机制，
  我可以写这样的一段淘气的脚本，不停地随机地给系统中的进程发
  sigkill（其中random是一个附助的生成随机整数的脚本）：

  #+BEGIN_SRC shell
  while true; do kill -9 $(random); done
  #+END_SRC

  而上面那一段4方管道，显然需要有一个父进程(bash)帮助把这个管道创建出
  来，把子进程创建出来，把输入输出配置好，再把相应的程序执行起来。

  而Binder机制里，系统中所有的进程都可以参与其中，只要它们打开了
  /dev/binder这个设备节点就可以。

  * 角色

    对，IPC中的各方是可以有不同的角色的。比如signal，有一个杀的，有一
    个被杀的（kill:-)）。
