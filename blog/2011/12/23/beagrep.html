<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>beagrep, grep 2G source code in 2 seconds</title>
<!-- 2013-05-20 Mon 21:17 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="generator" content="Org-mode"/>
<meta name="author" content="Bao Haojun"/>
<link rel="stylesheet" href="/css/default.css" type="text/css" />
 <link rel="shortcut icon" href="/poison.png" type="image/png" />

    <script type="text/javascript" src="/js/jquery-1.7.1.min.js"></script>
    <script type="text/javascript">
        var BYB = {};
    </script>
    <script type="text/javascript">
        BYB.includeScript = function(file,callback){
            var _doc = document.getElementsByTagName('head')[0];
            var js = document.createElement('script');
            js.setAttribute('type', 'text/javascript');
            js.setAttribute('src', file);
            _doc.appendChild(js);

            if (!/*@cc_on!@*/0) { //if not IE
                //Firefox2、Firefox3、Safari3.1+、Opera9.6+ support js.onload
                js.onload = function () {
                    callback();
                }
            } else {
                //IE6、IE7 support js.onreadystatechange
                js.onreadystatechange = function () {
                    if (js.readyState == 'loaded' || js.readyState == 'complete') {
                        callback();
                    }
                }
            }
            return false;
        }
    </script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012  Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<div id="header">

  <h1 id="blog-title">

    包昊军的博客

  </h1>
  <p id="description">What you don't know, won't hurt you.</p>

</div>
</div>
<div id='bhj_article'>
  <div id='bhj_leftpane'>
<div id="content">
<h1 class="title">beagrep, grep 2G source code in 2 seconds</h1>
<p>
Beagrep can grep <code>readlink</code> in Android source code in 0.8 second when
cache is hot, and about 11 seconds when cache is cold.
</p>

<p>
Using <a href="https://github.com/ggreer/the_silver_searcher">ag</a> or <a href="https://github.com/petdance/ack">ack</a> or bare grep, the results are a couple of seconds when
cache is hot, or a couple of minutes when the cache is cold<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
I still remember when I read the ``Linux Device Drivers'', 1st Edition, in the preface, the author says:
</p>

<blockquote>
<p>
&#x2026; The text you are approaching is the result of hours of patient grepping &#x2026;
</p>
</blockquote>

<p>
I have been using grep to read source code ever since. It's been
adequate for a long time, until I started reading Android source code
with it. I remember vividly how it took me 30 minutes to <code>grep
readlink</code> in Android source code (with VCS directory and binary files
excluded).
</p>

<p>
Then I learned about the beagle software, and it occurred to me, what
if I use beagle and grep together? I mean, to use beagle first to
decide the (relatively a lot smaller) set of possible matching files
(i.e., files that contained the word <code>readlink</code>, taking the previous
example), then invoke grep on this set only. Usually the job can be
done in a couple of seconds.
</p>

<p>
Beagrep supports both Linux and Windows (requires CYGWIN).
</p>

<p>
(Note a Chinese version of this page is available <a href="../../../2012/01/31/beagrep-cn.html">here</a>, but it may be
outdated).
</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Install</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Linux install</h3>
<div class="outline-text-3" id="text-2-1">
</div><div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1"><span class="section-number-4">2.1.1</span> Using .deb under debian/ubuntu</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
I have provided several .deb package files on github, one for debian
testing, 3 for ubuntu lucid(10.04), oneiric(11.10) and
precise(12.04). They are all for amd64. If you happen to be using one
of these, you can download them <a href="https://github.com/baohaojun/beagrep/downloads">here</a>. Here's how to install it using
ubuntu 12.04 as an example:
</p>

<div class="org-src-container">

<pre class="src src-sh">dpkg -i beagrep-for-ubuntu-precise-2012-09-05-ae0a1a2.deb <span class="org-comment-delimiter"># </span><span class="org-comment">will probably get dependency errors</span>
apt-get -f install <span class="org-comment-delimiter"># </span><span class="org-comment">fix the dependency errors</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-1-2" class="outline-4">
<h4 id="sec-2-1-2"><span class="section-number-4">2.1.2</span> Compile by yourself</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
If you need compile by yourself, using Ubuntu precise as an example:
</p>

<div class="org-src-container">

<pre class="src src-sh">git clone https://github.com/baohaojun/beagrep.git -b for-ubuntu-precise
<span class="org-comment-delimiter"># </span><span class="org-comment">you can also run "git branch -a" to see other versions of debian/ubuntu supported</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Install build dependencies. You can open debian/control and check</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">the build dependencies and install all of them. The following</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">command will try to install them automatically, but if it fails then</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">you need figure out which packages to install manually. Good luck!</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Or you can contact some debian/ubuntu advanced user for help.</span>
apt-get install $(<span class="org-sh-quoted-exec">cat</span> debian/control | perl -ne <span class="org-string">'print if m/Build-Depends/..m/Standards-Version/'</span>|grep -v -e Build-Depends:<span class="org-string">\\\|</span>Standards-Version|perl -npe <span class="org-string">'s/,/ /g'</span>)

<span class="org-comment-delimiter"># </span><span class="org-comment">do the build</span>
(<span class="org-builtin">set</span> -e; autoreconf -i; ./configure; make -j4; sudo make install; <span class="org-builtin">echo</span> OK)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-1-3" class="outline-4">
<h4 id="sec-2-1-3"><span class="section-number-4">2.1.3</span> Build .deb by yourself</h4>
<div class="outline-text-4" id="text-2-1-3">
<p>
Before someone volunteer to make beagrep into debian/ubuntu
distribution, you might also find a need to build .deb by yourself
(for e.g., to help your colleagues use beagrep easily without needing
to compile it themselves).
</p>

<p>
Here's how I do it:
</p>

<ol class="org-ol">
<li>Make sure you can compile beagrep manually by referring to the
previous section.
</li>

<li>Make a tar.gz of beagrep (note that the filename must be exact, it
is required by dpkg):

<pre class="example">
tar czfv ~/tmp/beagrep_0.4.0.orig.tar.gz beagrep --exclude-vcs
</pre>
</li>

<li>Untar it and build the .deb package:

<pre class="example">
cd ~/tmp
tar zxfv beagrep_0.4.0.orig.tar.gz
cd beagrep
dpkg-buildpackage
</pre>

<p>
The .deb file is generated in the <code>~/tmp</code> directory.
</p>
</li>

<li>Refer to <i>#using.deb</i> for how to install.
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Windows install</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Windows install can only be done compiling by yourself, and be
pre-warned, it's not easy&#x2026;
</p>
</div>

<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> Install dependencies</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
You need install CYGWIN and Mono for Windows.
</p>
</div>
</div>
<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> Get beagrep Windows code</h4>
<div class="outline-text-4" id="text-2-2-2">
<div class="org-src-container">

<pre class="src src-sh">git clone git://github.com/baohaojun/beagrep.git -b Windows
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3"><span class="section-number-4">2.2.3</span> Compile and install</h4>
<div class="outline-text-4" id="text-2-2-3">
<div class="org-src-container">

<pre class="src src-sh"><span class="org-builtin">cd</span> beagrep
bash build-win.sh
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Usage</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Quick smoke test</h3>
<div class="outline-text-3" id="text-3-1">
<div class="org-src-container">

<pre class="src src-sh"><span class="org-builtin">cd</span> /tmp; mkdir $<span class="org-variable-name">$</span>; <span class="org-builtin">cd</span> $<span class="org-variable-name">$</span>; <span class="org-builtin">echo</span> main &gt; 1.txt; mkbeagrepidx; beagrep -e <span class="org-string">'main'</span> --grep <span class="org-string">'--color=auto'</span>; true; <span class="org-builtin">cd</span> ..; rm $<span class="org-variable-name">$</span> -rf
</pre>
</div>

<p>
If beagrep has been installed correctly, at the end of the above
command's output, you should see something like
<code>/tmp/11468/1.txt:1:main</code>.
</p>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Create index</h3>
<div class="outline-text-3" id="text-3-2">
<p>
In your source code directory, using android as example: 
</p>

<div class="org-src-container">

<pre class="src src-sh"><span class="org-builtin">cd</span> ~/src/android
mkbeagrepidx
</pre>
</div>

<p>
This step will cost you quite some time, under my Linux indexing
Android cost me about half an hour (it's about the same time you run
grep directly on android source). So I'd advise you create a cron job
to do it at midnight.
</p>

<p>
It takes about 8 minutes to index linux kernel (v3.6-rc6):
</p>

<pre class="example">
Debug: IndexWorker Done
Debug: Elapsed time 478.01s.
</pre>

<p>
But the good news is if indexing has already been done before, there
re-indexing will only work on those updated files based on file
time-stamp. So it will cost you only a few minutes to re-index the
whole Android source.
</p>

<p>
Even better, after an initial indexing, you can do a sub-folder
re-index, <code>mkbeagrepidx</code> will ask you if you want to update the index
found for upper directory. This generally only takes seconds depending
on the size of the sub-folder.
</p>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Man page for mkbeagrepidx</h3>
<div class="outline-text-3" id="text-3-3">
<p>
mkbeagrepidx is a simple wrapper over beagrep-build-index. You can
configure it for which directories to ignore using
<code>&#x2013;deny-directory-pattern</code> option. By default,
</p>

<ul class="org-ul">
<li>The <code>$PWD/out</code> is ignored, because it contains android build output
</li>
<li>The */.git is ignored, because of well known reason
</li>
<li>The */.repo is ignored, for the same reason.
</li>
</ul>

<p>
The syntax is comma separated shell glob patterns, and you can check
how it is converted into regular expression by examining the beginning
of mkbeagrepidx output:
</p>

<pre class="example">
Always: Will ignore directories matching regular expression: ^(?:/home/bhj/tmp/test/out)$|^(?:.*/\.repo)$|^(?:.*/\.git)$
</pre>

<p>
You can customize it using several ways, in the order of increasing
priority:
</p>

<ul class="org-ul">
<li>Not customize it, then the default

<pre class="example">
"$PWD/out,*/.repo,*/.git"
</pre>

<p>
will be used.
</p>
</li>

<li>Override it in <code>~/.mkbeagrepidx.rc</code>, setting the <code>BEAGREP_IGNORE_DIR_PATTERNS</code> environment variable:

<div class="org-src-container">

<pre class="src src-sh"><span class="org-builtin">export</span> <span class="org-variable-name">BEAGREP_IGNORE_DIR_PATTERNS</span>=<span class="org-string">"$PWD/out,*/.repo,*/.git"</span>
</pre>
</div>
</li>

<li>Override it in the .mkbeagrepidx.rc in the current working directory, same as the above.
</li>

<li>Override it on the command line (you must repeat the default pattern
because it won't append):

<div class="org-src-container">

<pre class="src src-sh">mkbeagrepidx --deny-directory-pattern <span class="org-string">"$PWD/out,*/.repo,*/.git,*/.svn"</span>
</pre>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> Searching using beagrep</h3>
<div class="outline-text-3" id="text-3-4">
<p>
Under your source code directory:
</p>
<div class="org-src-container">

<pre class="src src-sh"><span class="org-builtin">cd</span> ~/src/android
beagrep -e <span class="org-string">"readlink"</span>
</pre>
</div>
</div>

<div id="outline-container-sec-3-4-1" class="outline-4">
<h4 id="sec-3-4-1"><span class="section-number-4">3.4.1</span> Man page for beagrep</h4>
<div class="outline-text-4" id="text-3-4-1">
<p>
Here's a list of all arguments that beagrep takes:
</p>

<pre class="example">
beagrep -e REGEXP_MATCH [-p REGEXP_PATH] [-a ADDITIONAL_WORDS] [-v REGEXP_REVERSE_PATH] [-i] [-f] [-l] [--grep GREP_OPTIONS] [-a]
</pre>

<dl class="org-dl">
<dt> -e <code>REGEXP_MATCH</code> </dt><dd>This is the minimum required arguments. For e.g., <code>beagrep -e readlink</code>

<p>
The <code>REGEXP_MATCH</code> serves 2 purposes:
</p>

<ul class="org-ul">
<li>First, it is computed into whole words for querying beagle. For
e.g., <code>l] [&#x2013;grep GREP_OPTIONS]</code> above should be matched with
the following REGEXP: <code>l\] \[&#x2013;grep GREP_OPTIONS\]</code>, but it
should be converted into 4 words: <code>l grep GREP OPTIONS</code> for
beagle.
</li>

<li>Second, it is used as the regexp for grep to work on.
</li>
</ul>
</dd>

<dt> -a <code>ADDITIONAL_WORDS</code> </dt><dd>means to add more words into the beagle
query. This is useful by increasing the work beagle need to do,
but reduce the possible work set grep need to work on.
</dd>

<dt> -p <code>REGEXP_PATH</code> </dt><dd>means to limit the search result to those files whose path-name matches <code>REGEXP_PATH</code>.
</dd>

<dt> -v <code>REGEXP_REVERSE_PATH</code> </dt><dd>means to exclude those matched files whose path-name matches <code>REGEXP_REVERSE_PATH</code>.
</dd>

<dt> -i </dt><dd>means to do case insignificant grep.
</dd>

<dt> -f </dt><dd>means to do the match in file-names only. For example, <code>beagrep
        -e readlink -f</code> will only show results like readlink.h and
readlink.c.

<p>
This is very useful for finding files. Note that when <code>-f</code> is
used, the beagle querying words will be computed differently:
only the basename will be used, and <code>filename:</code> is prepended
onto each words.
</p>
</dd>

<dt> -l </dt><dd>means to list the beagle matched list of files directly, without running grep to match on them.
</dd>

<dt> &#x2013;grep <code>GREP_OPTIONS</code> </dt><dd>means to pass additional arguments to the
grep invocation. For e.g., the <code>-l</code> argument can be passed to
beagrep directly, or it can be passed using <code>&#x2013;grep</code>, they mean different things:

<p>
<code>beagrep -e "hello world" -l</code> will show a file containing "hello
wonderful world", but <code>beagrep -e "hello world" &#x2013;grep -l</code> will
not show that file as a match.
</p>
</dd>
</dl>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> How does it work?</h2>
<div class="outline-text-2" id="text-4">
<p>
beagrep is a very practical software, it works because of the following observations:
</p>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> grep patterns are usually simple</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Or rather, they can be decomposed into several simple sub-patterns: whole words.
</p>

<p>
For example, to grep such a seemingly complex pattern in Android source code:
</p>

<pre class="example">
"JsonToValue(\"\\\\\"hello world\\\\\"\","
</pre>

<p>
In fact, it contained some simpler sub-patterns, i.e., those 3
wholesome English words: <code>JsonToValue</code> <code>hello</code> <code>world</code>. For a file to
match this complex pattern, one necessary but not sufficient condition
is for this file to contain all these 3 words. And what is good for
this job? A search engine! Using beagle, the parent project for
beagrep, a desktop search engine, you can find which files (actually,
which file in this case) contained these 3 words in a blink of the
eyes.
</p>

<p>
Only 1 file contained all 3 words:
</p>

<pre class="example">
$beagrep-files 'JsonToValue hello world '
Beagrep index found at /home/bhj/.cache/for-code-reading//home/bhj/src/gingerbread-tegra/.beagrep
/home/bhj/src/gingerbread-tegra/external/chromium/base/json/json_reader_unittest.cc
/dev/null
</pre>

<p>
So, you can imagine how quick it is to run <code>grep</code> on the set of files containing all required words:
</p>

<pre class="example">
beagrep -e "JsonToValue(\"\\\\\"hello world\\\\\"\","
pat is: 'JsonToValue("\\"hello world\\"",'.
beagrep query argument `JsonToValue hello world '
Beagrep index found at /home/bhj/.cache/for-code-reading//home/bhj/src/gingerbread-tegra/.beagrep
/home/bhj/src/gingerbread-tegra/external/chromium/base/json/json_reader_unittest.cc:168:  root.reset(JSONReader().JsonToValue("\"hello world\"", false, false));
Unmatched ( in regex; marked by &lt;-- HERE in m/JsonToValue( &lt;-- HERE ""hello world"",/ at /home/bhj/bin/beagrep line 98.
</pre>

<p>
To summarize, complete words are what search engines are good for, and
fortunately, when grepping source code, we almost always grep using
whole words, instead of sub-words. For e.g., this evil pattern
<code>r.*e.*a.*d.*l.*i.*n.*k</code> can match our <code>readlink</code>, but do you really
need that power of <code>grep</code>?
</p>
</div>

<div id="outline-container-sec-4-1-1" class="outline-4">
<h4 id="sec-4-1-1"><span class="section-number-4">4.1.1</span> BTW, creating the regexp pattern automatically in Emacs</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
From the example above, you can see the actual matched string is:
</p>

<pre class="example">
JsonToValue("\"hello world\"",
</pre>

<p>
but because of meta characters in regexp and shell, the regexp pattern for beagrep to work on is a lot more complex:
</p>

<pre class="example">
"JsonToValue(\"\\\\\"hello world\\\\\"\","
</pre>

<p>
It'd be tragedy if you need type all those <code>\</code> characters by
yourself. So of course I didn't. In fact, when you work in Emacs,
after you marked some text and press <code>C-u M-x grep</code>, Emacs will
correctly add the <code>\</code> -s for you, to convert this plain text into a
matching regexp (which can be passed to grep by the shell).
</p>

<p>
Note that last time I checked, the Emacs grep regexp generation code
has some bugs, so I rolled my own fix for it, you can check my <a href="https://github.com/baohaojun/system-config/raw/master/.emacs">.emacs</a>
for definition of <code>grep-default-command</code> and
<code>grep-shell-quote-argument</code>.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> grep keywords are usually interesting</h3>
<div class="outline-text-3" id="text-4-2">
<p>
beagrep can greatly quicken the speed of grep, only because it can
greatly reduce the working set of files for grep.
</p>

<p>
Note that you need provide interesting words to search for so as to
<b>greatly</b> reduce the working set. By interesting I mean non-common.
</p>

<p>
For e.g., say you want to grep <code>is</code>. This word is so common in English
that almost all files would probably contain it (source code file will
probably contain it in comments). Then you are basically running grep
nakedly on the whole android source.
</p>

<p>
Fortunately, this requirement is easy to meet. In the first place, you
probably don't want to grep for common words; and even if you do need
to, you probably won't grep for one common word <b>alone</b>, which is very
uninteresting; thirdly, even if you do need to <code>grep</code> for a common
word alone, you can provide more words for <code>beagrep</code> to work on by
using its <code>-a</code> option (see the manpage above).
</p>

<p>
So:
</p>

<ul class="org-ul">
<li>Don't grep for <code>include</code> alone, because almost all C/C++ source and
header files contain it.
</li>

<li>Don't grep for <code>import</code> alone, because almost all java source files
contain it.
</li>
</ul>

<p>
And so on.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Other projects using beagrep</h2>
<div class="outline-text-2" id="text-5">
<p>
Because beagrep is so fast, I have used it in a couple other projects/tools.
</p>
</div>

<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> offline Wikipedia</h3>
<div class="outline-text-3" id="text-5-1">
<p>
I added CJK character support into beagrep so that both English and
Chinese offline Wikipedia can be browsed and subject-searched.
</p>

<p>
Check it out at <a href="https://github.com/baohaojun/system-config">https://github.com/baohaojun/system-config</a>, sorry I
didn't make it a stand-alone project, it's under the
<code>gcode/offline.wikipedia</code> directory.
</p>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> <code>grep-func-call</code> and <code>grep-func-call-all</code></h3>
<div class="outline-text-3" id="text-5-2">
<p>
The latter used beagrep and ctags-exuberant to search for which
functions called a specific function. It's under the <code>bin/</code> directory.
</p>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> Generate call graph</h3>
<div class="outline-text-3" id="text-5-3">
<p>
This is a tool to generate a call graph for the software project you
want. I have found its effectiveness is to be questioned, but you can
see a picture below:
</p>


<div class="figure">
<p><img src="../../../../images/post/call-graph.png"  alt="call-graph.png"/></p>
</div>

<p>
This picture is generated for the adb sub-project in android code. You
can see which functions are calling <code>adb_connect</code>, and which functions
are called by it.
</p>

<p>
It is generated using beagrep + ctags-exuberant + graphviz, using my
wrap scripts like following in the android/system/core directory:
</p>

<div class="org-src-container">

<pre class="src src-sh">generate-call-graph.pl &gt; call_graph.org
dot-partition.pl call_graph.dot -s adb_connect -m 1 -r 2
</pre>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
Here's how I run <code>grep</code> in Android source tree: <code>time grep
          -I -r &#x2013;exclude-dir=.git &#x2013;exclude-dir=.repo -e readlink</code>
<code>~/src/android</code>. The first time it took 5m20s, second time
1m21s, and third time 3.5s, and it can't be reduced much
further. The result is retrieved on a ThinkPad T420 with 8G
memory. One thing notable here I think is that it could
require multiple runs to reach the minimum 3.5s. Another
thing is I tried it multiple times on my MacbookAir with
about the same debian installation, <code>grep</code> always takes
about 1m as the minimum. Was it because less memory (only 4G
for MacbookAir), or was it because SSD and thus different
caching strategy? It eludes me. (Edit: it is because of cpu
freq is locked at 800MHz, see <a href="../../../2013/05/03/beagrep-even-faster2.html">beagrep performance tuning on MacbookAir+Linux</a>.
</p>
<nav>
  <ul class="pager">
    <li class="prev_post">
      <a href="../../../../meta/Archive.html"> <!-- prev-url -->
        <i class="icon-chevron-left">《</i>
        Archive <!-- prev-title -->
      </a>
    </li>
    <li class="next_post" style="text-align: right;">
      <a href="index.html"> <!-- next-url -->
        My Page on Github <!-- next-title -->
        <i class="icon-chevron-right">》</i>
      </a>
    </li>
  </ul>
</nav></div>


</div>
</div></div>
<!-- {%html-mode%} -->

<div id="disqus_container">
  <a href="#" class="right disqus" onclick="return false;">DISQUS!</a>
  <div style="margin-bottom:20px">
    <script type="text/javascript" charset="utf-8">
      (function(){
      var _w = 86 , _h = 16;
      var param = {
      url:location.href,
      type:'6',
      count:'', /**是否显示分享数，1显示(可选)*/
      appkey:'', /**您申请的应用appkey,显示分享来源(可选)*/
      title:'', /**分享的文字内容(可选，默认为所在页面的title)*/
      pic:'', /**分享图片的路径(可选)*/
      ralateUid:'1611427581', /**关联用户的UID，分享微博会@该用户(可选)*/
      language:'zh_cn', /**设置语言，zh_cn|zh_tw(可选)*/
      rnd:new Date().valueOf()
      }
      var temp = [];
      for( var p in param ){
      temp.push(p + '=' + encodeURIComponent( param[p] || '' ) )
      }
      document.write('<iframe allowTransparency="true" frameborder="0" scrolling="no" src="http://hits.sinajs.cn/A1/weiboshare.html?' + temp.join('&') + '" width="'+ _w+'" height="'+_h+'"></iframe>')
      })()
    </script>
  </div>
  <div id="disqus_thread"></div>
</div>

</div> <!-- bhj_leftpane -->
<div id="sidebar"><div id="sidebar2">


  <!-- Begin #profile-container -->

   <div id="profile-container"><h2 class="sidebar-title">About Me</h2>
<dl class="profile-datablock"><dt class="profile-img"><a href="/images/bhj.png""><img src="/images/bhj-thumb.png" alt="My Photo" height="58" width="80"></a></dt>
<dd class="profile-data"><strong>Name:</strong> <a rel="author" href="https://www.github.com/baohaojun"> Bao Haojun </a></dd>
<dd class="profile-data"><strong>Location:</strong>  Beijing, China </dd></dl>

<p class="profile-link"><a rel="author" href="/blog/2011/12/23/index.html">View my complete profile</a></p></div>

  <!-- End #profile -->



  <h2 class="sidebar-title">Feeds</h2>
    <ul>
        <li><a href="/atom.xml">Atom</a></li>
    </ul>

  <h2 class="sidebar-title">Projects</h2>
    <dl>
        <dt><a href="/blog/2011/12/23/beagrep.html"> Beagrep </a></dt>
        <dd> Grep 2G source code in 0.23 second </dd>

        <dt><a href="/blog/2013/04/13/skeleton-complete.html"> Skeletom-complete.el </a></dt>
        <dd> Type a bare skeleton, complete to a symbol/partial line/sexp/paragraph </dd>

        <dt><a href="/blog/2011/12/28/org-jira.html"> Org-jira.el </a></dt>
        <dd> Use JIRA with org-mode </dd>
    </dl>

  <h2 class="sidebar-title">Previous Posts</h2>
    <ul id="recently">
        
    </ul>


  <!--
  <p>This is a paragraph of text that could go in the sidebar.</p>
  -->



</div></div>
<!-- End #sidebar -->
</div> <!-- End #bhj_article -->
<!-- {%/html-mode%} -->
<div id="postamble" class="status">
<!-- {%html-mode%} -->

<script src="/js/post.js" type="text/javascript"></script>


<!-- {%/html-mode%} -->
</div>
</body>
</html>
