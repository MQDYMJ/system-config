#+title: A script to use org-mode for editing confluence pages

The browser editing features are so bad, I can't stand using it for editing confluence pages, even though it is WYSIWYG.

I must use org-mode, it sounds crazy, I know.

There are already many confluence CLI tools, such as [[https://github.com/RaymiiOrg/confluence-python-cli][this one]] (search for [[https://github.com/search?q=confluence+cli][confluence in github]], and you will find a lot of projects).

My script will make it easy for using org-mode to edit confluence pages.

This script is work in progress, I will be constantly updating it.

* Sub Commands

I will mimic the CLI interface of [[https://github.com/RaymiiOrg/confluence-python-cli][confluence-python-cli]], i.e., provide many sub-commands that do different basic things, and also some sub-commands that do more advanced things, such as “editing a page with org-mode”.

The most needed sub-commands are these, I think:

- Download a page as html
- Convert a html page to org-mode (using pandoc)
- Edit the page in org-mode
- Convert the org-mode page back to html
- Upload the html to update the page
- Handle images in the page (automatically download/upload them as attachments)

* Download a Page

This script will download a page, including it's content（using the confluence =body.editor=, as I find it to be closest to real html and thus the simplest to deal with), and all attachment.

It will download the page into a directory that is arranged according to it's “Ancestors”, i.e., its path in the wiki spaces.

For e.g., if there's a wiki space named Hello, and there's a page named World under space Hello, then World will be downloaded into ${KUNGFU_TOPDIR}/Hello/World/content.html.

#+name: download-a-page
#+BEGIN_SRC perl
  use v5.10;
  use HTTP::Request::Common;
  use LWP::UserAgent;
  use JSON;
  use File::Path qw(make_path);
  use File::Basename;
  use Encode;

  sub kungfu_url_for_api($) {
      (my $api_path = $_[0]) =~ s,^/,,;

      my $auth_str = sprintf "%s:%s@", $ok_username, $ok_password;
      (my $scm_confluence_site = $ok_wikiurl) =~ s,(https?://),$1$auth_str,;
      return "${scm_confluence_site}/${api_path}";
  }

  sub get($) {
      my $ua = LWP::UserAgent->new;
      my $api = $_[0];
      my $url = kungfu_url_for_api($api);
      my $response = $ua->request(GET $url);
      if ($response->code != 200) {
          die "Can't get $api: code is " . $response->code;
      }

      return $response;
  }

  sub save_to_file($$) {
      my ($file, $content) = @_;
      open(my $f, ">$file")
          or die "Can't open $file for write";
      print $f $content;
      close($f);
  }

  sub ok_get1page(@) {
      ## start code-generator "^\\s *#\\s *"
      # generate-getopt -s perl -l -P p:page-id
      ## end code-generator
      ## start generated code
      use Getopt::Long;

      Getopt::Long::Configure("posix_default");

      local @ARGV = @_;

      my $page_id = "";

      GetOptions (
          'page-id|p=s' => \$page_id,
          'help|h!' => \&handler_help,
          );

      sub handler_help {
          print ;
          print "\n\n选项和参数：\n";
          printf "%6s", '-p, ';
          printf "%-24s", '--page-id=PAGE-ID';
          if (length('--page-id=PAGE-ID') > 24 and length() > 0) {
              print "\n";
              printf "%30s", "";
          }
          printf "%s", ;
          print "\n";

          exit(0);
      }

      ## end generated code

      my $page_api = "rest/api/content/${page_id}?expand=body.editor,version,ancestors";

      my $response = get($page_api);
      my $page_object = decode_json $response->content;

      my @dirs = (".");
      my $path = "";
      for my $ancestor (@{$page_object->{ancestors}}) {
          (my $dir = $ancestor->{title}) =~ s,/,%,g;
          push @dirs, $dir;
      }

      (my $title = $page_object->{title}) =~ s,/,%,g;
      push @dirs, ${title};
      $path = join('/', @dirs);

      make_path($path);
      chdir($path)
          or die "Can't chdir $path";

      save_to_file("content.html", $page_object->{body}{editor}{value});
      save_to_file("version.txt", $page_object->{version}{number});
      download_all_attachments($page_id);
      rewrite_html_after_download();
  }

  sub download_1_file($) {
      my ($download_path) = @_;

      (my $filename = $download_path) =~ s/\?.*//;
      $filename = "./$filename";
      make_path("./" . dirname($filename));
      if (-e $filename) {
          return;
      }
      my $response = get($download_path);
      save_to_file("$filename", $response->content);
  }

  sub download_all_attachments($) {
      my ($page_id) = @_;
      my ($api_path) = "rest/api/content/${page_id}/child/attachment";
      my $response = get($api_path);
      my $object = decode_json $response->content;

      for my $attachment (@{$object->{results}}) {
          my $download_path = $attachment->{_links}{download};
          download_1_file($download_path);
      }
  }

  use Mojo::DOM;
  sub rewrite_html_after_download() {
      open(my $html, "<content.html")
          or die "Can't open content.html for read";

      my $html_str = join "", <$html>;
      $html_str = decode_utf8 $html_str;
      close($html);

      save_to_file("content-after-download.html", $html_str);

      my $dom = Mojo::DOM->new($html_str);
      $dom->find('img')->each(
          sub {
              my $src = $_->{src};
              if ($src =~ m,^/download/,) {
                  $src =~ s,\?.*,,;
                  if (not -e ".$src") {
                      download_1_file($src);
                  }
                  $src = ".$src";
                  $_->{src} = $src;
              }
          });
      save_to_file("content.html", encode_utf8 $dom);
  }

  sub rewrite_html_for_update() {
      open(my $html, "<content.html")
          or die "Can't open content.html for read";
      my $html_str = join "", <$html>;
      close($html);

      $html_str = decode_utf8 $html_str;
      my $dom = Mojo::DOM->new->xml(1)->parse($html_str);
      $dom->find('img')->each(
          sub {
              my $src = $_->{src};
              if ($src =~ m,^\./download/,) {
                  $src =~ s/^\.//;
              }
              $_->{src} = $src;
          }
          );
      save_to_file("content.html", encode_utf8 $dom);
  }

  sub read_file($) {
      my $file = $_[0];
      open(my $f, "<$file")
          or die "Can't open $file for reading";

      my $str = join "", <$f>;
      close($f);
      return $str;
  }

  sub update_1_page($) {
      my ($page_id) = @_;
      my $page_api = "rest/api/content/${page_id}?expand=body.editor,version,title";

      my $response = get($page_api);
      my $page_object = decode_json $response->content;

      $page_object->{body}{editor}{value} = read_file("content.html");
      $page_object->{version}{number}++;

      my $ua = LWP::UserAgent->new;
      my $request = PUT kungfu_url_for_api("rest/api/content/${page_id}"), 'Content-Type' => 'application/json', Content => encode_json $page_object;

      my $response = $ua->request($request);
      say "PUT response code:" . $response->code;
  }
#+END_SRC

* e

This script will download a page, convert it to org-mode, edit it in
org-mode, export it to html, and then update the original page (with
the newly exported html).

There, we will need a emacs-lisp script to convert an .org file to .html file, but with the html body only (i.e., without =<html>= and =<head>=).

Now, this emacs-lisp script first.

#+name: emacs-kungfu-export
#+BEGIN_SRC emacs-lisp
  (defun org-kungfu--orgtext-to-html (orgtext)
    (with-temp-buffer
      (insert orgtext)
      (let ((org-export-show-temporary-export-buffer t))
        (org-html-export-as-html nil nil nil t)
        (prog1
            (buffer-substring-no-properties (point-min) (point-max))
          (kill-buffer)))))

  (defun org-kungfu--export-to-html (file)
    (with-temp-buffer
      (insert-file file)
      (org-mode)
      (let ((html_str (org-kungfu--orgtext-to-html (buffer-substring-no-properties (point-min) (point-max))))
            (html_file (replace-regexp-in-string "\\.org" ".html" file)))
        (delete-region (point-min) (point-max))
        (fundamental-mode)
        (insert html_str)
        (write-file html_file))))

#+END_SRC

#+name: e
#+BEGIN_SRC perl :noweb yes
  sub e($) {
      my ($url) = @_;
      my $page_id;
      if ($url =~ m/pageid=(\d+)/i) {
          $page_id = $1;
      } else {
          die "Can't get page id from $url";
      }

      download_1_page($page_id);
      System("pandoc -f html -t org content.html > content.org");
      System("ew content.org");

      my $emacs_script = <<~'EOF64f308bc1e9a';
          ; {%emacs-lisp-mode%}
          (progn
            <<emacs-kungfu-export>>
            (org-kungfu--export-to-html "content.org"))
          ; {%/emacs-lisp-mode%}

          EOF64f308bc1e9a

      System("emacsclient", "-e", $emacs_script);
      rewrite_html_for_update();
      update_1_page($page_id);
  }
#+END_SRC

#+name: perl-lib-funcs
#+BEGIN_SRC perl
  sub System(@) {
      my $ret = system(@_);
      if ($ret != 0) {
          die "Failed to run: @_";
      }
  }

#+END_SRC

* Which sub command to call?

This is simple using Perl's “reflection”.
  #+name: which-to-call
  #+BEGIN_SRC perl
    my $sub_command = "ok_" . shift;

    if (not defined &$sub_command) {
        say "Can't find sub-command: $sub_command";
        &$handler_help();
    }

    $sub_command = \&{$sub_command};
    &$sub_command(@ARGV);

  #+END_SRC
** help for sub commands
   #+name: subcmd-helps
   #+BEGIN_SRC perl
     sub subcmd_help() {
         my $top_help_str = <<~'EOF';
             Usage: org-kungfu [GLOBAL_OPTIONS]... SUB_COMMAND SUBCMD_ARGS...
             Here's the list of sub-commands:
             EOF

         my @subcmd_help_strs;
         my %subcmd_helpstr_map = (
             addpage => "Add a page",
             copypage => "Copy a page",
             updatepage => "Update a page",
             listpages => "List pages in one or all spaces",
             removepage => "Remove a page",
             getpagecontent => "Get page content",
             getpagesummary => "Get page summary",
             listspaces => "List all spaces",
             addspace => "Add a space",
             removespace => "Remove a space",
             adduser => "Add a user",
             removeuser => "Remove a user",
             deactivateuser => "Deactivate a user",
             reactivateuser => "Reactivate a user",
             changeuserpassword => "Change user password",
             addgroup => "Add a goup",
             removegroup => "Remove a goup",
             listgroups => "List all goup",
             listusers => "List all users",
             getallpages => "Save all pages to local files.",
             addusertogroup => "Add user to a group",
             removeusergromgroup => "Remove user from a group",
             listusergroups => "List groups user is in",
             );

         my %help_printed_map;

         for my $subcmd ((sort {$a cmp $b} grep {m/^ok_/} keys %::), (sort {$a cmp $b} keys %subcmd_helpstr_map)) {
             (my $raw_subcmd = $subcmd) =~ s,^ok_,,;
             $subcmd = "ok_$raw_subcmd";
             if ($help_printed_map{$raw_subcmd}) {
                 next;
             } else {
                 $help_printed_map{$raw_subcmd} = 1;
             }

             my $subcmd_help_str = $subcmd_helpstr_map{$raw_subcmd} ||
                 "NO DESCRIPTION.";

             if (not defined &$subcmd) {
                 $subcmd_help_str .= " (NO DEFINITION)"
             }

             push @subcmd_help_strs, sprintf("    %s\n\t%s", $raw_subcmd, $subcmd_help_str);
         }

         return join "\n", $top_help_str, @subcmd_help_strs;
     }
   #+END_SRC
** The final script

#+name: read-only
#+BEGIN_SRC sh
# Local Variables: #
# eval: (read-only-mode 1) #
# End: #
#+END_SRC

#+name: old-code
#+BEGIN_SRC sh
  #!/bin/bash

  # Given a page, I will edit this
#+END_SRC

#+name: global-args
#+BEGIN_SRC perl
  use strict;

  ## start code-generator "^\\s *#\\s *"
  # generate-getopt -P -s perl -p ok \
  # '?subcmd_help()' \
  # u:username '?"Login Username"' \
  # p:password '?"Login Password"' \
  # w:wikiurl '?"Wiki URL (only FQDN, no / and such)"' \
  # vverbose '?"Verbose debug output"'
  ## end code-generator
  ## start generated code
  use Getopt::Long;

  Getopt::Long::Configure("posix_default");



  my $ok_password = "";
  my $ok_username = "";
  my $ok_verbose = 0;
  my $ok_wikiurl = "";

  my $handler_help = sub {
      print subcmd_help();
      print "\n\n选项和参数：\n";
      printf "%6s", '-p, ';
      printf "%-24s", '--password=PASSWORD';
      if (length('--password=PASSWORD') > 24 and length("Login Password") > 0) {
          print "\n";
          printf "%30s", "";
      }
      printf "%s", "Login Password";
      print "\n";
      printf "%6s", '-u, ';
      printf "%-24s", '--username=USERNAME';
      if (length('--username=USERNAME') > 24 and length("Login Username") > 0) {
          print "\n";
          printf "%30s", "";
      }
      printf "%s", "Login Username";
      print "\n";
      printf "%6s", '-v, ';
      printf "%-24s", '--[no]verbose';
      if (length('--[no]verbose') > 24 and length("Verbose debug output") > 0) {
          print "\n";
          printf "%30s", "";
      }
      printf "%s", "Verbose debug output";
      print "\n";
      printf "%6s", '-w, ';
      printf "%-24s", '--wikiurl=WIKIURL';
      if (length('--wikiurl=WIKIURL') > 24 and length("Wiki URL (only FQDN, no / and such)") > 0) {
          print "\n";
          printf "%30s", "";
      }
      printf "%s", "Wiki URL (only FQDN, no / and such)";
      print "\n";

      exit(0);
  };

  GetOptions (
      'password|p=s' => \$ok_password,
      'username|u=s' => \$ok_username,
      'verbose|v!' => \$ok_verbose,
      'wikiurl|w=s' => \$ok_wikiurl,
      'help|h!' => \&$handler_help,
      );


  ## end generated code
  use v5.10;

  my %file_config;
  use Config::Simple;

  my ($config_file) = glob "~/.local-config/etc/org-kungfu.rc";

  if (-e $config_file) {
      Config::Simple->import_from($config_file, \%file_config);
  }

  if (not $ok_password) {
      $ok_password = $file_config{"ok.password"};
  }

  if (not $ok_password) {
      say "Must specify the wiki password";
      &$handler_help(1)
  }

  if (not $ok_username) {
      $ok_username = $file_config{"ok.username"};
  }

  if (not $ok_username) {
      say "Must specify the wiki username";
      &$handler_help(1);
  }

  if (not $ok_wikiurl) {
      $ok_wikiurl = $file_config{"ok.wikiurl"};
  }

  if (not $ok_wikiurl) {
      say "Must specify the wiki url";
      &$handler_help(1);
  }

  my $ok_topdir = $file_config{"ok.topdir"};
  if (not $ok_topdir) {
      $ok_topdir = glob("~/src/github/kungfu-edit");
  }

  use File::Path;
  make_path($ok_topdir);
  chdir($ok_topdir)
      or die "Can't chdir: $ok_topdir";

#+END_SRC

#+name: the-ultimate-script
#+BEGIN_SRC perl :tangle ~/system-config/bin/org-kungfu :comments link :shebang "#!/usr/bin/perl" :noweb yes
  <<global-args>>
  <<perl-lib-funcs>>
  <<download-a-page>>
  <<e>>
  <<subcmd-helps>>
  <<which-to-call>>
  <<read-only>>
#+END_SRC

#+results: the-ultimate-script


** TODO when downloading an attachment, should pay respect to the modificationDate.
Currently, I will not download an attachment file again if it already exist. Later, we should re-download it if it has been updated on the server side.
