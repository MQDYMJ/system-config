#+title: 安卓编译服务器、持续集成的设计与实现

* 现有的问题

1. 最为突出的问题，是安卓越来越庞大，编译时间越来越长。从安卓4.4升级到5.0之后，在咱们的编译服务器上（36核CPU、32G内存），编译时间直接从30分钟变成了1小时。在这种条件下，工程师的效率大打折扣。一旦开始编译，基本上电脑会变得奇慢，工程师不能再干其他事。

   这是一个很古老的问题，在2000年 Joel Spolsky （Joel on Software网站作者、Stack Exchange创始人）就写过一篇文章 [[http://www.joelonsoftware.com/articles/fog0000000023.html][“Daily Builds Are Your Friend”]]，其中提到 “我们曾经在办公室里放了一个仰卧起坐板，每次需要等待编译的时候就去做做仰卧起坐。编了几个月的程之后我拥有了杀手一样的腹肌”。

2. 我们的Build Server目前只做一天两次的Daily Build，其他时间都是空闲的，没有很好的利用起来。

3. 我们一直没有实现持续集成。在安卓的发源地谷歌，每一个Patch在工程师Review前都会先被Build机器人编译，没问题的话才会在Gerrit页面添加注释并提示工程师进行Review。


* 设计

** 前提

1. *不能影响CM现有的工作流程*

** 大纲

1. 系统会有一个daily的base build。

   这个跟CM的Build同步。这样大家都很清楚这个新系统的Base是哪个，可以从CM发布的包里去取manifest.xml。

2. 之后一整天的build，都会基于这个base，每个同事想提交一个新的build，都会基于这个base去做：

   - （初始条件：所有的代码已回归到base）

   - 打上同事提供的patch

   - 开始build

   - 如果成功，可以输出同事想要的文件，方便他测试、验证（一般情况下就是一个apk、boot.img等，特殊情况下可以提供整个system/data/root目录）

   - 如果失败，需要提供log供分析

   - 把所有的代码回归到base上，为下一个同事的build做准备

3. 在上面说的是同事主动提交patch(review地址)进行build，其有一些额外的需求，比如提供结果文件。也可以把这个系统稍微修改一下，让它进行自动的review验证。

4. 不同的产品、不同的线、不同的编译配置，需要有很多个base build，需要选择正确的base build。

   - 为了性能的关系，同一个base build可以考虑有多份，这样可以两个同事的编译可以并行的进行。

5. 需要确定review的git branch跟base build之间的关系。

6. 会用ccache进行编译优化

* 实现

** 创建一个新的base build

- Android 还是 OEM？

  repo init; repo sync 或者 git clone

- 哪个产品？

- 哪条线？还是说线已经包含了产品信息，所以就可以不分了。

以上可以称为base build信息

** 工程师提交一个review

比如：http://172.16.0.9:8080/#/c/46545

** 工程师提交一个build request，参数可以只指定review id。大部分情况下还需要加上要不要输出文件
比如：

remote-mm http://172.16.0.9:8080/#/c/46545

#+name: remote-mm
#+BEGIN_SRC sh
  function remote-mm() {
      ssh build build-request http://172.16.0.9:8080/#/c/47807/
  }
#+END_SRC

#+name: build-request
#+BEGIN_SRC sh
  function build-request() {
      ## start generated code
      TEMP=$(getopt -o m:hd:c:t: --long "method:,help,dir:,copy:,to:"  -n $(basename $0) -- "$@")
      method=mm
      mm_dir=
      copy=
      to=
      to_user=
      to_host=
      to_path=
      to_share=
      eval set -- "$TEMP"
      while true; do
          case "$1" in
              -m|--method)
                  method=$2
                  shift 2
                  ;;
              -h|--help)
                  cat <<EOF
  Usage: build-request -m|--method [mm|dep|full] [-d|--dir MM_DIR] [-c|--copy FILE|DIR]... [-t|--to COPY_TARGET] REVIEWS...

  You can use this command to submit a build request using a gerrit
  review, specify what to build, and what to copy back into your PC
  using share folder.

  -m|--method [mm|dep|full]
      MM means use android mm build
      DEP means build the whole dir, including DEPendencies
      FULL means to do a full build (need 5~8 minutes)

      Default is mm.

  [-d|--dir MM_DIR] Specify where to do the build, if you are using mm
      or partial build with dependencies resolved.

      Default is the git project if there is an Android.mk in it's top
      folder.

  [-c|--copy FILE|DIR]...  Specify what files/dirs to copy back. It must
      be like out/target/product/msm8974sfo_lte/XXX.

      You can specify it multiple times to copy more than 1 files.

  [-t|--to COPY_TARGET] Specify the share folder on your PC, it must be
      like: USER%PASSWORD@HOST:SHARE, where USER is your local username,
      PASSWORD is your samba share password, HOST is the IP address for
      your working Linux PC, and SHARE is the samba share folder's path
      on your Linux PC where you want the files to be copied.

      Note thate your password must not contain these characters: @%: ,
      because they will cause confusion.

  REVIEWS are gerrit review urls or ids, such as http://172.16.0.9:8080/47807/ or 47807

  EOF
                  exit
                  ;;
              -d|--dir)
                  mm_dir=$2
                  shift 2
                  ;;
              -c|--copy)
                  if test "$copy"; then
                      copy=("${copy[@]}" "$2")
                  else
                      copy=("$2")
                  fi
                  shift 2
                  ;;
              -t|--to)
                  to=$2
                  if ! echo "$to" | grep -i -q -P '^[a-z]+(%.*?)?@\d+\.\d+\.\d+\.\d+:'; then
                      die "$to is invalid, must match regeqp '^[a-z]+(%.*?)?@\d+\.\d+\.\d+\.\d+:' "
                  fi
                  to_user=${to%%%*}
                  to_password=${to#*%}
                  to_password=${to_password%@*}
                  to_host=${to#*@}
                  to_host=${to_host%%:*}
                  to_path=${to#*:}
                  to_share=${to_path%%/*}
                  to_path=${to_path#*/}
                  shift 2
                  ;;
              --)
                  shift
                  break
                  ;;
              *)
                  die "internal error"
                  ;;
          esac
      done
      ## end generated code

      num_reviews=$#

      for review_id in "$@"; do
          if [[ "$review_id" =~ http:// ]]; then
              review_id=$(basename "$review_id")
          fi

          if ! echo "$review_id" | grep -q -P '^\d+$'; then
              die "review_id $review_id is not a number."
          fi

          review_info=$(ssh smartisan gerrit query --current-patch-set $review_id)
          branch=$(echo "$review_info" | grep "^\s+branch:" -P | pn 2)
          project=$(echo "$review_info" | grep "^\s+project:" -P | pn 2)

          cd ~/buildfarm/sfo-rom
          path=$(my-rfa 'if test "$(git-remote-url|perl -npe s,.*//.*?/,,)" = '$project'; then pwd; fi')
          if test ! -d "$path"; then
              die "Can't decide the path for review id: $review_id"
          fi

          (
              cd "$path"
              rev=$(echo "$review_info" | grep "^\s+ref:" -P | pn 2)
              git fetch $(repo-remote) $rev
              git merge FETCH_HEAD || die "Can't merge the fetch head"
          )
      done

      if test "$method" = mm; then
          if test $num_reviews != 1; then
              die "mm can be used only if there is one review patch"
          fi

          if test -d "$mm_dir"; then
              (
                  cd "$mm_dir"
                  if ! is-a-subdir "$(readlink -f "$mm_dir")" ~/buildfarm/sfo-rom; then
                      die "$mm_dir is not in Android dir"
                  fi
                  mm
              )
          elif test -e "$path"/Android.mk; then
              (
                  cd $path
                  mm;
              )
          else
              die "Can't find Android.mk in $path for mm build"
          fi
      elif test "$method" = dep; then
          if test -d "$mm_dir"; then
              (
                  cd "$mm_dir"
                  if ! is-a-subdir "$(readlink -f "$mm_dir")" ~/buildfarm/sfo-rom; then
                      die "$mm_dir is not in Android dir"
                  fi
                  android-make -d .
              )
          else
              (
                  cd $path
                  android-make -d .
              )
          fi
      elif test "$method" = full; then
              android-make
      else
          die "Can't build with method '$method'"
      fi

      for c in "${copy[@]}"; do
          if ! is-a-subdir "$c" ~/buildfarm/sfo-rom/out; then
              die "$c to copy is not in Android dir"
          fi
          smbclient "//$to_host/$to_share" -U "$to_user%$to_password" -c "tarmode; recurse; prompt; cd \"$to_path\"; $(x=$c; while test ${x}y != .y; do x=$(dirname $x); echo mkdir $x\;; done|reverse) cd $(dirname $c); lcd $(dirname $c); mput $(basename $c)"
      done
  }
#+END_SRC


** 根据review id，计算出base build信息。

:+name: get-base-build.v1
#+BEGIN_SRC sh
  function get-base-build() {
      review_id=$1
      if [[ "$review_id" =~ http:// ]]; then
          review_id=$(basename "$review_id")
      fi

      review_info=$(ssh smartisan gerrit query review_id)

      branch=$(echo "$review_info" | grep "^\s+branch:" -P | pn 2)
      project=$(echo "$review_info" | grep "^\s+project:" -P | pn 2)

      # fix me: how to calculate the base build for this?
      echo ~/buildfarm/sfo-rom
  }
#+END_SRC

大概就是上面这样的，根据review地址计算出project和branch，然后就能得到是哪个base build。当然上面我最后作弊直接给了个地址。

最后，也可以让用户自己指定用哪个base build。当然，前提是需要有一个函数可以列出都有哪些base build。

:+name: list-base-builds
#+BEGIN_SRC sh
  function list-base-builds() {
      cd ~/buildfarm/
      for x in *; do
          if test -d "$x"; then
              echo "$x"
          fi
      done
  }

#+END_SRC


** 每天定时刷新base build

#+name: refresh-base-builds
#+BEGIN_SRC sh
  function refresh-base-builds() {
      cd ~/buildfarm/
      for x in */.repo/; do
          if test ! -d "$x"; then
              continue;
          fi
          (
              cd "$x"/manifests
              git reset --hard
              cd ../..
              android-make
              # fixme export the manifest.
          )
      done
  }
#+END_SRC

** 最终的版本：

#+name: the-ultimate-script
#+BEGIN_SRC sh :tangle ~/bin/abc :comments link :shebang "#!/bin/bash" :noweb yes
  # The name abc stands for Android Build Cake. Android Build is a piece
  # of Cake.

  # All bash scripts should start with ~set -e~ to fail early and loudly.
  set -e

 <<die>>

 <<remote-mm>>

 <<build-request>>

 <<get-base-build.v1>>

 <<list-base-builds>>

 <<refresh-base-builds>>

 <<which-to-call>>
#+END_SRC

** 一些辅助的函数

#+name: die
#+BEGIN_SRC sh
    function die() {
        echo Error: "$@"
        exit -1
    }

    function android-make() {
        command android-make -j8 "$@"
    }

    function is-a-subdir() {
        dir1=$(readlink -f "$1")
        dir2=$(readlink -f "$2")
        # test if dir1 is in a subdir of $dir2
        dir2=$dir2/
        if test -e "$dir1" -a -d "$dir2"; then
            if test "$(echo "$dir1" | cut -b 1-${#dir2})" = "${dir2}"; then
                return 0;
            fi
        fi
        return 1
    }
#+END_SRC

最后，决定该调用哪一个脚本：

#+name: which-to-call
#+BEGIN_SRC sh
  if test "$(readlink -f "$BASH_SOURCE")" = "$(readlink -f "$(echo "$0" | grep / || which "$0" 2>/dev/null)" )"; then
      if grep -q -P "^\s*function $1\s*\(" "$0" || test "$(basename $0)" = $1; then
          command=$1
          shift
          "$command" "$@"
      fi
  fi
#+END_SRC

* 功能检查

最后，要列一个todo list，看看哪些功能已经实现了，哪些功能还没有实现

** TODO 每天定时做full build
   - State "TODO"       from ""           [2015-02-15 Sun 09:56]
** TODO 做完full build之后，要把manifest.xml文件export出来，第二天就一直用这个做base
   - State "TODO"       from ""           [2015-02-15 Sun 09:57]
** TODO 做full build之前，要把manifest.xml文件恢复成服务器上的，确保能取到新代码
   - State "TODO"       from ""           [2015-02-15 Sun 09:57]
** TODO build失败的话，应该怎么做？可以细分一下
** TODO 确保每个bsp同事都可以使用这个脚本
** TODO 确保系统是安全的，不能让每个同事都有登录到服务器执行任意命令
** TODO OEM的编译也应该纳入此脚本
** TODO 根据branch自动分辨是哪个项目，是android还是oem
   - State "TODO"       from ""           [2015-02-15 Sun 10:07]
** TODO 每次有执行之后，都应该被记录，是谁执行的，执行了什么命令
