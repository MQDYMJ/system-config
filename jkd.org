#+title: JKD is Jira Keeps me Doing stuff, not Jeet Kune Do
This one is for using Jira on the command line, maybe also together with Emacs.

I still need a way to work with Jira, org-jira just can't fulfill my needs anymore.


* The dispatcher (copied from org-kungfu)

** Which sub command to call?

This is simple using Perl's “reflection”.
  #+name: which-to-call
  #+BEGIN_SRC perl
    my $sub_command = "jkd_" . shift;

    if (not defined &$sub_command) {
        say "Can't find sub-command: $sub_command";
        &$handler_help();
    }

    $sub_command = \&{$sub_command};
    &$sub_command(@ARGV);

  #+END_SRC
** help for sub commands
   #+name: subcmd-helps
   #+BEGIN_SRC perl
     sub subcmd_help() {
         my $top_help_str = <<~'EOF';
             Usage: jkd [GLOBAL_OPTIONS]... SUB_COMMAND SUBCMD_ARGS...
             Here's the list of sub-commands:
             EOF

         my @subcmd_help_strs;
         my %subcmd_helpstr_map = (
             update1page => "Update 1 page (html text and all images -- automatically upload as page attachments)",
             get1page => "Get 1 page (html text and all image attachments)",
             e => "Edit 1 page in emacs org-mode, download/edit/upload",
             );

         my %help_printed_map;

         for my $subcmd ((sort {$a cmp $b} grep {m/^jkd_/} keys %::), (sort {$a cmp $b} keys %subcmd_helpstr_map)) {
             (my $raw_subcmd = $subcmd) =~ s,^jkd_,,;
             $subcmd = "jkd_$raw_subcmd";
             if ($help_printed_map{$raw_subcmd}) {
                 next;
             } else {
                 $help_printed_map{$raw_subcmd} = 1;
             }

             my $subcmd_help_str = $subcmd_helpstr_map{$raw_subcmd} ||
                 "NO DESCRIPTION.";

             if (not defined &$subcmd) {
                 $subcmd_help_str .= " (NO DEFINITION)"
             }

             push @subcmd_help_strs, sprintf("    %s\n\t%s", $raw_subcmd, $subcmd_help_str);
         }

         return join "\n", $top_help_str, @subcmd_help_strs;
     }
   #+END_SRC
** The final script

#+name: read-only
#+BEGIN_SRC sh
# Local Variables: #
# eval: (read-only-mode 1) #
# End: #
#+END_SRC

#+name: old-code
#+BEGIN_SRC sh
  #!/bin/bash

  # Given a page, I will edit this
#+END_SRC

#+name: global-args
#+BEGIN_SRC perl
  use strict;
  use String::ShellQuote;

  ## start code-generator "^\\s *#\\s *"
  # generate-getopt -P -s perl -p jkd \
  # '?subcmd_help()' \
  # u:username '?"Login Username"' \
  # p:password '?"Login Password"' \
  # j:jiraurl '?"Jira URL (only FQDN, no / and such)"' \
  # vverbose '?"Verbose debug output"'
  ## end code-generator
  ## start generated code
  use Getopt::Long;

  Getopt::Long::Configure("posix_default");



  my $jkd_jiraurl = "";
  my $jkd_password = "";
  my $jkd_username = "";
  my $jkd_verbose = 0;

  my $handler_help = sub {
      print subcmd_help();
      print "\n\n选项和参数：\n";
      printf "%6s", '-j, ';
      printf "%-24s", '--jiraurl=JIRAURL';
      if (length('--jiraurl=JIRAURL') > 24 and length("Jira URL (only FQDN, no / and such)") > 0) {
          print "\n";
          printf "%30s", "";
      }
      printf "%s", "Jira URL (only FQDN, no / and such)";
      print "\n";
      printf "%6s", '-p, ';
      printf "%-24s", '--password=PASSWORD';
      if (length('--password=PASSWORD') > 24 and length("Login Password") > 0) {
          print "\n";
          printf "%30s", "";
      }
      printf "%s", "Login Password";
      print "\n";
      printf "%6s", '-u, ';
      printf "%-24s", '--username=USERNAME';
      if (length('--username=USERNAME') > 24 and length("Login Username") > 0) {
          print "\n";
          printf "%30s", "";
      }
      printf "%s", "Login Username";
      print "\n";
      printf "%6s", '-v, ';
      printf "%-24s", '--[no]verbose';
      if (length('--[no]verbose') > 24 and length("Verbose debug output") > 0) {
          print "\n";
          printf "%30s", "";
      }
      printf "%s", "Verbose debug output";
      print "\n";

      exit(0);
  };

  GetOptions (
      'jiraurl|j=s' => \$jkd_jiraurl,
      'password|p=s' => \$jkd_password,
      'username|u=s' => \$jkd_username,
      'verbose|v!' => \$jkd_verbose,
      'help|h!' => \&$handler_help,
      );


  ## end generated code
  use v5.10;

  my %file_config;
  use Config::Simple;

  my ($config_file) = glob "~/.config/org-kungfu/config.ini";

  if (-e $config_file) {
      Config::Simple->import_from($config_file, \%file_config);
  }

  if (not $jkd_password) {
      $jkd_password = $file_config{"jkd.password"};
  }

  if (not $jkd_password) {
      say "Must specify the wiki password";
      &$handler_help(1)
  }

  if (not $jkd_username) {
      $jkd_username = $file_config{"jkd.username"};
  }

  if (not $jkd_username) {
      say "Must specify the wiki username";
      &$handler_help(1);
  }

  if (not $jkd_jiraurl) {
      $jkd_jiraurl = $file_config{"jkd.jiraurl"};
  }

  if (not $jkd_jiraurl) {
      say "Must specify the wiki url";
      &$handler_help(1);
  }

  my $jkd_topdir = $file_config{"jkd.topdir"};
  if (not $jkd_topdir) {
      $jkd_topdir = glob("~/src/github/jkd-doujyou"); # doujyou is japanese for 道場
  }

  use File::Path;
  make_path($jkd_topdir);
  chdir($jkd_topdir)
      or die "Can't chdir: $jkd_topdir";

#+END_SRC

#+name: the-ultimate-script
#+BEGIN_SRC perl :tangle ./jkd :comments link :shebang "#!/usr/bin/env perl" :noweb yes
  <<global-args>>
  <<create-1-issue>>
  <<subcmd-helps>>
  <<which-to-call>>
  <<read-only>>
#+END_SRC

#+results: the-ultimate-script


#+name: read-only
#+BEGIN_SRC sh
# Local Variables: #
# eval: (read-only-mode 1) #
# End: #
#+END_SRC

* create 1 issue

#+name: create-1-issue
#+BEGIN_SRC perl
  use v5.10;
  use HTTP::Request::Common;
  use LWP::UserAgent;
  use JSON;
  use File::Path qw(make_path);
  use File::Basename;
  use Encode;

  sub jkd_url_for_api($) {
      (my $api_path = $_[0]) =~ s,^/,,;

      my $auth_str = sprintf "%s:%s@", $jkd_username, $jkd_password;
      (my $scm_jira_site = $jkd_jiraurl) =~ s,(https?://),$1$auth_str,;
      my $url = "${scm_jira_site}${api_path}";
      say STDERR "api: $url";
      return "$url";
  }

  sub get($) {
      my $ua = LWP::UserAgent->new;
      my $api = $_[0];
      my $url = jkd_url_for_api($api);

      my $response = $ua->request(GET $url);
      if ($response->code != 200) {
          die "Can't get $api: code is " . $response->code . ", url is $url";
      }


      return $response;
  }

  sub select_args(@) {
      ## start code-generator "^\\s *#\\s *"
      # generate-getopt -s perl -l -P p:prompt O:order-name
      ## end code-generator
      ## start generated code
      use Getopt::Long;

      Getopt::Long::Configure("posix_default");

      local @ARGV = @_;

      my $order_name = "";
      my $prompt = "";

      my $handler_help = sub {
          print ;
          print "\n\n选项和参数：\n";
          printf "%6s", '-O, ';
          printf "%-24s", '--order-name=ORDER-NAME';
          if (length('--order-name=ORDER-NAME') > 24 and length() > 0) {
              print "\n";
              printf "%30s", "";
          }
          printf "%s", ;
          print "\n";
          printf "%6s", '-p, ';
          printf "%-24s", '--prompt=PROMPT';
          if (length('--prompt=PROMPT') > 24 and length() > 0) {
              print "\n";
              printf "%30s", "";
          }
          printf "%s", ;
          print "\n";

          exit(0);
      };

      GetOptions (
          'order-name|O=s' => \$order_name,
          'prompt|p=s' => \$prompt,
          'help|h!' => \&$handler_help,
          );


      ## end generated code

      my @command = (
          "select-args", "-p", "$prompt",
          "-O", "$order_name",
          @ARGV
          );

      my $command = join(" ", shell_quote(@command));
      my $res = qx($command);

      return $res;
  }

  sub jkd_select_project(@) {
      my $projects_resp = get("rest/api/2/project/");

      my %project_key_name_map;
      my $projects_object = decode_json $projects_resp->content;

      for my $project (@{$projects_object}) {
          $project_key_name_map{$project->{key}} = $project->{name};
      }

      return select_args("-p", "Which project do you want to use?",
                  "-O", "select-jira-project",
                  sort {$a cmp $b} map {sprintf "%s: %s", $_, $project_key_name_map{$_}} keys %project_key_name_map
          );
  }

  sub jkd_get_issue_types(@) {
      ## start code-generator "^\\s *#\\s *"
      # generate-getopt -s perl -l p:project ttest-it
      ## end code-generator
      ## start generated code
      use Getopt::Long;

      Getopt::Long::Configure("default");

      local @ARGV = @_;

      my $project = "";
      my $test_it = 0;

      my $handler_help = sub {
          print ;
          print "\n\n选项和参数：\n";
          printf "%6s", '-p, ';
          printf "%-24s", '--project=PROJECT';
          if (length('--project=PROJECT') > 24 and length() > 0) {
              print "\n";
              printf "%30s", "";
          }
          printf "%s", ;
          print "\n";
          printf "%6s", '-t, ';
          printf "%-24s", '--[no]test-it';
          if (length('--[no]test-it') > 24 and length() > 0) {
              print "\n";
              printf "%30s", "";
          }
          printf "%s", ;
          print "\n";

          exit(0);
      };

      GetOptions (
          'project|p=s' => \$project,
          'test-it|t!' => \$test_it,
          'help|h!' => \&$handler_help,
          );


      ## end generated code

      my $project_meta_resp = get("rest/api/2/issue/createmeta?projectKeys=$project");
      my %jkd_project_issue_types_name_id_map;

      my $project_meta_obj = decode_json $project_meta_resp->content;
      for my $project (@{$project_meta_obj->{projects}}) {
          for my $issuetype (@{$project->{issuetypes}}) {
              my $name = $issuetype->{name};
              my $id = $issuetype->{id};
              $jkd_project_issue_types_name_id_map{$name} = $id;
              say "Got issue type: $name => $id";
          }
      }

      if ($test_it) {
          print join("\n",
                     map
                     {sprintf "%s: %s", $_, $jkd_project_issue_types_name_id_map{$_}}
                     keys %jkd_project_issue_types_name_id_map
              );
      }
      return %jkd_project_issue_types_name_id_map;
  }

  sub jkd_get_issue_fields(@) {
      ## start code-generator "^\\s *#\\s *"
      # generate-getopt -s perl -l p:project i:issue-type
      ## end code-generator
      ## start generated code
      use Getopt::Long;

      Getopt::Long::Configure("default");

      local @ARGV = @_;

      my $issue_type = "";
      my $project = "";

      my $handler_help = sub {
          print ;
          print "\n\n选项和参数：\n";
          printf "%6s", '-i, ';
          printf "%-24s", '--issue-type=ISSUE-TYPE';
          if (length('--issue-type=ISSUE-TYPE') > 24 and length() > 0) {
              print "\n";
              printf "%30s", "";
          }
          printf "%s", ;
          print "\n";
          printf "%6s", '-p, ';
          printf "%-24s", '--project=PROJECT';
          if (length('--project=PROJECT') > 24 and length() > 0) {
              print "\n";
              printf "%30s", "";
          }
          printf "%s", ;
          print "\n";

          exit(0);
      };

      GetOptions (
          'issue-type|i=s' => \$issue_type,
          'project|p=s' => \$project,
          'help|h!' => \&$handler_help,
          );


      ## end generated code

      my $issue_fields_resp = get("rest/api/2/issue/createmeta?projectKeys=${project}&issuetypeIds=${issue_type}&expand=projects.issuetypes.fields");

      return decode_json $issue_fields_resp->content;
  }


  sub jkd_c(@) { # create issue

      ## start code-generator "^\\s *#\\s *"
      # generate-getopt -s perl -l p:project i:issue-type-id
      ## end code-generator
      ## start generated code
      use Getopt::Long;

      Getopt::Long::Configure("default");

      local @ARGV = @_;

      my $issue_type_id = "";
      my $project = "";

      my $handler_help = sub {
          print ;
          print "\n\n选项和参数：\n";
          printf "%6s", '-i, ';
          printf "%-24s", '--issue-type-id=ISSUE-TYPE-ID';
          if (length('--issue-type-id=ISSUE-TYPE-ID') > 24 and length() > 0) {
              print "\n";
              printf "%30s", "";
          }
          printf "%s", ;
          print "\n";
          printf "%6s", '-p, ';
          printf "%-24s", '--project=PROJECT';
          if (length('--project=PROJECT') > 24 and length() > 0) {
              print "\n";
              printf "%30s", "";
          }
          printf "%s", ;
          print "\n";

          exit(0);
      };

      GetOptions (
          'issue-type-id|i=s' => \$issue_type_id,
          'project|p=s' => \$project,
          'help|h!' => \&$handler_help,
          );


      ## end generated code

      if (not $project) {
          ($project = jkd_select_project()) =~ s/:.*//;
      }

      if (not $issue_type_id) {
          my %jkd_project_issue_types_name_id_map = jkd_get_issue_types("-p", $project);
          my $issue_type_name = decode_utf8 select_args("-p", "Which type of issue do you want?", "-O", "select-issue-type", sort {$a cmp $b} keys %jkd_project_issue_types_name_id_map);
          $issue_type_id = $jkd_project_issue_types_name_id_map{$issue_type_name};
          say STDERR "issue_type_id is $issue_type_id, issue_type_name is '$issue_type_name'";
      }

      my $issue_fields_obj = jkd_get_issue_fields("-p", "$project", "-i", "$issue_type_id");

      my %required_fields;
      for my $project (@{$issue_fields_obj->{projects}}) {
          for my $it (@{$project->{issuetypes}}) {
              if ($it->{id} != $issue_type_id) {
                  next;
              }
              for my $field_key (keys %{$it->{fields}}) {
                  if ($it->{fields}{$field_key}{required}) {
                      if ($field_key eq 'project' || $field_key eq 'issuetype') {
                          next;
                      }
                      if ($it->{fields}{$field_key}{schema}{type} eq 'string') {
                          my @command = (
                              "ask-for-input-with-emacs", "-p", sprintf("Please input the %s", ($it->{fields}{$field_key}{name} or "$field_key (field has no name)"))
                              );
                          my $command = join(" ", shell_quote(@command));
                          $required_fields{$field_key} = qx($command);
                      } elsif ($it->{fields}{$field_key}{schema}{type} eq 'array' and
                               $it->{fields}{$field_key}{schema}{custom} eq "com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes") {
                          my $field_name = $it->{fields}{$field_key}{name};
                          my %allowed_values_map;
                          map { $allowed_values_map{$_->{value}} = $_->{id}} @{$it->{fields}{$field_key}{allowedValues}};
                          my @command = (
                              "select-args-n", "-p", decode_utf8("请输入你想要选择的 ") . "$field_name",
                              keys %allowed_values_map
                              );
                          my $command = join(" ", shell_quote @command);
                          my $values = decode_utf8 qx($command);
                          $required_fields{$field_key} = [];
                          for (split " ", $values) {
                              say "Working for $field_name: $_";
                              push @{$required_fields{$field_key}}, {id => $allowed_values_map{$_}} if ${allowed_values_map{$_}};
                          }
                      } else {
                          say $it->{fields}{$field_key}{name}, " scheme is ", $it->{fields}{$field_key}{schema}{type}, ", don't know how to deal";
                      }
                  }

              }
          }
      }

      $required_fields{project} = {
          key => $project,
      };

      $required_fields{issuetype} = {
          id => $issue_type_id,
      };

      my $ua = LWP::UserAgent->new;
      say "json is ", encode_json { fields => \%required_fields };

      my $request = POST jkd_url_for_api("rest/api/2/issue"),
          'Content-Type' => 'application/json',
          'Accept' => 'application/json',
          "charset" => "utf-8",
          Content => encode_json {
              fields => \%required_fields,
      };
      my $response = $ua->request($request);

      say "POST response code:" . $response->code, "result: ", $response->content;
  }

#+END_SRC
